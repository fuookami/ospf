/* automatically generated by rust-bindgen 0.57.0 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _CRT_INTERNAL_STDIO_SYMBOL_PREFIX: &'static [u8; 1usize] = b"\0";
pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION: u32 = 1;
pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR: u32 = 2;
pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS: u32 = 4;
pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 8;
pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS: u32 = 16;
pub const _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING: u32 = 32;
pub const _CRT_INTERNAL_SCANF_SECURECRT: u32 = 1;
pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS: u32 = 2;
pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 4;
pub const BUFSIZ: u32 = 512;
pub const _NSTREAM_: u32 = 512;
pub const _IOB_ENTRIES: u32 = 3;
pub const EOF: i32 = -1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 64;
pub const _IONBF: u32 = 4;
pub const L_tmpnam: u32 = 260;
pub const L_tmpnam_s: u32 = 260;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_SET: u32 = 0;
pub const FILENAME_MAX: u32 = 260;
pub const FOPEN_MAX: u32 = 20;
pub const _SYS_OPEN: u32 = 20;
pub const TMP_MAX: u32 = 2147483647;
pub const TMP_MAX_S: u32 = 2147483647;
pub const _TMP_MAX_S: u32 = 2147483647;
pub const SYS_OPEN: u32 = 20;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const _DOMAIN: u32 = 1;
pub const _SING: u32 = 2;
pub const _OVERFLOW: u32 = 3;
pub const _UNDERFLOW: u32 = 4;
pub const _TLOSS: u32 = 5;
pub const _PLOSS: u32 = 6;
pub const _HUGE_ENUF : f64 = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0 ;
pub const _DENORM: i32 = -2;
pub const _FINITE: i32 = -1;
pub const _INFCODE: u32 = 1;
pub const _NANCODE: u32 = 2;
pub const FP_INFINITE: u32 = 1;
pub const FP_NAN: u32 = 2;
pub const FP_NORMAL: i32 = -1;
pub const FP_SUBNORMAL: i32 = -2;
pub const FP_ZERO: u32 = 0;
pub const _C2: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: u32 = 2147483647;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const _FE_DIVBYZERO: u32 = 4;
pub const _FE_INEXACT: u32 = 32;
pub const _FE_INVALID: u32 = 1;
pub const _FE_OVERFLOW: u32 = 8;
pub const _FE_UNDERFLOW: u32 = 16;
pub const _D0_C: u32 = 3;
pub const _D1_C: u32 = 2;
pub const _D2_C: u32 = 1;
pub const _D3_C: u32 = 0;
pub const _DBIAS: u32 = 1022;
pub const _DOFF: u32 = 4;
pub const _F0_C: u32 = 1;
pub const _F1_C: u32 = 0;
pub const _FBIAS: u32 = 126;
pub const _FOFF: u32 = 7;
pub const _FRND: u32 = 1;
pub const _L0_C: u32 = 3;
pub const _L1_C: u32 = 2;
pub const _L2_C: u32 = 1;
pub const _L3_C: u32 = 0;
pub const _LBIAS: u32 = 1022;
pub const _LOFF: u32 = 4;
pub const _FP_LT: u32 = 1;
pub const _FP_EQ: u32 = 2;
pub const _FP_GT: u32 = 4;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const FLT_EVAL_METHOD: u32 = 0;
pub const DBL_DECIMAL_DIG: u32 = 17;
pub const DBL_DIG: u32 = 15;
pub const DBL_HAS_SUBNORM: u32 = 1;
pub const DBL_MANT_DIG: u32 = 53;
pub const DBL_MAX_10_EXP: u32 = 308;
pub const DBL_MAX_EXP: u32 = 1024;
pub const DBL_MIN_10_EXP: i32 = -307;
pub const DBL_MIN_EXP: i32 = -1021;
pub const _DBL_RADIX: u32 = 2;
pub const FLT_DECIMAL_DIG: u32 = 9;
pub const FLT_DIG: u32 = 6;
pub const FLT_HAS_SUBNORM: u32 = 1;
pub const FLT_GUARD: u32 = 0;
pub const FLT_MANT_DIG: u32 = 24;
pub const FLT_MAX_10_EXP: u32 = 38;
pub const FLT_MAX_EXP: u32 = 128;
pub const FLT_MIN_10_EXP: i32 = -37;
pub const FLT_MIN_EXP: i32 = -125;
pub const FLT_NORMALIZE: u32 = 0;
pub const FLT_RADIX: u32 = 2;
pub const LDBL_DIG: u32 = 15;
pub const LDBL_HAS_SUBNORM: u32 = 1;
pub const LDBL_MANT_DIG: u32 = 53;
pub const LDBL_MAX_10_EXP: u32 = 308;
pub const LDBL_MAX_EXP: u32 = 1024;
pub const LDBL_MIN_10_EXP: i32 = -307;
pub const LDBL_MIN_EXP: i32 = -1021;
pub const _LDBL_RADIX: u32 = 2;
pub const DECIMAL_DIG: u32 = 17;
pub const _SW_INEXACT: u32 = 1;
pub const _SW_UNDERFLOW: u32 = 2;
pub const _SW_OVERFLOW: u32 = 4;
pub const _SW_ZERODIVIDE: u32 = 8;
pub const _SW_INVALID: u32 = 16;
pub const _SW_DENORMAL: u32 = 524288;
pub const _EM_AMBIGUIOUS: u32 = 2147483648;
pub const _EM_AMBIGUOUS: u32 = 2147483648;
pub const _MCW_EM: u32 = 524319;
pub const _EM_INEXACT: u32 = 1;
pub const _EM_UNDERFLOW: u32 = 2;
pub const _EM_OVERFLOW: u32 = 4;
pub const _EM_ZERODIVIDE: u32 = 8;
pub const _EM_INVALID: u32 = 16;
pub const _EM_DENORMAL: u32 = 524288;
pub const _MCW_RC: u32 = 768;
pub const _RC_NEAR: u32 = 0;
pub const _RC_DOWN: u32 = 256;
pub const _RC_UP: u32 = 512;
pub const _RC_CHOP: u32 = 768;
pub const _MCW_PC: u32 = 196608;
pub const _PC_64: u32 = 0;
pub const _PC_53: u32 = 65536;
pub const _PC_24: u32 = 131072;
pub const _MCW_IC: u32 = 262144;
pub const _IC_AFFINE: u32 = 262144;
pub const _IC_PROJECTIVE: u32 = 0;
pub const _MCW_DN: u32 = 50331648;
pub const _DN_SAVE: u32 = 0;
pub const _DN_FLUSH: u32 = 16777216;
pub const _DN_FLUSH_OPERANDS_SAVE_RESULTS: u32 = 33554432;
pub const _DN_SAVE_OPERANDS_FLUSH_RESULTS: u32 = 50331648;
pub const _SW_UNEMULATED: u32 = 64;
pub const _SW_SQRTNEG: u32 = 128;
pub const _SW_STACKOVERFLOW: u32 = 512;
pub const _SW_STACKUNDERFLOW: u32 = 1024;
pub const _FPE_INVALID: u32 = 129;
pub const _FPE_DENORMAL: u32 = 130;
pub const _FPE_ZERODIVIDE: u32 = 131;
pub const _FPE_OVERFLOW: u32 = 132;
pub const _FPE_UNDERFLOW: u32 = 133;
pub const _FPE_INEXACT: u32 = 134;
pub const _FPE_UNEMULATED: u32 = 135;
pub const _FPE_SQRTNEG: u32 = 136;
pub const _FPE_STACKOVERFLOW: u32 = 138;
pub const _FPE_STACKUNDERFLOW: u32 = 139;
pub const _FPE_EXPLICITGEN: u32 = 140;
pub const _FPE_MULTIPLE_TRAPS: u32 = 141;
pub const _FPE_MULTIPLE_FAULTS: u32 = 142;
pub const _FPCLASS_SNAN: u32 = 1;
pub const _FPCLASS_QNAN: u32 = 2;
pub const _FPCLASS_NINF: u32 = 4;
pub const _FPCLASS_NN: u32 = 8;
pub const _FPCLASS_ND: u32 = 16;
pub const _FPCLASS_NZ: u32 = 32;
pub const _FPCLASS_PZ: u32 = 64;
pub const _FPCLASS_PD: u32 = 128;
pub const _FPCLASS_PN: u32 = 256;
pub const _FPCLASS_PINF: u32 = 512;
pub const _CW_DEFAULT: u32 = 524319;
pub const DBL_RADIX: u32 = 2;
pub const LDBL_RADIX: u32 = 2;
pub const EM_AMBIGUIOUS: u32 = 2147483648;
pub const EM_AMBIGUOUS: u32 = 2147483648;
pub const MCW_EM: u32 = 524319;
pub const EM_INVALID: u32 = 16;
pub const EM_DENORMAL: u32 = 524288;
pub const EM_ZERODIVIDE: u32 = 8;
pub const EM_OVERFLOW: u32 = 4;
pub const EM_UNDERFLOW: u32 = 2;
pub const EM_INEXACT: u32 = 1;
pub const MCW_IC: u32 = 262144;
pub const IC_AFFINE: u32 = 262144;
pub const IC_PROJECTIVE: u32 = 0;
pub const MCW_RC: u32 = 768;
pub const RC_CHOP: u32 = 768;
pub const RC_UP: u32 = 512;
pub const RC_DOWN: u32 = 256;
pub const RC_NEAR: u32 = 0;
pub const MCW_PC: u32 = 196608;
pub const PC_24: u32 = 131072;
pub const PC_53: u32 = 65536;
pub const PC_64: u32 = 0;
pub const CW_DEFAULT: u32 = 524319;
pub const SW_INVALID: u32 = 16;
pub const SW_DENORMAL: u32 = 524288;
pub const SW_ZERODIVIDE: u32 = 8;
pub const SW_OVERFLOW: u32 = 4;
pub const SW_UNDERFLOW: u32 = 2;
pub const SW_INEXACT: u32 = 1;
pub const SW_UNEMULATED: u32 = 64;
pub const SW_SQRTNEG: u32 = 128;
pub const SW_STACKOVERFLOW: u32 = 512;
pub const SW_STACKUNDERFLOW: u32 = 1024;
pub const FPE_INVALID: u32 = 129;
pub const FPE_DENORMAL: u32 = 130;
pub const FPE_ZERODIVIDE: u32 = 131;
pub const FPE_OVERFLOW: u32 = 132;
pub const FPE_UNDERFLOW: u32 = 133;
pub const FPE_INEXACT: u32 = 134;
pub const FPE_UNEMULATED: u32 = 135;
pub const FPE_SQRTNEG: u32 = 136;
pub const FPE_STACKOVERFLOW: u32 = 138;
pub const FPE_STACKUNDERFLOW: u32 = 139;
pub const FPE_EXPLICITGEN: u32 = 140;
pub const CMAKE_BUILD_TYPE: &'static [u8; 8usize] = b"Release\0";
pub const SCIP_VERSION_MAJOR: u32 = 7;
pub const SCIP_VERSION_MINOR: u32 = 0;
pub const SCIP_VERSION_PATCH: u32 = 0;
pub const SCIP_VERSION_SUB: u32 = 0;
pub const SCIP_VERSION_API: u32 = 68;
pub const SCIP_HAVE_VARIADIC_MACROS: u32 = 1;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const SCIP_VERSION: u32 = 700;
pub const SCIP_SUBVERSION: u32 = 0;
pub const SCIP_APIVERSION: u32 = 68;
pub const SCIP_COPYRIGHT: &'static [u8; 82usize] =
    b"Copyright (C) 2002-2020 Konrad-Zuse-Zentrum fuer Informationstechnik Berlin (ZIB)\0";
pub const SCIP_VARTYPE_BINARY_CHAR: u8 = 66u8;
pub const SCIP_VARTYPE_INTEGER_CHAR: u8 = 73u8;
pub const SCIP_VARTYPE_IMPLINT_CHAR: u8 = 77u8;
pub const SCIP_VARTYPE_CONTINUOUS_CHAR: u8 = 67u8;
pub const SCIP_LONGINT_FORMAT: &'static [u8; 5usize] = b"I64d\0";
pub const SCIP_REAL_FORMAT: &'static [u8; 3usize] = b"lf\0";
pub const SCIP_DEFAULT_INFINITY: f64 = 100000000000000000000.0;
pub const SCIP_DEFAULT_EPSILON: f64 = 0.000000001;
pub const SCIP_DEFAULT_SUMEPSILON: f64 = 0.000001;
pub const SCIP_DEFAULT_FEASTOL: f64 = 0.000001;
pub const SCIP_DEFAULT_CHECKFEASTOLFAC: f64 = 1.0;
pub const SCIP_DEFAULT_LPFEASTOLFACTOR: f64 = 1.0;
pub const SCIP_DEFAULT_DUALFEASTOL: f64 = 0.0000001;
pub const SCIP_DEFAULT_BARRIERCONVTOL: f64 = 0.0000000001;
pub const SCIP_DEFAULT_BOUNDSTREPS: f64 = 0.05;
pub const SCIP_DEFAULT_PSEUDOCOSTEPS: f64 = 0.1;
pub const SCIP_DEFAULT_PSEUDOCOSTDELTA: f64 = 0.0001;
pub const SCIP_DEFAULT_RECOMPFAC: f64 = 10000000.0;
pub const SCIP_DEFAULT_HUGEVAL: f64 = 1000000000000000.0;
pub const SCIP_MAXEPSILON: f64 = 0.001;
pub const SCIP_MINEPSILON: f64 = 0.00000000000000000001;
pub const SCIP_MAXSTRLEN: u32 = 1024;
pub const SCIP_HASHSIZE_PARAMS: u32 = 2048;
pub const SCIP_HASHSIZE_NAMES: u32 = 500;
pub const SCIP_HASHSIZE_CUTPOOLS: u32 = 500;
pub const SCIP_HASHSIZE_CLIQUES: u32 = 500;
pub const SCIP_HASHSIZE_NAMES_SMALL: u32 = 100;
pub const SCIP_HASHSIZE_CUTPOOLS_SMALL: u32 = 100;
pub const SCIP_HASHSIZE_CLIQUES_SMALL: u32 = 100;
pub const SCIP_HASHSIZE_VBC: u32 = 500;
pub const SCIP_DEFAULT_MEM_ARRAYGROWFAC: f64 = 1.2;
pub const SCIP_DEFAULT_MEM_ARRAYGROWINIT: u32 = 4;
pub const SCIP_MAXTREEDEPTH: u32 = 65534;
pub const SCIP_PROBINGSCORE_PENALTYRATIO: u32 = 2;
pub const _MAX_ITOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ITOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_LTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_LTOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_ULTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ULTOSTR_BASE10_COUNT: u32 = 11;
pub const _MAX_ULTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ULTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_I64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_I64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_I64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_I64TOSTR_BASE2_COUNT: u32 = 65;
pub const _MAX_U64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_U64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_U64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_U64TOSTR_BASE2_COUNT: u32 = 65;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const RAND_MAX: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _MAX_ENV: u32 = 32767;
pub const SCIP_PRESOLTIMING_NONE: u32 = 2;
pub const SCIP_PRESOLTIMING_FAST: u32 = 4;
pub const SCIP_PRESOLTIMING_MEDIUM: u32 = 8;
pub const SCIP_PRESOLTIMING_EXHAUSTIVE: u32 = 16;
pub const SCIP_PRESOLTIMING_FINAL: u32 = 32;
pub const SCIP_PRESOLTIMING_ALWAYS: u32 = 28;
pub const SCIP_PRESOLTIMING_MAX: u32 = 60;
pub const SCIP_PROPTIMING_BEFORELP: u32 = 1;
pub const SCIP_PROPTIMING_DURINGLPLOOP: u32 = 2;
pub const SCIP_PROPTIMING_AFTERLPLOOP: u32 = 4;
pub const SCIP_PROPTIMING_AFTERLPNODE: u32 = 8;
pub const SCIP_PROPTIMING_ALWAYS: u32 = 15;
pub const SCIP_HEURTIMING_BEFORENODE: u32 = 1;
pub const SCIP_HEURTIMING_DURINGLPLOOP: u32 = 2;
pub const SCIP_HEURTIMING_AFTERLPLOOP: u32 = 4;
pub const SCIP_HEURTIMING_AFTERLPNODE: u32 = 8;
pub const SCIP_HEURTIMING_AFTERPSEUDONODE: u32 = 16;
pub const SCIP_HEURTIMING_AFTERLPPLUNGE: u32 = 32;
pub const SCIP_HEURTIMING_AFTERPSEUDOPLUNGE: u32 = 64;
pub const SCIP_HEURTIMING_DURINGPRICINGLOOP: u32 = 128;
pub const SCIP_HEURTIMING_BEFOREPRESOL: u32 = 256;
pub const SCIP_HEURTIMING_DURINGPRESOLLOOP: u32 = 512;
pub const SCIP_HEURTIMING_AFTERPROPLOOP: u32 = 1024;
pub const SCIP_HEURTIMING_AFTERNODE: u32 = 24;
pub const SCIP_HEURTIMING_AFTERPLUNGE: u32 = 96;
pub const PRId8: &'static [u8; 4usize] = b"hhd\0";
pub const PRId16: &'static [u8; 3usize] = b"hd\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 4usize] = b"lld\0";
pub const PRIdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 4usize] = b"lld\0";
pub const PRIdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIdFAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST64: &'static [u8; 4usize] = b"lld\0";
pub const PRIdMAX: &'static [u8; 4usize] = b"lld\0";
pub const PRIdPTR: &'static [u8; 4usize] = b"lld\0";
pub const PRIi8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIi16: &'static [u8; 3usize] = b"hi\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 4usize] = b"lli\0";
pub const PRIiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 4usize] = b"lli\0";
pub const PRIiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIiFAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST64: &'static [u8; 4usize] = b"lli\0";
pub const PRIiMAX: &'static [u8; 4usize] = b"lli\0";
pub const PRIiPTR: &'static [u8; 4usize] = b"lli\0";
pub const PRIo8: &'static [u8; 4usize] = b"hho\0";
pub const PRIo16: &'static [u8; 3usize] = b"ho\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 4usize] = b"llo\0";
pub const PRIoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const PRIoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 4usize] = b"llo\0";
pub const PRIoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const PRIoFAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST64: &'static [u8; 4usize] = b"llo\0";
pub const PRIoMAX: &'static [u8; 4usize] = b"llo\0";
pub const PRIoPTR: &'static [u8; 4usize] = b"llo\0";
pub const PRIu8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIu16: &'static [u8; 3usize] = b"hu\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 4usize] = b"llu\0";
pub const PRIuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 4usize] = b"llu\0";
pub const PRIuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIuFAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST64: &'static [u8; 4usize] = b"llu\0";
pub const PRIuMAX: &'static [u8; 4usize] = b"llu\0";
pub const PRIuPTR: &'static [u8; 4usize] = b"llu\0";
pub const PRIx8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIx16: &'static [u8; 3usize] = b"hx\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 4usize] = b"llx\0";
pub const PRIxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 4usize] = b"llx\0";
pub const PRIxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIxFAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST64: &'static [u8; 4usize] = b"llx\0";
pub const PRIxMAX: &'static [u8; 4usize] = b"llx\0";
pub const PRIxPTR: &'static [u8; 4usize] = b"llx\0";
pub const PRIX8: &'static [u8; 4usize] = b"hhX\0";
pub const PRIX16: &'static [u8; 3usize] = b"hX\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 4usize] = b"llX\0";
pub const PRIXLEAST8: &'static [u8; 4usize] = b"hhX\0";
pub const PRIXLEAST16: &'static [u8; 3usize] = b"hX\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 4usize] = b"llX\0";
pub const PRIXFAST8: &'static [u8; 4usize] = b"hhX\0";
pub const PRIXFAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST64: &'static [u8; 4usize] = b"llX\0";
pub const PRIXMAX: &'static [u8; 4usize] = b"llX\0";
pub const PRIXPTR: &'static [u8; 4usize] = b"llX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 4usize] = b"lld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 4usize] = b"lld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 2usize] = b"d\0";
pub const SCNdFAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdFAST64: &'static [u8; 4usize] = b"lld\0";
pub const SCNdMAX: &'static [u8; 4usize] = b"lld\0";
pub const SCNdPTR: &'static [u8; 4usize] = b"lld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 4usize] = b"lli\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 4usize] = b"lli\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 2usize] = b"i\0";
pub const SCNiFAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiFAST64: &'static [u8; 4usize] = b"lli\0";
pub const SCNiMAX: &'static [u8; 4usize] = b"lli\0";
pub const SCNiPTR: &'static [u8; 4usize] = b"lli\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 4usize] = b"llo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 4usize] = b"llo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 2usize] = b"o\0";
pub const SCNoFAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoFAST64: &'static [u8; 4usize] = b"llo\0";
pub const SCNoMAX: &'static [u8; 4usize] = b"llo\0";
pub const SCNoPTR: &'static [u8; 4usize] = b"llo\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 4usize] = b"llu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 4usize] = b"llu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 2usize] = b"u\0";
pub const SCNuFAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuFAST64: &'static [u8; 4usize] = b"llu\0";
pub const SCNuMAX: &'static [u8; 4usize] = b"llu\0";
pub const SCNuPTR: &'static [u8; 4usize] = b"llu\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 4usize] = b"llx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 4usize] = b"llx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 2usize] = b"x\0";
pub const SCNxFAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxFAST64: &'static [u8; 4usize] = b"llx\0";
pub const SCNxMAX: &'static [u8; 4usize] = b"llx\0";
pub const SCNxPTR: &'static [u8; 4usize] = b"llx\0";
pub const SCIP_EVENTTYPE_FORMAT: &'static [u8; 4usize] = b"llx\0";
pub const NLOCKTYPES: u32 = 2;
pub const SCIP_DIVETYPE_NONE: u32 = 0;
pub const SCIP_DIVETYPE_INTEGRALITY: u32 = 1;
pub const SCIP_DIVETYPE_SOS1VARIABLE: u32 = 2;
pub const SCIP_HEURDISPCHAR_LNS: u8 = 76u8;
pub const SCIP_HEURDISPCHAR_DIVING: u8 = 100u8;
pub const SCIP_HEURDISPCHAR_ITERATIVE: u8 = 105u8;
pub const SCIP_HEURDISPCHAR_OBJDIVING: u8 = 111u8;
pub const SCIP_HEURDISPCHAR_PROP: u8 = 112u8;
pub const SCIP_HEURDISPCHAR_ROUNDING: u8 = 114u8;
pub const SCIP_HEURDISPCHAR_TRIVIAL: u8 = 116u8;
pub const SCIP_EXPR_DEGREEINFINITY: u32 = 65535;
pub const SCIP_EXPRBOUNDSTATUS_VALID: u32 = 0;
pub const SCIP_EXPRBOUNDSTATUS_CHILDTIGHTENED: u32 = 1;
pub const SCIP_EXPRBOUNDSTATUS_CHILDRELAXED: u32 = 2;
pub const SCIP_EXPRBOUNDSTATUS_TIGHTENEDBYPARENT: u32 = 4;
pub const SCIP_EXPRBOUNDSTATUS_TIGHTENEDBYPARENTRECENT: u32 = 12;
pub const SCIP_EXPRBOUNDSTATUS_TIGHTENEDBYPARENTFORCE: u32 = 28;
pub const SCIP_DECOMP_LINKVAR: i32 = -1;
pub const SCIP_DECOMP_LINKCONS: i32 = -2;
pub const SCIP_EXPRINTCAPABILITY_NONE: u32 = 0;
pub const SCIP_EXPRINTCAPABILITY_FUNCVALUE: u32 = 1;
pub const SCIP_EXPRINTCAPABILITY_INTFUNCVALUE: u32 = 2;
pub const SCIP_EXPRINTCAPABILITY_GRADIENT: u32 = 16;
pub const SCIP_EXPRINTCAPABILITY_INTGRADIENT: u32 = 32;
pub const SCIP_EXPRINTCAPABILITY_HESSIAN: u32 = 256;
pub const SCIP_EXPRINTCAPABILITY_INTHESSIAN: u32 = 512;
pub const SCIP_EXPRINTCAPABILITY_ALL: u32 = 819;
pub const QUAD_EPSILON: f64 = 0.000000000001;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type size_t = ::std::os::raw::c_ulonglong;
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn();
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    );
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__crt_locale_data_public>()))._locale_pctype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_pctype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__crt_locale_data_public>()))._locale_mb_cur_max as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_mb_cur_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__crt_locale_data_public>()))._locale_lc_codepage as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_lc_codepage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__crt_locale_pointers>())).locinfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__crt_locale_pointers>())).mbcinfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(mbcinfo)
        )
    );
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    assert_eq!(
        ::std::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Mbstatet>()))._Wchar as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Wchar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Mbstatet>()))._Byte as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Byte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Mbstatet>()))._State as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_State)
        )
    );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = size_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
    pub _Placeholder: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__iobuf() {
    assert_eq!(
        ::std::mem::size_of::<_iobuf>(),
        8usize,
        concat!("Size of: ", stringify!(_iobuf))
    );
    assert_eq!(
        ::std::mem::align_of::<_iobuf>(),
        8usize,
        concat!("Alignment of ", stringify!(_iobuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_iobuf>()))._Placeholder as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_iobuf),
            "::",
            stringify!(_Placeholder)
        )
    );
}
pub type FILE = _iobuf;
extern "C" {
    pub fn __acrt_iob_func(_Ix: ::std::os::raw::c_uint) -> *mut FILE;
}
extern "C" {
    pub fn fgetwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fgetwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn getwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fgetws(
        _Buffer: *mut wchar_t,
        _BufferCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn fputws(_Buffer: *const wchar_t, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getws_s(_Buffer: *mut wchar_t, _BufferCount: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn putwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn _putws(_Buffer: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _wfdopen(_FileHandle: ::std::os::raw::c_int, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen(_FileName: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfreopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wfreopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfsopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const wchar_t);
}
extern "C" {
    pub fn _wpopen(_Command: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wremove(_FileName: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtempnam(_Directory: *const wchar_t, _FilePrefix: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtmpnam_s(_Buffer: *mut wchar_t, _BufferCount: size_t) -> errno_t;
}
extern "C" {
    pub fn _wtmpnam(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _fgetwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _getwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _putwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _ungetwc_nolock(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn __stdio_common_vfwprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _MaxCount: size_t,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const wchar_t,
        _BufferCount: size_t,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = ::std::os::raw::c_longlong;
extern "C" {
    pub fn _get_stream_buffer_pointers(
        _Stream: *mut FILE,
        _Base: *mut *mut *mut ::std::os::raw::c_char,
        _Pointer: *mut *mut *mut ::std::os::raw::c_char,
        _Count: *mut *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn clearerr_s(_Stream: *mut FILE) -> errno_t;
}
extern "C" {
    pub fn fopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn fread_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: size_t,
        _ElementSize: size_t,
        _ElementCount: size_t,
        _Stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn freopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn gets_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _Size: rsize_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile_s(_Stream: *mut *mut FILE) -> errno_t;
}
extern "C" {
    pub fn tmpnam_s(_Buffer: *mut ::std::os::raw::c_char, _Size: rsize_t) -> errno_t;
}
extern "C" {
    pub fn clearerr(_Stream: *mut FILE);
}
extern "C" {
    pub fn fclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn feof(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(_Stream: *mut FILE, _Position: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        _Buffer: *mut ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fputc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(
        _Buffer: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: ::std::os::raw::c_ulonglong,
        _ElementCount: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn freopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fsopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fsetpos(_Stream: *mut FILE, _Position: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fwrite(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: ::std::os::raw::c_ulonglong,
        _ElementCount: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn getc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getmaxstdio() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrorMessage: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn _pclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _popen(
        _Command: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn putc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(_Buffer: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putw(_Word: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        _OldFileName: *const ::std::os::raw::c_char,
        _NewFileName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(_Stream: *mut FILE);
}
extern "C" {
    pub fn _rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(_Stream: *mut FILE, _Buffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn _setmaxstdio(_Maximum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setvbuf(
        _Stream: *mut FILE,
        _Buffer: *mut ::std::os::raw::c_char,
        _Mode: ::std::os::raw::c_int,
        _Size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tempnam(
        _DirectoryName: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _lock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _unlock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _fclose_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fflush_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fread_nolock(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: size_t,
        _ElementCount: size_t,
        _Stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fread_nolock_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: size_t,
        _ElementSize: size_t,
        _ElementCount: size_t,
        _Stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fseek_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ftell_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _fwrite_nolock(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: size_t,
        _ElementCount: size_t,
        _Stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _getc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ungetc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p__commode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_printf_count_output(_Value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_printf_count_output() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _Arglist: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _MaxCount: size_t,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        _Directory: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Format: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputchar(_Ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(_Ch: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmtmp() -> ::std::os::raw::c_int;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout__exception() {
    assert_eq!(
        ::std::mem::size_of::<_exception>(),
        40usize,
        concat!("Size of: ", stringify!(_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<_exception>(),
        8usize,
        concat!("Alignment of ", stringify!(_exception))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_exception>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_exception),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_exception>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_exception),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_exception>())).arg1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_exception),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_exception>())).arg2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_exception),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_exception>())).retval as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_exception),
            "::",
            stringify!(retval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _complex {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout__complex() {
    assert_eq!(
        ::std::mem::size_of::<_complex>(),
        16usize,
        concat!("Size of: ", stringify!(_complex))
    );
    assert_eq!(
        ::std::mem::align_of::<_complex>(),
        8usize,
        concat!("Alignment of ", stringify!(_complex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_complex>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_complex),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_complex>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_complex),
            "::",
            stringify!(y)
        )
    );
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub static _HUGE: f64;
}
extern "C" {
    pub fn _fperrraise(_Except: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _dclass(_X: f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldclass(_X: f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdclass(_X: f32) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dsign(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ldsign(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdsign(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _dpcomp(_X: f64, _Y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ldpcomp(_X: f64, _Y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdpcomp(_X: f32, _Y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _dtest(_Px: *mut f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldtest(_Px: *mut f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdtest(_Px: *mut f32) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _d_int(_Px: *mut f64, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ld_int(_Px: *mut f64, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fd_int(_Px: *mut f32, _Xexp: ::std::os::raw::c_short) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dscale(_Px: *mut f64, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldscale(_Px: *mut f64, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdscale(_Px: *mut f32, _Lexp: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f64) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f64)
        -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdunscale(_Pex: *mut ::std::os::raw::c_short, _Px: *mut f32)
        -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dexp(_Px: *mut f64, _Y: f64, _Eoff: ::std::os::raw::c_long) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _ldexp(_Px: *mut f64, _Y: f64, _Eoff: ::std::os::raw::c_long)
        -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdexp(_Px: *mut f32, _Y: f32, _Eoff: ::std::os::raw::c_long)
        -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dnorm(_Ps: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _fdnorm(_Ps: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _dpoly(_X: f64, _Tab: *const f64, _N: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _ldpoly(_X: f64, _Tab: *const f64, _N: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _fdpoly(_X: f32, _Tab: *const f32, _N: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn _dlog(_X: f64, _Baseflag: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _ldlog(_X: f64, _Baseflag: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn _fdlog(_X: f32, _Baseflag: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn _dsin(_X: f64, _Qoff: ::std::os::raw::c_uint) -> f64;
}
extern "C" {
    pub fn _ldsin(_X: f64, _Qoff: ::std::os::raw::c_uint) -> f64;
}
extern "C" {
    pub fn _fdsin(_X: f32, _Qoff: ::std::os::raw::c_uint) -> f32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _double_val {
    pub _Sh: [::std::os::raw::c_ushort; 4usize],
    pub _Val: f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__double_val() {
    assert_eq!(
        ::std::mem::size_of::<_double_val>(),
        8usize,
        concat!("Size of: ", stringify!(_double_val))
    );
    assert_eq!(
        ::std::mem::align_of::<_double_val>(),
        8usize,
        concat!("Alignment of ", stringify!(_double_val))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_double_val>()))._Sh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_double_val),
            "::",
            stringify!(_Sh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_double_val>()))._Val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_double_val),
            "::",
            stringify!(_Val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _float_val {
    pub _Sh: [::std::os::raw::c_ushort; 2usize],
    pub _Val: f32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__float_val() {
    assert_eq!(
        ::std::mem::size_of::<_float_val>(),
        4usize,
        concat!("Size of: ", stringify!(_float_val))
    );
    assert_eq!(
        ::std::mem::align_of::<_float_val>(),
        4usize,
        concat!("Alignment of ", stringify!(_float_val))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_float_val>()))._Sh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_float_val),
            "::",
            stringify!(_Sh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_float_val>()))._Val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_float_val),
            "::",
            stringify!(_Val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ldouble_val {
    pub _Sh: [::std::os::raw::c_ushort; 4usize],
    pub _Val: f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__ldouble_val() {
    assert_eq!(
        ::std::mem::size_of::<_ldouble_val>(),
        8usize,
        concat!("Size of: ", stringify!(_ldouble_val))
    );
    assert_eq!(
        ::std::mem::align_of::<_ldouble_val>(),
        8usize,
        concat!("Alignment of ", stringify!(_ldouble_val))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ldouble_val>()))._Sh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldouble_val),
            "::",
            stringify!(_Sh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ldouble_val>()))._Val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldouble_val),
            "::",
            stringify!(_Val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _float_const {
    pub _Word: [::std::os::raw::c_ushort; 4usize],
    pub _Float: f32,
    pub _Double: f64,
    pub _Long_double: f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__float_const() {
    assert_eq!(
        ::std::mem::size_of::<_float_const>(),
        8usize,
        concat!("Size of: ", stringify!(_float_const))
    );
    assert_eq!(
        ::std::mem::align_of::<_float_const>(),
        8usize,
        concat!("Alignment of ", stringify!(_float_const))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_float_const>()))._Word as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_float_const),
            "::",
            stringify!(_Word)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_float_const>()))._Float as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_float_const),
            "::",
            stringify!(_Float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_float_const>()))._Double as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_float_const),
            "::",
            stringify!(_Double)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_float_const>()))._Long_double as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_float_const),
            "::",
            stringify!(_Long_double)
        )
    );
}
extern "C" {
    pub static _Denorm_C: _float_const;
}
extern "C" {
    pub static _Inf_C: _float_const;
}
extern "C" {
    pub static _Nan_C: _float_const;
}
extern "C" {
    pub static _Snan_C: _float_const;
}
extern "C" {
    pub static _Hugeval_C: _float_const;
}
extern "C" {
    pub static _FDenorm_C: _float_const;
}
extern "C" {
    pub static _FInf_C: _float_const;
}
extern "C" {
    pub static _FNan_C: _float_const;
}
extern "C" {
    pub static _FSnan_C: _float_const;
}
extern "C" {
    pub static _LDenorm_C: _float_const;
}
extern "C" {
    pub static _LInf_C: _float_const;
}
extern "C" {
    pub static _LNan_C: _float_const;
}
extern "C" {
    pub static _LSnan_C: _float_const;
}
extern "C" {
    pub static _Eps_C: _float_const;
}
extern "C" {
    pub static _Rteps_C: _float_const;
}
extern "C" {
    pub static _FEps_C: _float_const;
}
extern "C" {
    pub static _FRteps_C: _float_const;
}
extern "C" {
    pub static _LEps_C: _float_const;
}
extern "C" {
    pub static _LRteps_C: _float_const;
}
extern "C" {
    pub static _Zero_C: f64;
}
extern "C" {
    pub static _Xbig_C: f64;
}
extern "C" {
    pub static _FZero_C: f32;
}
extern "C" {
    pub static _FXbig_C: f32;
}
extern "C" {
    pub static _LZero_C: f64;
}
extern "C" {
    pub static _LXbig_C: f64;
}
extern "C" {
    pub fn abs(_X: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(_X: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(_X: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn acos(_X: f64) -> f64;
}
extern "C" {
    pub fn asin(_X: f64) -> f64;
}
extern "C" {
    pub fn atan(_X: f64) -> f64;
}
extern "C" {
    pub fn atan2(_Y: f64, _X: f64) -> f64;
}
extern "C" {
    pub fn cos(_X: f64) -> f64;
}
extern "C" {
    pub fn cosh(_X: f64) -> f64;
}
extern "C" {
    pub fn exp(_X: f64) -> f64;
}
extern "C" {
    pub fn fabs(_X: f64) -> f64;
}
extern "C" {
    pub fn fmod(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn log(_X: f64) -> f64;
}
extern "C" {
    pub fn log10(_X: f64) -> f64;
}
extern "C" {
    pub fn pow(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn sin(_X: f64) -> f64;
}
extern "C" {
    pub fn sinh(_X: f64) -> f64;
}
extern "C" {
    pub fn sqrt(_X: f64) -> f64;
}
extern "C" {
    pub fn tan(_X: f64) -> f64;
}
extern "C" {
    pub fn tanh(_X: f64) -> f64;
}
extern "C" {
    pub fn acosh(_X: f64) -> f64;
}
extern "C" {
    pub fn asinh(_X: f64) -> f64;
}
extern "C" {
    pub fn atanh(_X: f64) -> f64;
}
extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _cabs(_Complex_value: _complex) -> f64;
}
extern "C" {
    pub fn cbrt(_X: f64) -> f64;
}
extern "C" {
    pub fn ceil(_X: f64) -> f64;
}
extern "C" {
    pub fn _chgsign(_X: f64) -> f64;
}
extern "C" {
    pub fn copysign(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
    pub fn _copysign(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
    pub fn erf(_X: f64) -> f64;
}
extern "C" {
    pub fn erfc(_X: f64) -> f64;
}
extern "C" {
    pub fn exp2(_X: f64) -> f64;
}
extern "C" {
    pub fn expm1(_X: f64) -> f64;
}
extern "C" {
    pub fn fdim(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn floor(_X: f64) -> f64;
}
extern "C" {
    pub fn fma(_X: f64, _Y: f64, _Z: f64) -> f64;
}
extern "C" {
    pub fn fmax(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn fmin(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn frexp(_X: f64, _Y: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn hypot(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn _hypot(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn ilogb(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ldexp(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lgamma(_X: f64) -> f64;
}
extern "C" {
    pub fn llrint(_X: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llround(_X: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn log1p(_X: f64) -> f64;
}
extern "C" {
    pub fn log2(_X: f64) -> f64;
}
extern "C" {
    pub fn logb(_X: f64) -> f64;
}
extern "C" {
    pub fn lrint(_X: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lround(_X: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _matherr(_Except: *mut _exception) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn modf(_X: f64, _Y: *mut f64) -> f64;
}
extern "C" {
    pub fn nan(_X: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nearbyint(_X: f64) -> f64;
}
extern "C" {
    pub fn nextafter(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn remainder(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn remquo(_X: f64, _Y: f64, _Z: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(_X: f64) -> f64;
}
extern "C" {
    pub fn round(_X: f64) -> f64;
}
extern "C" {
    pub fn scalbln(_X: f64, _Y: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalbn(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn tgamma(_X: f64) -> f64;
}
extern "C" {
    pub fn trunc(_X: f64) -> f64;
}
extern "C" {
    pub fn _j0(_X: f64) -> f64;
}
extern "C" {
    pub fn _j1(_X: f64) -> f64;
}
extern "C" {
    pub fn _jn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
extern "C" {
    pub fn _y0(_X: f64) -> f64;
}
extern "C" {
    pub fn _y1(_X: f64) -> f64;
}
extern "C" {
    pub fn _yn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
extern "C" {
    pub fn acoshf(_X: f32) -> f32;
}
extern "C" {
    pub fn asinhf(_X: f32) -> f32;
}
extern "C" {
    pub fn atanhf(_X: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(_X: f32) -> f32;
}
extern "C" {
    pub fn _chgsignf(_X: f32) -> f32;
}
extern "C" {
    pub fn copysignf(_Number: f32, _Sign: f32) -> f32;
}
extern "C" {
    pub fn _copysignf(_Number: f32, _Sign: f32) -> f32;
}
extern "C" {
    pub fn erff(_X: f32) -> f32;
}
extern "C" {
    pub fn erfcf(_X: f32) -> f32;
}
extern "C" {
    pub fn expm1f(_X: f32) -> f32;
}
extern "C" {
    pub fn exp2f(_X: f32) -> f32;
}
extern "C" {
    pub fn fdimf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(_X: f32, _Y: f32, _Z: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn fminf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn _hypotf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn ilogbf(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lgammaf(_X: f32) -> f32;
}
extern "C" {
    pub fn llrintf(_X: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundf(_X: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn log1pf(_X: f32) -> f32;
}
extern "C" {
    pub fn log2f(_X: f32) -> f32;
}
extern "C" {
    pub fn logbf(_X: f32) -> f32;
}
extern "C" {
    pub fn lrintf(_X: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundf(_X: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nanf(_X: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn nearbyintf(_X: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(_X: f32, _Y: f64) -> f32;
}
extern "C" {
    pub fn remainderf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn remquof(_X: f32, _Y: f32, _Z: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(_X: f32) -> f32;
}
extern "C" {
    pub fn roundf(_X: f32) -> f32;
}
extern "C" {
    pub fn scalblnf(_X: f32, _Y: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn scalbnf(_X: f32, _Y: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn tgammaf(_X: f32) -> f32;
}
extern "C" {
    pub fn truncf(_X: f32) -> f32;
}
extern "C" {
    pub fn _logbf(_X: f32) -> f32;
}
extern "C" {
    pub fn _nextafterf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn _finitef(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isnanf(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fpclassf(_X: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_FMA3_enable(_Flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_FMA3_enable() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(_X: f32) -> f32;
}
extern "C" {
    pub fn asinf(_X: f32) -> f32;
}
extern "C" {
    pub fn atan2f(_Y: f32, _X: f32) -> f32;
}
extern "C" {
    pub fn atanf(_X: f32) -> f32;
}
extern "C" {
    pub fn ceilf(_X: f32) -> f32;
}
extern "C" {
    pub fn cosf(_X: f32) -> f32;
}
extern "C" {
    pub fn coshf(_X: f32) -> f32;
}
extern "C" {
    pub fn expf(_X: f32) -> f32;
}
extern "C" {
    pub fn floorf(_X: f32) -> f32;
}
extern "C" {
    pub fn fmodf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn log10f(_X: f32) -> f32;
}
extern "C" {
    pub fn logf(_X: f32) -> f32;
}
extern "C" {
    pub fn modff(_X: f32, _Y: *mut f32) -> f32;
}
extern "C" {
    pub fn powf(_X: f32, _Y: f32) -> f32;
}
extern "C" {
    pub fn sinf(_X: f32) -> f32;
}
extern "C" {
    pub fn sinhf(_X: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(_X: f32) -> f32;
}
extern "C" {
    pub fn tanf(_X: f32) -> f32;
}
extern "C" {
    pub fn tanhf(_X: f32) -> f32;
}
extern "C" {
    pub fn acoshl(_X: f64) -> f64;
}
extern "C" {
    pub fn asinhl(_X: f64) -> f64;
}
extern "C" {
    pub fn atanhl(_X: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(_X: f64) -> f64;
}
extern "C" {
    pub fn copysignl(_Number: f64, _Sign: f64) -> f64;
}
extern "C" {
    pub fn erfl(_X: f64) -> f64;
}
extern "C" {
    pub fn erfcl(_X: f64) -> f64;
}
extern "C" {
    pub fn exp2l(_X: f64) -> f64;
}
extern "C" {
    pub fn expm1l(_X: f64) -> f64;
}
extern "C" {
    pub fn fdiml(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn fmal(_X: f64, _Y: f64, _Z: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn fminl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn ilogbl(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lgammal(_X: f64) -> f64;
}
extern "C" {
    pub fn llrintl(_X: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundl(_X: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn log1pl(_X: f64) -> f64;
}
extern "C" {
    pub fn log2l(_X: f64) -> f64;
}
extern "C" {
    pub fn logbl(_X: f64) -> f64;
}
extern "C" {
    pub fn lrintl(_X: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundl(_X: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nanl(_X: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nearbyintl(_X: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn remainderl(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn remquol(_X: f64, _Y: f64, _Z: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rintl(_X: f64) -> f64;
}
extern "C" {
    pub fn roundl(_X: f64) -> f64;
}
extern "C" {
    pub fn scalblnl(_X: f64, _Y: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalbnl(_X: f64, _Y: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn tgammal(_X: f64) -> f64;
}
extern "C" {
    pub fn truncl(_X: f64) -> f64;
}
extern "C" {
    pub static mut HUGE: f64;
}
extern "C" {
    pub fn j0(_X: f64) -> f64;
}
extern "C" {
    pub fn j1(_X: f64) -> f64;
}
extern "C" {
    pub fn jn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
extern "C" {
    pub fn y0(_X: f64) -> f64;
}
extern "C" {
    pub fn y1(_X: f64) -> f64;
}
extern "C" {
    pub fn yn(_X: ::std::os::raw::c_int, _Y: f64) -> f64;
}
extern "C" {
    pub fn _clearfp() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _controlfp(
        _NewValue: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _set_controlfp(_NewValue: ::std::os::raw::c_uint, _Mask: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _controlfp_s(
        _CurrentState: *mut ::std::os::raw::c_uint,
        _NewValue: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> errno_t;
}
extern "C" {
    pub fn _statusfp() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _fpreset();
}
extern "C" {
    pub fn _control87(
        _NewValue: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __fpecode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpe_flt_rounds() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scalb(_X: f64, _Y: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn _logb(_X: f64) -> f64;
}
extern "C" {
    pub fn _nextafter(_X: f64, _Y: f64) -> f64;
}
extern "C" {
    pub fn _finite(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isnan(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fpclass(_X: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scalbf(_X: f32, _Y: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn fpreset();
}
extern "C" {
    pub fn _wassert(_Message: *const wchar_t, _File: *const wchar_t, _Line: ::std::os::raw::c_uint);
}
#[doc = "< normal termination"]
pub const SCIP_Retcode_SCIP_OKAY: SCIP_Retcode = 1;
#[doc = "< unspecified error"]
pub const SCIP_Retcode_SCIP_ERROR: SCIP_Retcode = 0;
#[doc = "< insufficient memory error"]
pub const SCIP_Retcode_SCIP_NOMEMORY: SCIP_Retcode = -1;
#[doc = "< read error"]
pub const SCIP_Retcode_SCIP_READERROR: SCIP_Retcode = -2;
#[doc = "< write error"]
pub const SCIP_Retcode_SCIP_WRITEERROR: SCIP_Retcode = -3;
#[doc = "< file not found error"]
pub const SCIP_Retcode_SCIP_NOFILE: SCIP_Retcode = -4;
#[doc = "< cannot create file"]
pub const SCIP_Retcode_SCIP_FILECREATEERROR: SCIP_Retcode = -5;
#[doc = "< error in LP solver"]
pub const SCIP_Retcode_SCIP_LPERROR: SCIP_Retcode = -6;
#[doc = "< no problem exists"]
pub const SCIP_Retcode_SCIP_NOPROBLEM: SCIP_Retcode = -7;
#[doc = "< method cannot be called at this time in solution process"]
pub const SCIP_Retcode_SCIP_INVALIDCALL: SCIP_Retcode = -8;
#[doc = "< error in input data"]
pub const SCIP_Retcode_SCIP_INVALIDDATA: SCIP_Retcode = -9;
#[doc = "< method returned an invalid result code"]
pub const SCIP_Retcode_SCIP_INVALIDRESULT: SCIP_Retcode = -10;
#[doc = "< a required plugin was not found"]
pub const SCIP_Retcode_SCIP_PLUGINNOTFOUND: SCIP_Retcode = -11;
#[doc = "< the parameter with the given name was not found"]
pub const SCIP_Retcode_SCIP_PARAMETERUNKNOWN: SCIP_Retcode = -12;
#[doc = "< the parameter is not of the expected type"]
pub const SCIP_Retcode_SCIP_PARAMETERWRONGTYPE: SCIP_Retcode = -13;
#[doc = "< the value is invalid for the given parameter"]
pub const SCIP_Retcode_SCIP_PARAMETERWRONGVAL: SCIP_Retcode = -14;
#[doc = "< the given key is already existing in table"]
pub const SCIP_Retcode_SCIP_KEYALREADYEXISTING: SCIP_Retcode = -15;
#[doc = "< maximal branching depth level exceeded"]
pub const SCIP_Retcode_SCIP_MAXDEPTHLEVEL: SCIP_Retcode = -16;
#[doc = "< no branching could be created"]
pub const SCIP_Retcode_SCIP_BRANCHERROR: SCIP_Retcode = -17;
#[doc = "< function not implemented"]
pub const SCIP_Retcode_SCIP_NOTIMPLEMENTED: SCIP_Retcode = -18;
#[doc = " return codes for SCIP methods: non-positive return codes are errors"]
pub type SCIP_Retcode = ::std::os::raw::c_int;
pub use self::SCIP_Retcode as SCIP_RETCODE;
#[doc = "< only error and warning messages are displayed"]
pub const SCIP_VerbLevel_SCIP_VERBLEVEL_NONE: SCIP_VerbLevel = 0;
#[doc = "< only interactive dialogs, errors, and warnings are displayed"]
pub const SCIP_VerbLevel_SCIP_VERBLEVEL_DIALOG: SCIP_VerbLevel = 1;
#[doc = "< only important messages are displayed"]
pub const SCIP_VerbLevel_SCIP_VERBLEVEL_MINIMAL: SCIP_VerbLevel = 2;
#[doc = "< standard messages are displayed"]
pub const SCIP_VerbLevel_SCIP_VERBLEVEL_NORMAL: SCIP_VerbLevel = 3;
#[doc = "< a lot of information is displayed"]
pub const SCIP_VerbLevel_SCIP_VERBLEVEL_HIGH: SCIP_VerbLevel = 4;
#[doc = "< all messages are displayed"]
pub const SCIP_VerbLevel_SCIP_VERBLEVEL_FULL: SCIP_VerbLevel = 5;
#[doc = " verbosity levels of output"]
pub type SCIP_VerbLevel = ::std::os::raw::c_int;
pub use self::SCIP_VerbLevel as SCIP_VERBLEVEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Messagehdlr {
    _unused: [u8; 0],
}
pub type SCIP_MESSAGEHDLR = SCIP_Messagehdlr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_MessagehdlrData {
    _unused: [u8; 0],
}
pub type SCIP_MESSAGEHDLRDATA = SCIP_MessagehdlrData;
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn memchr(
        _Buf: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        _Dst: *mut ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strchr(
        _Str: *const ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        _Str: *const ::std::os::raw::c_char,
        _Ch: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        _Str: *const ::std::os::raw::c_char,
        _SubStr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wcschr(
        _Str: *const ::std::os::raw::c_ushort,
        _Ch: ::std::os::raw::c_ushort,
    ) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _memicmp_l(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(
        _String1: *const ::std::os::raw::c_ushort,
        _String2: *const ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscpy(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(_String: *const wchar_t, _Control: *const wchar_t) -> size_t;
}
extern "C" {
    pub fn wcslen(_String: *const ::std::os::raw::c_ushort) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcsnlen(_Source: *const wchar_t, _MaxCount: size_t) -> size_t;
}
extern "C" {
    pub fn wcsncat(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: size_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncmp(
        _String1: *const ::std::os::raw::c_ushort,
        _String2: *const ::std::os::raw::c_ushort,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncpy(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: size_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcspbrk(_String: *const wchar_t, _Control: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsspn(_String: *const wchar_t, _Control: *const wchar_t) -> size_t;
}
extern "C" {
    pub fn wcstok(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror(_ErrorNumber: ::std::os::raw::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: size_t,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn __wcserror(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn __wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: size_t,
        _ErrorMessage: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnset_s(
        _Destination: *mut wchar_t,
        _SizeInWords: size_t,
        _Value: wchar_t,
        _MaxCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsset_s(_Destination: *mut wchar_t, _SizeInWords: size_t, _Value: wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s(_String: *mut wchar_t, _SizeInWords: size_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s_l(_String: *mut wchar_t, _SizeInWords: size_t, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s(_String: *mut wchar_t, _Size: size_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s_l(_String: *mut wchar_t, _Size: size_t, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsxfrm(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _wcsxfrm_l(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcscoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcscoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strcat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn strncat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strncpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strtok_s(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
        _Context: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strdup(_Source: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror(_ErrorMessage: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _ErrorMessage: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror(_ErrorMessage: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlen(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strlwr_s(_String: *mut ::std::os::raw::c_char, _Size: size_t) -> errno_t;
}
extern "C" {
    pub fn _strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strlwr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: size_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strlwr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __strncnt(_String: *const ::std::os::raw::c_char, _Count: size_t) -> size_t;
}
extern "C" {
    pub fn strncpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(_String: *const ::std::os::raw::c_char, _MaxCount: size_t) -> size_t;
}
extern "C" {
    pub fn _strnset_s(
        _String: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _Value: ::std::os::raw::c_int,
        _MaxCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strnset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _Count: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strrev(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strset_s(
        _Destination: *mut ::std::os::raw::c_char,
        _DestinationSize: size_t,
        _Value: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _strset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtok(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s(_String: *mut ::std::os::raw::c_char, _Size: size_t) -> errno_t;
}
extern "C" {
    pub fn _strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: size_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strupr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strxfrm_l(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(_String: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strnset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _MaxCount: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrev(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Creates and captures a message handler which deals with warning, information, and dialog (interactive shell) methods."]
    #[doc = ""]
    #[doc = "  Use SCIPsetMessagehdlr() to make SCIP aware of the created message handler."]
    #[doc = "  @note The message handler does not handle error messages. For that see SCIPmessageSetErrorPrinting()"]
    #[doc = "  @note Creating a message handler automatically captures it."]
    pub fn SCIPmessagehdlrCreate(
        messagehdlr: *mut *mut SCIP_MESSAGEHDLR,
        bufferedoutput: ::std::os::raw::c_uint,
        filename: *const ::std::os::raw::c_char,
        quiet: ::std::os::raw::c_uint,
        messagewarning: ::std::option::Option<
            unsafe extern "C" fn(
                messagehdlr: *mut SCIP_MESSAGEHDLR,
                file: *mut FILE,
                msg: *const ::std::os::raw::c_char,
            ),
        >,
        messagedialog: ::std::option::Option<
            unsafe extern "C" fn(
                messagehdlr: *mut SCIP_MESSAGEHDLR,
                file: *mut FILE,
                msg: *const ::std::os::raw::c_char,
            ),
        >,
        messageinfo: ::std::option::Option<
            unsafe extern "C" fn(
                messagehdlr: *mut SCIP_MESSAGEHDLR,
                file: *mut FILE,
                msg: *const ::std::os::raw::c_char,
            ),
        >,
        messagehdlrfree: ::std::option::Option<
            unsafe extern "C" fn(messagehdlr: *mut SCIP_MESSAGEHDLR) -> SCIP_RETCODE,
        >,
        messagehdlrdata: *mut SCIP_MESSAGEHDLRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " captures message handler"]
    pub fn SCIPmessagehdlrCapture(messagehdlr: *mut SCIP_MESSAGEHDLR);
}
extern "C" {
    #[doc = " releases message handler"]
    pub fn SCIPmessagehdlrRelease(messagehdlr: *mut *mut SCIP_MESSAGEHDLR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the user data of the message handler"]
    pub fn SCIPmessagehdlrSetData(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        messagehdlrdata: *mut SCIP_MESSAGEHDLRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the log file name for the message handler"]
    pub fn SCIPmessagehdlrSetLogfile(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        filename: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " sets the messages handler to be quiet"]
    pub fn SCIPmessagehdlrSetQuiet(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        quiet: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " prints a message, acting like the printf() command"]
    pub fn SCIPmessagePrintInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " prints a message, acting like the vprintf() command"]
    pub fn SCIPmessageVPrintInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
extern "C" {
    #[doc = " prints a message into a file, acting like the fprintf() command"]
    pub fn SCIPmessageFPrintInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " prints a message into a file, acting like the vfprintf() command"]
    pub fn SCIPmessageVFPrintInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
extern "C" {
    #[doc = " prints a warning message, acting like the printf() command"]
    pub fn SCIPmessagePrintWarning(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " prints a warning message, acting like the vprintf() command"]
    pub fn SCIPmessageVPrintWarning(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
extern "C" {
    #[doc = " prints a warning message into a file, acting like the fprintf() command"]
    pub fn SCIPmessageFPrintWarning(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " prints a warning message into a file, acting like the vfprintf() command"]
    pub fn SCIPmessageVFPrintWarning(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
extern "C" {
    #[doc = " prints a dialog message that requests user interaction, acting like the printf() command"]
    pub fn SCIPmessagePrintDialog(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " prints a dialog message that requests user interaction, acting like the vprintf() command"]
    pub fn SCIPmessageVPrintDialog(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        formatstr: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
extern "C" {
    #[doc = " prints a dialog message that requests user interaction into a file, acting like the fprintf() command"]
    pub fn SCIPmessageFPrintDialog(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " prints a dialog message that requests user interaction into a file, acting like the vfprintf() command"]
    pub fn SCIPmessageVFPrintDialog(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
extern "C" {
    #[doc = " prints a message depending on the verbosity level, acting like the printf() command"]
    pub fn SCIPmessagePrintVerbInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        verblevel: SCIP_VERBLEVEL,
        msgverblevel: SCIP_VERBLEVEL,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " prints a message depending on the verbosity level, acting like the vprintf() command"]
    pub fn SCIPmessageVPrintVerbInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        verblevel: SCIP_VERBLEVEL,
        msgverblevel: SCIP_VERBLEVEL,
        formatstr: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
extern "C" {
    #[doc = " prints a message into a file depending on the verbosity level, acting like the fprintf() command"]
    pub fn SCIPmessageFPrintVerbInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        verblevel: SCIP_VERBLEVEL,
        msgverblevel: SCIP_VERBLEVEL,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " prints a message into a file depending on the verbosity level, acting like the vfprintf() command"]
    pub fn SCIPmessageVFPrintVerbInfo(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        verblevel: SCIP_VERBLEVEL,
        msgverblevel: SCIP_VERBLEVEL,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
extern "C" {
    #[doc = " prints the header with source file location for an error message using the static message handler"]
    pub fn SCIPmessagePrintErrorHeader(
        sourcefile: *const ::std::os::raw::c_char,
        sourceline: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " prints an error message, acting like the printf() command using the static message handler"]
    pub fn SCIPmessagePrintError(formatstr: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " prints an error message, acting like the vprintf() command using the static message handler"]
    pub fn SCIPmessageVPrintError(formatstr: *const ::std::os::raw::c_char, ap: va_list);
}
extern "C" {
    #[doc = " Method to set the error printing method. Setting the error printing method to NULL will suspend all error methods."]
    #[doc = ""]
    #[doc = "  @note The error printing method is a static variable. This means that all occurring errors are handled via this method."]
    pub fn SCIPmessageSetErrorPrinting(
        errorPrinting: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                file: *mut FILE,
                msg: *const ::std::os::raw::c_char,
            ),
        >,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Method to set the error printing method to default version prints everything the stderr."]
    #[doc = ""]
    #[doc = "  @note The error printing method is a static variable. This means that all occurring errors are handled via this method."]
    pub fn SCIPmessageSetErrorPrintingDefault();
}
extern "C" {
    #[doc = " returns the user data of the message handler"]
    pub fn SCIPmessagehdlrGetData(messagehdlr: *mut SCIP_MESSAGEHDLR) -> *mut SCIP_MESSAGEHDLRDATA;
}
extern "C" {
    #[doc = " returns the log file or NULL for stdout"]
    pub fn SCIPmessagehdlrGetLogfile(messagehdlr: *mut SCIP_MESSAGEHDLR) -> *mut FILE;
}
extern "C" {
    #[doc = " returns TRUE if the message handler is set to be quiet"]
    pub fn SCIPmessagehdlrIsQuiet(messagehdlr: *mut SCIP_MESSAGEHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _calloc_base(_Count: size_t, _Size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        _Count: ::std::os::raw::c_ulonglong,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _callnewh(_Size: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _expand(
        _Block: *mut ::std::os::raw::c_void,
        _Size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _free_base(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _malloc_base(_Size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize_base(_Block: *mut ::std::os::raw::c_void) -> size_t;
}
extern "C" {
    pub fn _msize(_Block: *mut ::std::os::raw::c_void) -> size_t;
}
extern "C" {
    pub fn _realloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Count: size_t,
        _Size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: size_t,
        _Size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: size_t, _Alignment: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: size_t,
        _Alignment: size_t,
        _Offset: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_msize(
        _Block: *mut ::std::os::raw::c_void,
        _Alignment: size_t,
        _Offset: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: size_t,
        _Alignment: size_t,
        _Offset: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: size_t,
        _Size: size_t,
        _Alignment: size_t,
        _Offset: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: size_t,
        _Alignment: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: size_t,
        _Size: size_t,
        _Alignment: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __threadid() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __threadhandle() -> usize;
}
pub type _CoreCrtSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type _CoreCrtNonSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort_s(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn bsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: size_t,
        _SizeOfElements: size_t,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: size_t,
        _SizeOfElements: size_t,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    );
}
extern "C" {
    pub fn _lfind_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: size_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: size_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _itow_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itow(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ltow_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltow(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ultow_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultow(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstod(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstod_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstol(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wcstol_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoll(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoll_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoul(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoull(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoull_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcstold(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstold_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstof(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn _wcstof_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn _wtof(_String: *const wchar_t) -> f64;
}
extern "C" {
    pub fn _wtof_l(_String: *const wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_String: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtoi_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtol(_String: *const wchar_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtol_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtoll(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoll_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _i64tow_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64tow(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ui64tow_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64tow(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtoi64(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wfullpath(
        _Buffer: *mut wchar_t,
        _Path: *const wchar_t,
        _BufferCount: size_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wmakepath_s(
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wmakepath(
        _Buffer: *mut wchar_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _Dir: *mut wchar_t,
        _Filename: *mut wchar_t,
        _Ext: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath_s(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _DriveCount: size_t,
        _Dir: *mut wchar_t,
        _DirCount: size_t,
        _Filename: *mut wchar_t,
        _FilenameCount: size_t,
        _Ext: *mut wchar_t,
        _ExtCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wdupenv_s(
        _Buffer: *mut *mut wchar_t,
        _BufferCount: *mut size_t,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wgetenv_s(
        _RequiredCount: *mut size_t,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wputenv(_EnvString: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wputenv_s(_Name: *const wchar_t, _Value: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv_s(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _Buffer: *mut wchar_t,
        _BufferCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _ResultPath: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsystem(_Command: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(_Code: ::std::os::raw::c_int);
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn _set_abort_behavior(
        _Flags: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const wchar_t,
        arg2: *const wchar_t,
        arg3: *const wchar_t,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
extern "C" {
    pub fn _set_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_thread_local_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_thread_local_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sys_errlist() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __sys_nerr() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p__pgmptr() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wpgmptr() -> *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__fmode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut wchar_t) -> errno_t;
}
extern "C" {
    pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__div_t() {
    assert_eq!(
        ::std::mem::size_of::<_div_t>(),
        8usize,
        concat!("Size of: ", stringify!(_div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<_ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ldiv_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<_lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type lldiv_t = _lldiv_t;
extern "C" {
    pub fn _abs64(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _byteswap_ushort(_Number: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Number: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Number: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long)
        -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        _Numerator: ::std::os::raw::c_longlong,
        _Denominator: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn _rotl(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotl(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotl64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotr(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotr64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout__LDOUBLE() {
    assert_eq!(
        ::std::mem::size_of::<_LDOUBLE>(),
        10usize,
        concat!("Size of: ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDOUBLE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LDOUBLE>())).ld as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDOUBLE),
            "::",
            stringify!(ld)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__CRT_DOUBLE() {
    assert_eq!(
        ::std::mem::size_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CRT_DOUBLE>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_DOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[test]
fn bindgen_test_layout__CRT_FLOAT() {
    assert_eq!(
        ::std::mem::size_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Size of: ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CRT_FLOAT>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_FLOAT),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LONGDOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__LONGDOUBLE() {
    assert_eq!(
        ::std::mem::size_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LONGDOUBLE>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LONGDOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
#[test]
fn bindgen_test_layout__LDBL12() {
    assert_eq!(
        ::std::mem::size_of::<_LDBL12>(),
        12usize,
        concat!("Size of: ", stringify!(_LDBL12))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDBL12>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDBL12))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LDBL12>())).ld12 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDBL12),
            "::",
            stringify!(ld12)
        )
    );
}
extern "C" {
    pub fn atoi(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atol_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atoll_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoflt(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt_l(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl_l(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl_l(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtof(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn _strtof_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtod(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtold_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoll(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoll_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoi64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoui64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _itoa_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ltoa_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ultoa_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _i64toa_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64toa(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ui64toa_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64toa(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _gcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_l_func(_Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_l(
        _Ch: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(_String: *const ::std::os::raw::c_char) -> size_t;
}
extern "C" {
    pub fn _mbstrlen_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> size_t;
}
extern "C" {
    pub fn _mbstrnlen(_String: *const ::std::os::raw::c_char, _MaxCount: size_t) -> size_t;
}
extern "C" {
    pub fn _mbstrnlen_l(
        _String: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbtowc(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_l(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: size_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut size_t,
        _DstBuf: *mut wchar_t,
        _SizeInWords: size_t,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn mbstowcs(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _mbstowcs_s_l(
        _PtNumOfCharConverted: *mut size_t,
        _DstBuf: *mut wchar_t,
        _SizeInWords: size_t,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _mbstowcs_l(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_l(
        _MbCh: *mut ::std::os::raw::c_char,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb_s(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _WCh: wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctomb_s_l(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: size_t,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut size_t,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: size_t,
        _Src: *const wchar_t,
        _MaxCountInBytes: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _wcstombs_s_l(
        _PtNumOfCharConverted: *mut size_t,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: size_t,
        _Src: *const wchar_t,
        _MaxCountInBytes: size_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstombs_l(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn _fullpath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Path: *const ::std::os::raw::c_char,
        _BufferCount: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _makepath_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _makepath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _Dir: *mut ::std::os::raw::c_char,
        _Filename: *mut ::std::os::raw::c_char,
        _Ext: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath_s(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _DriveCount: size_t,
        _Dir: *mut ::std::os::raw::c_char,
        _DirCount: size_t,
        _Filename: *mut ::std::os::raw::c_char,
        _FilenameCount: size_t,
        _Ext: *mut ::std::os::raw::c_char,
        _ExtCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn getenv_s(
        _RequiredCount: *mut size_t,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: rsize_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn __p___argc() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p___argv() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p___wargv() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__environ() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wenviron() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _dupenv_s(
        _Buffer: *mut *mut ::std::os::raw::c_char,
        _BufferCount: *mut size_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv_s(
        _Name: *const ::std::os::raw::c_char,
        _Value: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv_s(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    #[doc = " allocates array and initializes it with 0; returns NULL if memory allocation failed"]
    pub fn BMSallocClearMemory_call(
        num: size_t,
        typesize: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates memory; returns NULL if memory allocation failed"]
    pub fn BMSallocMemory_call(
        size: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates array; returns NULL if memory allocation failed"]
    pub fn BMSallocMemoryArray_call(
        num: size_t,
        typesize: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates memory; returns NULL if memory allocation failed"]
    pub fn BMSreallocMemory_call(
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " reallocates array; returns NULL if memory allocation failed"]
    pub fn BMSreallocMemoryArray_call(
        ptr: *mut ::std::os::raw::c_void,
        num: size_t,
        typesize: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " clears a memory element (i.e. fills it with zeros)"]
    pub fn BMSclearMemory_call(ptr: *mut ::std::os::raw::c_void, size: size_t);
}
extern "C" {
    #[doc = " copies the contents of one memory element into another memory element"]
    pub fn BMScopyMemory_call(
        ptr: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_void,
        size: size_t,
    );
}
extern "C" {
    #[doc = " moves the contents of one memory element into another memory element, should be used if both elements overlap,"]
    #[doc = "  otherwise BMScopyMemory is faster"]
    pub fn BMSmoveMemory_call(
        ptr: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_void,
        size: size_t,
    );
}
extern "C" {
    #[doc = " allocates memory and copies the contents of the given memory element into the new memory element"]
    pub fn BMSduplicateMemory_call(
        source: *const ::std::os::raw::c_void,
        size: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates array and copies the contents of the given source array into the new array"]
    pub fn BMSduplicateMemoryArray_call(
        source: *const ::std::os::raw::c_void,
        num: size_t,
        typesize: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " frees an allocated memory element and sets pointer to NULL"]
    pub fn BMSfreeMemory_call(
        ptr: *mut *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " frees an allocated memory element if pointer is not NULL and sets pointer to NULL"]
    pub fn BMSfreeMemoryNull_call(
        ptr: *mut *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " returns the size of an allocated memory element"]
    pub fn BMSgetPointerSize_call(ptr: *const ::std::os::raw::c_void) -> size_t;
}
extern "C" {
    #[doc = " outputs information about currently allocated memory to the screen"]
    pub fn BMSdisplayMemory_call();
}
extern "C" {
    #[doc = " displays a warning message on the screen, if allocated memory exists"]
    pub fn BMScheckEmptyMemory_call();
}
extern "C" {
    #[doc = " returns total number of allocated bytes"]
    pub fn BMSgetMemoryUsed_call() -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BMS_ChkMem {
    _unused: [u8; 0],
}
#[doc = " Chunk Memory Management"]
#[doc = ""]
#[doc = " Efficient memory management for multiple objects of the same size"]
pub type BMS_CHKMEM = BMS_ChkMem;
extern "C" {
    #[doc = " aligns the given byte size corresponding to the minimal alignment for chunk and block memory"]
    pub fn BMSalignMemsize(size: *mut size_t);
}
extern "C" {
    #[doc = " checks whether the given size meets the alignment conditions for chunk and block memory"]
    pub fn BMSisAligned(size: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates a new chunk block data structure"]
    pub fn BMScreateChunkMemory_call(
        size: size_t,
        initchunksize: ::std::os::raw::c_int,
        garbagefactor: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut BMS_CHKMEM;
}
extern "C" {
    #[doc = " clears a chunk block data structure"]
    pub fn BMSclearChunkMemory_call(
        chkmem: *mut BMS_CHKMEM,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " destroys and frees a chunk block data structure"]
    pub fn BMSdestroyChunkMemory_call(
        chkmem: *mut *mut BMS_CHKMEM,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " allocates a memory element of the given chunk block"]
    pub fn BMSallocChunkMemory_call(
        chkmem: *mut BMS_CHKMEM,
        size: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " duplicates a given memory element by allocating a new element of the same chunk block and copying the data"]
    pub fn BMSduplicateChunkMemory_call(
        chkmem: *mut BMS_CHKMEM,
        source: *const ::std::os::raw::c_void,
        size: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " frees a memory element of the given chunk block and sets pointer to NULL"]
    pub fn BMSfreeChunkMemory_call(
        chkmem: *mut BMS_CHKMEM,
        ptr: *mut *mut ::std::os::raw::c_void,
        size: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " frees a memory element of the given chunk block if pointer is not NULL and sets pointer to NULL"]
    pub fn BMSfreeChunkMemoryNull_call(
        chkmem: *mut BMS_CHKMEM,
        ptr: *mut *mut ::std::os::raw::c_void,
        size: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " calls garbage collection of chunk block and frees chunks without allocated memory elements"]
    pub fn BMSgarbagecollectChunkMemory_call(chkmem: *mut BMS_CHKMEM);
}
extern "C" {
    #[doc = " returns the number of allocated bytes in the chunk block"]
    pub fn BMSgetChunkMemoryUsed_call(chkmem: *const BMS_CHKMEM) -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BMS_BlkMem {
    _unused: [u8; 0],
}
#[doc = " Block Memory Management"]
#[doc = ""]
#[doc = " Efficient memory management for objects of varying sizes"]
pub type BMS_BLKMEM = BMS_BlkMem;
extern "C" {
    #[doc = " creates a block memory allocation data structure"]
    pub fn BMScreateBlockMemory_call(
        initchunksize: ::std::os::raw::c_int,
        garbagefactor: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut BMS_BLKMEM;
}
extern "C" {
    #[doc = " frees all chunk blocks in the block memory"]
    pub fn BMSclearBlockMemory_call(
        blkmem: *mut BMS_BLKMEM,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " clears and deletes block memory"]
    pub fn BMSdestroyBlockMemory_call(
        blkmem: *mut *mut BMS_BLKMEM,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " allocates memory in the block memory pool"]
    pub fn BMSallocBlockMemory_call(
        blkmem: *mut BMS_BLKMEM,
        size: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates array in the block memory pool"]
    pub fn BMSallocBlockMemoryArray_call(
        blkmem: *mut BMS_BLKMEM,
        num: size_t,
        typesize: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates array in the block memory pool and clears it"]
    pub fn BMSallocClearBlockMemoryArray_call(
        blkmem: *mut BMS_BLKMEM,
        num: size_t,
        typesize: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " resizes memory element in the block memory pool and copies the data"]
    pub fn BMSreallocBlockMemory_call(
        blkmem: *mut BMS_BLKMEM,
        ptr: *mut ::std::os::raw::c_void,
        oldsize: size_t,
        newsize: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " resizes array in the block memory pool and copies the data"]
    pub fn BMSreallocBlockMemoryArray_call(
        blkmem: *mut BMS_BLKMEM,
        ptr: *mut ::std::os::raw::c_void,
        oldnum: size_t,
        newnum: size_t,
        typesize: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " duplicates memory element in the block memory pool and copies the data"]
    pub fn BMSduplicateBlockMemory_call(
        blkmem: *mut BMS_BLKMEM,
        source: *const ::std::os::raw::c_void,
        size: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " duplicates array in the block memory pool and copies the data"]
    pub fn BMSduplicateBlockMemoryArray_call(
        blkmem: *mut BMS_BLKMEM,
        source: *const ::std::os::raw::c_void,
        num: size_t,
        typesize: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " frees memory element in the block memory pool and sets pointer to NULL"]
    pub fn BMSfreeBlockMemory_call(
        blkmem: *mut BMS_BLKMEM,
        ptr: *mut *mut ::std::os::raw::c_void,
        size: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " frees memory element in the block memory pool if pointer is not NULL and sets pointer to NULL"]
    pub fn BMSfreeBlockMemoryNull_call(
        blkmem: *mut BMS_BLKMEM,
        ptr: *mut *mut ::std::os::raw::c_void,
        size: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " calls garbage collection of block memory, frees chunks without allocated memory elements, and frees"]
    #[doc = "  chunk blocks without any chunks"]
    pub fn BMSgarbagecollectBlockMemory_call(blkmem: *mut BMS_BLKMEM);
}
extern "C" {
    #[doc = " returns the number of allocated bytes in the block memory"]
    pub fn BMSgetBlockMemoryAllocated_call(blkmem: *const BMS_BLKMEM)
        -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the number of used bytes in the block memory"]
    pub fn BMSgetBlockMemoryUsed_call(blkmem: *const BMS_BLKMEM) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the number of allocated but not used bytes in the block memory"]
    pub fn BMSgetBlockMemoryUnused_call(blkmem: *const BMS_BLKMEM) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the maximal number of used bytes in the block memory"]
    pub fn BMSgetBlockMemoryUsedMax_call(blkmem: *const BMS_BLKMEM) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the maximal number of allocated but not used bytes in the block memory"]
    pub fn BMSgetBlockMemoryUnusedMax_call(blkmem: *const BMS_BLKMEM)
        -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the maximal number of allocated bytes in the block memory"]
    pub fn BMSgetBlockMemoryAllocatedMax_call(
        blkmem: *const BMS_BLKMEM,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the size of the given memory element; returns 0, if the element is not member of the block memory"]
    pub fn BMSgetBlockPointerSize_call(
        blkmem: *const BMS_BLKMEM,
        ptr: *const ::std::os::raw::c_void,
    ) -> size_t;
}
extern "C" {
    #[doc = " outputs allocation diagnostics of block memory"]
    pub fn BMSdisplayBlockMemory_call(blkmem: *const BMS_BLKMEM);
}
extern "C" {
    #[doc = " outputs error messages, if there are allocated elements in the block memory and returns number of unfreed bytes"]
    pub fn BMScheckEmptyBlockMemory_call(blkmem: *const BMS_BLKMEM) -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BMS_BufMem {
    _unused: [u8; 0],
}
#[doc = " Buffer Memory Management"]
#[doc = ""]
#[doc = " Efficient memory management for temporary objects"]
pub type BMS_BUFMEM = BMS_BufMem;
extern "C" {
    #[doc = " creates memory buffer storage"]
    pub fn BMScreateBufferMemory_call(
        arraygrowfac: f64,
        arraygrowinit: ::std::os::raw::c_int,
        clean: ::std::os::raw::c_uint,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut BMS_BUFMEM;
}
extern "C" {
    #[doc = " destroys buffer memory"]
    pub fn BMSdestroyBufferMemory_call(
        buffer: *mut *mut BMS_BUFMEM,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " set arraygrowfac"]
    pub fn BMSsetBufferMemoryArraygrowfac(buffer: *mut BMS_BUFMEM, arraygrowfac: f64);
}
extern "C" {
    #[doc = " set arraygrowinit"]
    pub fn BMSsetBufferMemoryArraygrowinit(
        buffer: *mut BMS_BUFMEM,
        arraygrowinit: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " allocates the next unused buffer"]
    pub fn BMSallocBufferMemory_call(
        buffer: *mut BMS_BUFMEM,
        size: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates the next unused buffer array"]
    pub fn BMSallocBufferMemoryArray_call(
        buffer: *mut BMS_BUFMEM,
        num: size_t,
        typesize: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates the next unused buffer and clears it"]
    pub fn BMSallocClearBufferMemoryArray_call(
        buffer: *mut BMS_BUFMEM,
        num: size_t,
        typesize: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " reallocates the buffer to at least the given size"]
    pub fn BMSreallocBufferMemory_call(
        buffer: *mut BMS_BUFMEM,
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " reallocates an array in the buffer to at least the given size"]
    pub fn BMSreallocBufferMemoryArray_call(
        buffer: *mut BMS_BUFMEM,
        ptr: *mut ::std::os::raw::c_void,
        num: size_t,
        typesize: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates the next unused buffer and copies the given memory into the buffer"]
    pub fn BMSduplicateBufferMemory_call(
        buffer: *mut BMS_BUFMEM,
        source: *const ::std::os::raw::c_void,
        size: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " allocates an array in the next unused buffer and copies the given memory into the buffer"]
    pub fn BMSduplicateBufferMemoryArray_call(
        buffer: *mut BMS_BUFMEM,
        source: *const ::std::os::raw::c_void,
        num: size_t,
        typesize: size_t,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " frees a buffer and sets pointer to NULL"]
    pub fn BMSfreeBufferMemory_call(
        buffer: *mut BMS_BUFMEM,
        ptr: *mut *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " frees a buffer if pointer is not NULL and sets pointer to NULL"]
    pub fn BMSfreeBufferMemoryNull_call(
        buffer: *mut BMS_BUFMEM,
        ptr: *mut *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " gets number of used buffers"]
    pub fn BMSgetNUsedBufferMemory(buffer: *mut BMS_BUFMEM) -> size_t;
}
extern "C" {
    #[doc = " returns the number of allocated bytes in the buffer memory"]
    pub fn BMSgetBufferMemoryUsed(bufmem: *const BMS_BUFMEM) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " outputs statistics about currently allocated buffers to the screen"]
    pub fn BMSprintBufferMemory(buffer: *mut BMS_BUFMEM);
}
#[doc = "< the method was not executed"]
pub const SCIP_Result_SCIP_DIDNOTRUN: SCIP_Result = 1;
#[doc = "< the method was not executed, but should be called again later"]
pub const SCIP_Result_SCIP_DELAYED: SCIP_Result = 2;
#[doc = "< the method was executed, but failed finding anything"]
pub const SCIP_Result_SCIP_DIDNOTFIND: SCIP_Result = 3;
#[doc = "< no infeasibility could be found"]
pub const SCIP_Result_SCIP_FEASIBLE: SCIP_Result = 4;
#[doc = "< an infeasibility was detected"]
pub const SCIP_Result_SCIP_INFEASIBLE: SCIP_Result = 5;
#[doc = "< an unboundedness was detected"]
pub const SCIP_Result_SCIP_UNBOUNDED: SCIP_Result = 6;
#[doc = "< the current node is infeasible and can be cut off"]
pub const SCIP_Result_SCIP_CUTOFF: SCIP_Result = 7;
#[doc = "< the method added a cutting plane"]
pub const SCIP_Result_SCIP_SEPARATED: SCIP_Result = 8;
#[doc = "< the method added a cutting plane and a new separation round should immediately start"]
pub const SCIP_Result_SCIP_NEWROUND: SCIP_Result = 9;
#[doc = "< the method reduced the domain of a variable"]
pub const SCIP_Result_SCIP_REDUCEDDOM: SCIP_Result = 10;
#[doc = "< the method added a constraint"]
pub const SCIP_Result_SCIP_CONSADDED: SCIP_Result = 11;
#[doc = "< the method changed a constraint"]
pub const SCIP_Result_SCIP_CONSCHANGED: SCIP_Result = 12;
#[doc = "< the method created a branching"]
pub const SCIP_Result_SCIP_BRANCHED: SCIP_Result = 13;
#[doc = "< the current node's LP must be solved"]
pub const SCIP_Result_SCIP_SOLVELP: SCIP_Result = 14;
#[doc = "< the method found a feasible primal solution"]
pub const SCIP_Result_SCIP_FOUNDSOL: SCIP_Result = 15;
#[doc = "< the method interrupted its execution, but can continue if needed"]
pub const SCIP_Result_SCIP_SUSPENDED: SCIP_Result = 16;
#[doc = "< the method was successfully executed"]
pub const SCIP_Result_SCIP_SUCCESS: SCIP_Result = 17;
#[doc = "< the processing of the branch-and-bound node should stopped and continued later"]
pub const SCIP_Result_SCIP_DELAYNODE: SCIP_Result = 18;
#[doc = " result codes for SCIP callback methods"]
pub type SCIP_Result = ::std::os::raw::c_int;
pub use self::SCIP_Result as SCIP_RESULT;
#[doc = "< use default clock type"]
pub const SCIP_ClockType_SCIP_CLOCKTYPE_DEFAULT: SCIP_ClockType = 0;
#[doc = "< use CPU clock"]
pub const SCIP_ClockType_SCIP_CLOCKTYPE_CPU: SCIP_ClockType = 1;
#[doc = "< use wall clock"]
pub const SCIP_ClockType_SCIP_CLOCKTYPE_WALL: SCIP_ClockType = 2;
pub type SCIP_ClockType = ::std::os::raw::c_int;
pub use self::SCIP_ClockType as SCIP_CLOCKTYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Clock {
    _unused: [u8; 0],
}
pub type SCIP_CLOCK = SCIP_Clock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_CPUClock {
    _unused: [u8; 0],
}
pub type SCIP_CPUCLOCK = SCIP_CPUClock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_WallClock {
    _unused: [u8; 0],
}
pub type SCIP_WALLCLOCK = SCIP_WallClock;
#[doc = "< one-sided confidence level 75 %, two-sided 50 %"]
pub const SCIP_Confidencelevel_SCIP_CONFIDENCELEVEL_MIN: SCIP_Confidencelevel = 0;
#[doc = "< (one-sided) confidence level 87.5 %, two-sided 75 %"]
pub const SCIP_Confidencelevel_SCIP_CONFIDENCELEVEL_LOW: SCIP_Confidencelevel = 1;
#[doc = "< (one-sided) confidence level 90 %, two-sided 80 %"]
pub const SCIP_Confidencelevel_SCIP_CONFIDENCELEVEL_MEDIUM: SCIP_Confidencelevel = 2;
#[doc = "< (one-sided) confidence level 95 %, two-sided 90 %"]
pub const SCIP_Confidencelevel_SCIP_CONFIDENCELEVEL_HIGH: SCIP_Confidencelevel = 3;
#[doc = "< (one-sided) confidence level 97.5 %, two-sided 95 %"]
pub const SCIP_Confidencelevel_SCIP_CONFIDENCELEVEL_MAX: SCIP_Confidencelevel = 4;
#[doc = " represents different confidence levels for (one-sided) hypothesis testing; in order to obtain two-sided confidence"]
#[doc = "  levels, calculate 2 * c - 1, i.e., if the one-sided confidence level is 90 %, the two-sided level is 80 %"]
pub type SCIP_Confidencelevel = ::std::os::raw::c_int;
pub use self::SCIP_Confidencelevel as SCIP_CONFIDENCELEVEL;
#[doc = "< the hashmap did not store a single element yet, type unknown"]
pub const SCIP_Hashmaptype_SCIP_HASHMAPTYPE_UNKNOWN: SCIP_Hashmaptype = 0;
#[doc = "< the hashmap stores pointers %"]
pub const SCIP_Hashmaptype_SCIP_HASHMAPTYPE_POINTER: SCIP_Hashmaptype = 1;
#[doc = "< the hashmap stores reals"]
pub const SCIP_Hashmaptype_SCIP_HASHMAPTYPE_REAL: SCIP_Hashmaptype = 2;
#[doc = "< the hashmap stores ints"]
pub const SCIP_Hashmaptype_SCIP_HASHMAPTYPE_INT: SCIP_Hashmaptype = 3;
#[doc = " type of hashmap: are pointers, reals or ints stored, or unknown"]
pub type SCIP_Hashmaptype = ::std::os::raw::c_int;
pub use self::SCIP_Hashmaptype as SCIP_HASHMAPTYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SparseSol {
    _unused: [u8; 0],
}
#[doc = " Sparse solution data structure"]
#[doc = ""]
#[doc = "  - \\ref SparseSol \"List of all available methods\""]
pub type SCIP_SPARSESOL = SCIP_SparseSol;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Queue {
    _unused: [u8; 0],
}
#[doc = " (circular) Queue data structure"]
#[doc = ""]
#[doc = "  - \\ref Queue \"List of all available methods\""]
pub type SCIP_QUEUE = SCIP_Queue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_PQueue {
    _unused: [u8; 0],
}
#[doc = " Priority queue data structure"]
#[doc = ""]
#[doc = "  - \\ref PriorityQueue \"List of all available methods\""]
pub type SCIP_PQUEUE = SCIP_PQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_HashTable {
    _unused: [u8; 0],
}
#[doc = " Hash table data structure"]
#[doc = ""]
#[doc = "  - \\ref HashTable \"List of all available methods\""]
pub type SCIP_HASHTABLE = SCIP_HashTable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_MultiHash {
    _unused: [u8; 0],
}
#[doc = " Hash table data structure which allows multiple occurences of an element"]
#[doc = ""]
#[doc = "  - \\ref MultiHash \"List of all available methods\""]
pub type SCIP_MULTIHASH = SCIP_MultiHash;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_MultiHashList {
    _unused: [u8; 0],
}
#[doc = " Hash table element list to store single elements of a multi hash table"]
pub type SCIP_MULTIHASHLIST = SCIP_MultiHashList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_HashMapEntry {
    _unused: [u8; 0],
}
#[doc = " Hash map entry"]
pub type SCIP_HASHMAPENTRY = SCIP_HashMapEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_HashMap {
    _unused: [u8; 0],
}
#[doc = " Hash map data structure"]
#[doc = ""]
#[doc = "  - \\ref HashMap \"List of all available methods\""]
pub type SCIP_HASHMAP = SCIP_HashMap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_HashSet {
    _unused: [u8; 0],
}
#[doc = " Hash set data structure"]
#[doc = ""]
#[doc = "  - \\ref HashMap \"List of all available methods\""]
pub type SCIP_HASHSET = SCIP_HashSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_RealArray {
    _unused: [u8; 0],
}
#[doc = " dynamic array for storing SCIP_Real values"]
pub type SCIP_REALARRAY = SCIP_RealArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_IntArray {
    _unused: [u8; 0],
}
#[doc = " dynamic array for storing int values"]
pub type SCIP_INTARRAY = SCIP_IntArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BoolArray {
    _unused: [u8; 0],
}
#[doc = " dynamic array for storing SCIP_Bool values"]
pub type SCIP_BOOLARRAY = SCIP_BoolArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_PtrArray {
    _unused: [u8; 0],
}
#[doc = " dynamic array for storing pointers"]
pub type SCIP_PTRARRAY = SCIP_PtrArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_RandNumGen {
    _unused: [u8; 0],
}
#[doc = " random number generator"]
pub type SCIP_RANDNUMGEN = SCIP_RandNumGen;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ResourceActivity {
    _unused: [u8; 0],
}
#[doc = " Resource activity data structure"]
#[doc = ""]
#[doc = "  - \\ref ResourceActivity \"List of all available methods\""]
pub type SCIP_RESOURCEACTIVITY = SCIP_ResourceActivity;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Profile {
    _unused: [u8; 0],
}
#[doc = " Resource profile data structure"]
#[doc = ""]
#[doc = "  - \\ref ResourceProfile \"List of all available methods\""]
pub type SCIP_PROFILE = SCIP_Profile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Digraph {
    _unused: [u8; 0],
}
#[doc = " Directed graph data structure (stored as adjacency list)"]
#[doc = ""]
#[doc = "  - \\ref DirectedGraph \"List of all available methods\""]
pub type SCIP_DIGRAPH = SCIP_Digraph;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Bt {
    _unused: [u8; 0],
}
#[doc = " Binary tree data structure"]
#[doc = ""]
#[doc = "  - \\ref BinaryTree \"List of all available methods\""]
pub type SCIP_BT = SCIP_Bt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BtNode {
    _unused: [u8; 0],
}
#[doc = " search node of \\ref SCIP_BT \"binary tree\""]
pub type SCIP_BTNODE = SCIP_BtNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Regression {
    _unused: [u8; 0],
}
#[doc = " regression data structure to compute an incremental linear regression of paired observations"]
#[doc = ""]
#[doc = "  - \\ref Regression \"List of all available methods\""]
pub type SCIP_REGRESSION = SCIP_Regression;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DisjointSet {
    _unused: [u8; 0],
}
#[doc = " disjoint set (disjoint set (union find)) data structure for querying and updating connectedness of a graph with integer vertices 0,...,n - 1"]
#[doc = ""]
#[doc = "  - \\ref DisjointSet \"List of available methods\""]
pub type SCIP_DISJOINTSET = SCIP_DisjointSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Scip {
    _unused: [u8; 0],
}
pub type SCIP = Scip;
pub type SCIP_PRESOLTIMING = ::std::os::raw::c_uint;
pub type SCIP_PROPTIMING = ::std::os::raw::c_uint;
pub type SCIP_HEURTIMING = ::std::os::raw::c_uint;
#[doc = "< bool values: TRUE or FALSE"]
pub const SCIP_ParamType_SCIP_PARAMTYPE_BOOL: SCIP_ParamType = 0;
#[doc = "< integer values"]
pub const SCIP_ParamType_SCIP_PARAMTYPE_INT: SCIP_ParamType = 1;
#[doc = "< long integer values"]
pub const SCIP_ParamType_SCIP_PARAMTYPE_LONGINT: SCIP_ParamType = 2;
#[doc = "< real values"]
pub const SCIP_ParamType_SCIP_PARAMTYPE_REAL: SCIP_ParamType = 3;
#[doc = "< characters"]
pub const SCIP_ParamType_SCIP_PARAMTYPE_CHAR: SCIP_ParamType = 4;
#[doc = "< strings: arrays of characters"]
pub const SCIP_ParamType_SCIP_PARAMTYPE_STRING: SCIP_ParamType = 5;
#[doc = " possible parameter types"]
pub type SCIP_ParamType = ::std::os::raw::c_int;
pub use self::SCIP_ParamType as SCIP_PARAMTYPE;
#[doc = "< use default values"]
pub const SCIP_ParamSetting_SCIP_PARAMSETTING_DEFAULT: SCIP_ParamSetting = 0;
#[doc = "< set to aggressive settings"]
pub const SCIP_ParamSetting_SCIP_PARAMSETTING_AGGRESSIVE: SCIP_ParamSetting = 1;
#[doc = "< set to fast settings"]
pub const SCIP_ParamSetting_SCIP_PARAMSETTING_FAST: SCIP_ParamSetting = 2;
#[doc = "< turn off"]
pub const SCIP_ParamSetting_SCIP_PARAMSETTING_OFF: SCIP_ParamSetting = 3;
#[doc = " possible parameter settings - used to determine the behavior of different SCIP components, e.g., heuristics, separators, ..."]
pub type SCIP_ParamSetting = ::std::os::raw::c_int;
pub use self::SCIP_ParamSetting as SCIP_PARAMSETTING;
#[doc = "< use default values"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_DEFAULT: SCIP_ParamEmphasis = 0;
#[doc = "< get CP like search (e.g. no LP relaxation)"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_CPSOLVER: SCIP_ParamEmphasis = 1;
#[doc = "< solve easy problems fast"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_EASYCIP: SCIP_ParamEmphasis = 2;
#[doc = "< detect feasibility fast"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_FEASIBILITY: SCIP_ParamEmphasis = 3;
#[doc = "< be capable to handle hard LPs"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_HARDLP: SCIP_ParamEmphasis = 4;
#[doc = "< prove optimality fast"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_OPTIMALITY: SCIP_ParamEmphasis = 5;
#[doc = "< get a feasible and \"fast\" counting process"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_COUNTER: SCIP_ParamEmphasis = 6;
#[doc = "< feasibility phase settings during 3-phase solving approach"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_PHASEFEAS: SCIP_ParamEmphasis = 7;
#[doc = "< improvement phase settings during 3-phase solving approach"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_PHASEIMPROVE: SCIP_ParamEmphasis = 8;
#[doc = "< proof phase settings during 3-phase solving approach"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_PHASEPROOF: SCIP_ParamEmphasis = 9;
#[doc = "< emphasis parameters for increased numerical safety"]
pub const SCIP_ParamEmphasis_SCIP_PARAMEMPHASIS_NUMERICS: SCIP_ParamEmphasis = 10;
#[doc = " possible parameter emphases - used to determine the general SCIP behavior"]
pub type SCIP_ParamEmphasis = ::std::os::raw::c_int;
pub use self::SCIP_ParamEmphasis as SCIP_PARAMEMPHASIS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Param {
    _unused: [u8; 0],
}
pub type SCIP_PARAM = SCIP_Param;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ParamData {
    _unused: [u8; 0],
}
pub type SCIP_PARAMDATA = SCIP_ParamData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ParamSet {
    _unused: [u8; 0],
}
pub type SCIP_PARAMSET = SCIP_ParamSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Lldiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout__Lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<_Lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_Lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_Lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_Lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type imaxdiv_t = _Lldiv_t;
extern "C" {
    pub fn imaxabs(_Number: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(_Numerator: intmax_t, _Denominator: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn _strtoimax_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _strtoumax_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn _wcstoimax_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _wcstoumax_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> uintmax_t;
}
pub type SCIP_EVENTTYPE = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Eventhdlr {
    _unused: [u8; 0],
}
pub type SCIP_EVENTHDLR = SCIP_Eventhdlr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventhdlrData {
    _unused: [u8; 0],
}
pub type SCIP_EVENTHDLRDATA = SCIP_EventhdlrData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Event {
    _unused: [u8; 0],
}
pub type SCIP_EVENT = SCIP_Event;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventVarAdded {
    _unused: [u8; 0],
}
pub type SCIP_EVENTVARADDED = SCIP_EventVarAdded;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventVarDeleted {
    _unused: [u8; 0],
}
pub type SCIP_EVENTVARDELETED = SCIP_EventVarDeleted;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventVarFixed {
    _unused: [u8; 0],
}
pub type SCIP_EVENTVARFIXED = SCIP_EventVarFixed;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventVarUnlocked {
    _unused: [u8; 0],
}
pub type SCIP_EVENTVARUNLOCKED = SCIP_EventVarUnlocked;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventObjChg {
    _unused: [u8; 0],
}
pub type SCIP_EVENTOBJCHG = SCIP_EventObjChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventBdChg {
    _unused: [u8; 0],
}
pub type SCIP_EVENTBDCHG = SCIP_EventBdChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventHole {
    _unused: [u8; 0],
}
pub type SCIP_EVENTHOLE = SCIP_EventHole;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventImplAdd {
    _unused: [u8; 0],
}
pub type SCIP_EVENTIMPLADD = SCIP_EventImplAdd;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventTypeChg {
    _unused: [u8; 0],
}
pub type SCIP_EVENTTYPECHG = SCIP_EventTypeChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowAddedSepa {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWADDEDSEPA = SCIP_EventRowAddedSepa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowDeletedSepa {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWDELETEDSEPA = SCIP_EventRowDeletedSepa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowAddedLP {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWADDEDLP = SCIP_EventRowAddedLP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowDeletedLP {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWDELETEDLP = SCIP_EventRowDeletedLP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowCoefChanged {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWCOEFCHANGED = SCIP_EventRowCoefChanged;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowConstChanged {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWCONSTCHANGED = SCIP_EventRowConstChanged;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventRowSideChanged {
    _unused: [u8; 0],
}
pub type SCIP_EVENTROWSIDECHANGED = SCIP_EventRowSideChanged;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventData {
    _unused: [u8; 0],
}
pub type SCIP_EVENTDATA = SCIP_EventData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventFilter {
    _unused: [u8; 0],
}
pub type SCIP_EVENTFILTER = SCIP_EventFilter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_EventQueue {
    _unused: [u8; 0],
}
pub type SCIP_EVENTQUEUE = SCIP_EventQueue;
#[doc = "< LP was not solved, no solution exists"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_NOTSOLVED: SCIP_LPSolStat = 0;
#[doc = "< LP was solved to optimality"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_OPTIMAL: SCIP_LPSolStat = 1;
#[doc = "< LP is primal infeasible"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_INFEASIBLE: SCIP_LPSolStat = 2;
#[doc = "< LP has a primal unbounded ray"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_UNBOUNDEDRAY: SCIP_LPSolStat = 3;
#[doc = "< objective limit was reached during optimization"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_OBJLIMIT: SCIP_LPSolStat = 4;
#[doc = "< iteration limit was reached during optimization"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_ITERLIMIT: SCIP_LPSolStat = 5;
#[doc = "< time limit was reached during optimization"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_TIMELIMIT: SCIP_LPSolStat = 6;
#[doc = "< an error occured during optimization"]
pub const SCIP_LPSolStat_SCIP_LPSOLSTAT_ERROR: SCIP_LPSolStat = 7;
#[doc = " solution status after solving LP"]
pub type SCIP_LPSolStat = ::std::os::raw::c_int;
pub use self::SCIP_LPSolStat as SCIP_LPSOLSTAT;
#[doc = "< lower bound"]
pub const SCIP_BoundType_SCIP_BOUNDTYPE_LOWER: SCIP_BoundType = 0;
#[doc = "< upper bound"]
pub const SCIP_BoundType_SCIP_BOUNDTYPE_UPPER: SCIP_BoundType = 1;
#[doc = " type of variable bound: lower or upper bound"]
pub type SCIP_BoundType = ::std::os::raw::c_int;
pub use self::SCIP_BoundType as SCIP_BOUNDTYPE;
#[doc = "< left hand side"]
pub const SCIP_SideType_SCIP_SIDETYPE_LEFT: SCIP_SideType = 0;
#[doc = "< right hand side"]
pub const SCIP_SideType_SCIP_SIDETYPE_RIGHT: SCIP_SideType = 1;
#[doc = " type of row side: left hand or right hand side"]
pub type SCIP_SideType = ::std::os::raw::c_int;
pub use self::SCIP_SideType as SCIP_SIDETYPE;
#[doc = "< unspecified origin of row"]
pub const SCIP_RowOriginType_SCIP_ROWORIGINTYPE_UNSPEC: SCIP_RowOriginType = 0;
#[doc = "< row created by a constraint handler"]
pub const SCIP_RowOriginType_SCIP_ROWORIGINTYPE_CONSHDLR: SCIP_RowOriginType = 1;
#[doc = "< row created by a constraint"]
pub const SCIP_RowOriginType_SCIP_ROWORIGINTYPE_CONS: SCIP_RowOriginType = 2;
#[doc = "< row created by separator"]
pub const SCIP_RowOriginType_SCIP_ROWORIGINTYPE_SEPA: SCIP_RowOriginType = 3;
#[doc = "< row created by reoptimization"]
pub const SCIP_RowOriginType_SCIP_ROWORIGINTYPE_REOPT: SCIP_RowOriginType = 4;
#[doc = " type of origin of row"]
pub type SCIP_RowOriginType = ::std::os::raw::c_int;
pub use self::SCIP_RowOriginType as SCIP_ROWORIGINTYPE;
#[doc = "< primal simplex"]
pub const SCIP_LPAlgo_SCIP_LPALGO_PRIMALSIMPLEX: SCIP_LPAlgo = 0;
#[doc = "< dual simplex"]
pub const SCIP_LPAlgo_SCIP_LPALGO_DUALSIMPLEX: SCIP_LPAlgo = 1;
#[doc = "< barrier algorithm"]
pub const SCIP_LPAlgo_SCIP_LPALGO_BARRIER: SCIP_LPAlgo = 2;
#[doc = "< barrier algorithm with crossover"]
pub const SCIP_LPAlgo_SCIP_LPALGO_BARRIERCROSSOVER: SCIP_LPAlgo = 3;
#[doc = " type of LP algorithm"]
pub type SCIP_LPAlgo = ::std::os::raw::c_int;
pub use self::SCIP_LPAlgo as SCIP_LPALGO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ColSolVals {
    _unused: [u8; 0],
}
pub type SCIP_COLSOLVALS = SCIP_ColSolVals;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_RowSolVals {
    _unused: [u8; 0],
}
pub type SCIP_ROWSOLVALS = SCIP_RowSolVals;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LpSolVals {
    _unused: [u8; 0],
}
pub type SCIP_LPSOLVALS = SCIP_LpSolVals;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Col {
    _unused: [u8; 0],
}
#[doc = " column of an LP"]
#[doc = ""]
#[doc = "  - \\ref PublicColumnMethods \"List of all available methods\""]
pub type SCIP_COL = SCIP_Col;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Row {
    _unused: [u8; 0],
}
#[doc = " row of an LP"]
#[doc = ""]
#[doc = "  - \\ref PublicRowMethods \"List of all available methods\""]
pub type SCIP_ROW = SCIP_Row;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Lp {
    _unused: [u8; 0],
}
#[doc = " LP structure"]
#[doc = ""]
#[doc = "  - \\ref PublicLPMethods \"List of all available methods\""]
pub type SCIP_LP = SCIP_Lp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NlRow {
    _unused: [u8; 0],
}
pub type SCIP_NLROW = SCIP_NlRow;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Nlp {
    _unused: [u8; 0],
}
pub type SCIP_NLP = SCIP_Nlp;
#[doc = "< variable belongs to original problem"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_ORIGINAL: SCIP_Varstatus = 0;
#[doc = "< variable is a loose variable of the transformed problem"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_LOOSE: SCIP_Varstatus = 1;
#[doc = "< variable is a column of the transformed problem"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_COLUMN: SCIP_Varstatus = 2;
#[doc = "< variable is fixed to specific value in the transformed problem"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_FIXED: SCIP_Varstatus = 3;
#[doc = "< variable is aggregated to x = a*y + c in the transformed problem"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_AGGREGATED: SCIP_Varstatus = 4;
#[doc = "< variable is aggregated to x = a_1*y_1 + ... + a_k*y_k + c"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_MULTAGGR: SCIP_Varstatus = 5;
#[doc = "< variable is the negation of an original or transformed variable"]
pub const SCIP_Varstatus_SCIP_VARSTATUS_NEGATED: SCIP_Varstatus = 6;
#[doc = " status of problem variables"]
pub type SCIP_Varstatus = ::std::os::raw::c_int;
pub use self::SCIP_Varstatus as SCIP_VARSTATUS;
#[doc = "< binary variable: \\f$ x \\in \\{0,1\\} \\f$"]
pub const SCIP_Vartype_SCIP_VARTYPE_BINARY: SCIP_Vartype = 0;
#[doc = "< integer variable: \\f$ x in \\{lb, \\dots, ub\\} \\f$"]
pub const SCIP_Vartype_SCIP_VARTYPE_INTEGER: SCIP_Vartype = 1;
#[doc = "< implicit integer variable: Integrality of this variable is implied for every optimal"]
#[doc = "solution of the remaining problem after any fixing all integer and binary variables,"]
#[doc = "without the explicit need to enforce integrality further"]
pub const SCIP_Vartype_SCIP_VARTYPE_IMPLINT: SCIP_Vartype = 2;
#[doc = "< continuous variable: \\f$ lb \\leq x \\leq ub \\f$"]
pub const SCIP_Vartype_SCIP_VARTYPE_CONTINUOUS: SCIP_Vartype = 3;
#[doc = " variable type"]
pub type SCIP_Vartype = ::std::os::raw::c_int;
pub use self::SCIP_Vartype as SCIP_VARTYPE;
#[doc = "< dynamic bound changes with size information of arrays"]
pub const SCIP_DomchgType_SCIP_DOMCHGTYPE_DYNAMIC: SCIP_DomchgType = 0;
#[doc = "< static domain changes: number of entries equals size of arrays"]
pub const SCIP_DomchgType_SCIP_DOMCHGTYPE_BOTH: SCIP_DomchgType = 1;
#[doc = "< static domain changes without any hole changes"]
pub const SCIP_DomchgType_SCIP_DOMCHGTYPE_BOUND: SCIP_DomchgType = 2;
#[doc = " domain change data type"]
pub type SCIP_DomchgType = ::std::os::raw::c_int;
pub use self::SCIP_DomchgType as SCIP_DOMCHGTYPE;
#[doc = "< bound change was due to a branching decision"]
pub const SCIP_BoundchgType_SCIP_BOUNDCHGTYPE_BRANCHING: SCIP_BoundchgType = 0;
#[doc = "< bound change was due to an inference of a constraint (domain propagation)"]
pub const SCIP_BoundchgType_SCIP_BOUNDCHGTYPE_CONSINFER: SCIP_BoundchgType = 1;
#[doc = "< bound change was due to an inference of a domain propagator"]
pub const SCIP_BoundchgType_SCIP_BOUNDCHGTYPE_PROPINFER: SCIP_BoundchgType = 2;
#[doc = " bound change type"]
pub type SCIP_BoundchgType = ::std::os::raw::c_int;
pub use self::SCIP_BoundchgType as SCIP_BOUNDCHGTYPE;
#[doc = "< variable locks for model and check constraints"]
pub const SCIP_LockType_SCIP_LOCKTYPE_MODEL: SCIP_LockType = 0;
#[doc = "< variable locks for conflict constraints"]
pub const SCIP_LockType_SCIP_LOCKTYPE_CONFLICT: SCIP_LockType = 1;
pub type SCIP_LockType = ::std::os::raw::c_int;
pub use self::SCIP_LockType as SCIP_LOCKTYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DomChgBound {
    _unused: [u8; 0],
}
pub type SCIP_DOMCHGBOUND = SCIP_DomChgBound;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DomChgBoth {
    _unused: [u8; 0],
}
pub type SCIP_DOMCHGBOTH = SCIP_DomChgBoth;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DomChgDyn {
    _unused: [u8; 0],
}
pub type SCIP_DOMCHGDYN = SCIP_DomChgDyn;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SCIP_DomChg {
    _unused: [u8; 0],
}
pub type SCIP_DOMCHG = SCIP_DomChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BoundChg {
    _unused: [u8; 0],
}
pub type SCIP_BOUNDCHG = SCIP_BoundChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BdChgIdx {
    _unused: [u8; 0],
}
pub type SCIP_BDCHGIDX = SCIP_BdChgIdx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BdChgInfo {
    _unused: [u8; 0],
}
pub type SCIP_BDCHGINFO = SCIP_BdChgInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BranchingData {
    _unused: [u8; 0],
}
pub type SCIP_BRANCHINGDATA = SCIP_BranchingData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_InferenceData {
    _unused: [u8; 0],
}
pub type SCIP_INFERENCEDATA = SCIP_InferenceData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_HoleChg {
    _unused: [u8; 0],
}
pub type SCIP_HOLECHG = SCIP_HoleChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Hole {
    _unused: [u8; 0],
}
pub type SCIP_HOLE = SCIP_Hole;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Holelist {
    _unused: [u8; 0],
}
pub type SCIP_HOLELIST = SCIP_Holelist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Dom {
    _unused: [u8; 0],
}
pub type SCIP_DOM = SCIP_Dom;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Original {
    _unused: [u8; 0],
}
pub type SCIP_ORIGINAL = SCIP_Original;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Aggregate {
    _unused: [u8; 0],
}
pub type SCIP_AGGREGATE = SCIP_Aggregate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Multaggr {
    _unused: [u8; 0],
}
pub type SCIP_MULTAGGR = SCIP_Multaggr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Negate {
    _unused: [u8; 0],
}
pub type SCIP_NEGATE = SCIP_Negate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Var {
    _unused: [u8; 0],
}
pub type SCIP_VAR = SCIP_Var;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_VarData {
    _unused: [u8; 0],
}
pub type SCIP_VARDATA = SCIP_VarData;
#[doc = "< maximization of objective function"]
pub const SCIP_Objsense_SCIP_OBJSENSE_MAXIMIZE: SCIP_Objsense = -1;
#[doc = "< minimization of objective function (the default)"]
pub const SCIP_Objsense_SCIP_OBJSENSE_MINIMIZE: SCIP_Objsense = 1;
#[doc = " objective sense: minimization or maximization"]
pub type SCIP_Objsense = ::std::os::raw::c_int;
pub use self::SCIP_Objsense as SCIP_OBJSENSE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Prob {
    _unused: [u8; 0],
}
pub type SCIP_PROB = SCIP_Prob;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ProbData {
    _unused: [u8; 0],
}
pub type SCIP_PROBDATA = SCIP_ProbData;
#[doc = "< the focus node, whose data is stored in the tree data structure"]
pub const SCIP_NodeType_SCIP_NODETYPE_FOCUSNODE: SCIP_NodeType = 0;
#[doc = "< temporary child node of the focus or refocused node used for probing"]
pub const SCIP_NodeType_SCIP_NODETYPE_PROBINGNODE: SCIP_NodeType = 1;
#[doc = "< unsolved sibling of the focus node"]
pub const SCIP_NodeType_SCIP_NODETYPE_SIBLING: SCIP_NodeType = 2;
#[doc = "< unsolved child of the focus node"]
pub const SCIP_NodeType_SCIP_NODETYPE_CHILD: SCIP_NodeType = 3;
#[doc = "< unsolved leaf of the tree, stored in the tree's queue"]
pub const SCIP_NodeType_SCIP_NODETYPE_LEAF: SCIP_NodeType = 4;
#[doc = "< temporary type of focus node, if it was solved completely"]
pub const SCIP_NodeType_SCIP_NODETYPE_DEADEND: SCIP_NodeType = 5;
#[doc = "< fork without LP solution"]
pub const SCIP_NodeType_SCIP_NODETYPE_JUNCTION: SCIP_NodeType = 6;
#[doc = "< fork without LP solution and added rows and columns"]
pub const SCIP_NodeType_SCIP_NODETYPE_PSEUDOFORK: SCIP_NodeType = 7;
#[doc = "< fork with solved LP and added rows and columns"]
pub const SCIP_NodeType_SCIP_NODETYPE_FORK: SCIP_NodeType = 8;
#[doc = "< fork with solved LP and arbitrarily changed rows and columns"]
pub const SCIP_NodeType_SCIP_NODETYPE_SUBROOT: SCIP_NodeType = 9;
#[doc = "< junction, fork, or subroot that was refocused for domain propagation"]
pub const SCIP_NodeType_SCIP_NODETYPE_REFOCUSNODE: SCIP_NodeType = 10;
pub type SCIP_NodeType = ::std::os::raw::c_int;
pub use self::SCIP_NodeType as SCIP_NODETYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Probingnode {
    _unused: [u8; 0],
}
pub type SCIP_PROBINGNODE = SCIP_Probingnode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Sibling {
    _unused: [u8; 0],
}
pub type SCIP_SIBLING = SCIP_Sibling;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Child {
    _unused: [u8; 0],
}
pub type SCIP_CHILD = SCIP_Child;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Leaf {
    _unused: [u8; 0],
}
pub type SCIP_LEAF = SCIP_Leaf;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Junction {
    _unused: [u8; 0],
}
pub type SCIP_JUNCTION = SCIP_Junction;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Pseudofork {
    _unused: [u8; 0],
}
pub type SCIP_PSEUDOFORK = SCIP_Pseudofork;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Fork {
    _unused: [u8; 0],
}
pub type SCIP_FORK = SCIP_Fork;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Subroot {
    _unused: [u8; 0],
}
pub type SCIP_SUBROOT = SCIP_Subroot;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Node {
    _unused: [u8; 0],
}
pub type SCIP_NODE = SCIP_Node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_PendingBdchg {
    _unused: [u8; 0],
}
pub type SCIP_PENDINGBDCHG = SCIP_PendingBdchg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Tree {
    _unused: [u8; 0],
}
pub type SCIP_TREE = SCIP_Tree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Bandit {
    _unused: [u8; 0],
}
#[doc = " data structure for bandit algorithms"]
pub type SCIP_BANDIT = SCIP_Bandit;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BanditVTable {
    _unused: [u8; 0],
}
#[doc = " virtual function table for bandit callbacks"]
pub type SCIP_BANDITVTABLE = SCIP_BanditVTable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BanditData {
    _unused: [u8; 0],
}
#[doc = " data structure for specific bandit algorithm implementation"]
pub type SCIP_BANDITDATA = SCIP_BanditData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BranchCand {
    _unused: [u8; 0],
}
pub type SCIP_BRANCHCAND = SCIP_BranchCand;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Branchrule {
    _unused: [u8; 0],
}
pub type SCIP_BRANCHRULE = SCIP_Branchrule;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BranchruleData {
    _unused: [u8; 0],
}
pub type SCIP_BRANCHRULEDATA = SCIP_BranchruleData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Treemodel {
    _unused: [u8; 0],
}
pub type SCIP_TREEMODEL = SCIP_Treemodel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Conflicthdlr {
    _unused: [u8; 0],
}
pub type SCIP_CONFLICTHDLR = SCIP_Conflicthdlr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConflicthdlrData {
    _unused: [u8; 0],
}
pub type SCIP_CONFLICTHDLRDATA = SCIP_ConflicthdlrData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConflictSet {
    _unused: [u8; 0],
}
pub type SCIP_CONFLICTSET = SCIP_ConflictSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ProofSet {
    _unused: [u8; 0],
}
pub type SCIP_PROOFSET = SCIP_ProofSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LPBdChgs {
    _unused: [u8; 0],
}
pub type SCIP_LPBDCHGS = SCIP_LPBdChgs;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Conflict {
    _unused: [u8; 0],
}
pub type SCIP_CONFLICT = SCIP_Conflict;
#[doc = "< unknown type"]
pub const SCIP_ConflictType_SCIP_CONFTYPE_UNKNOWN: SCIP_ConflictType = 0;
#[doc = "< conflict results from propagation"]
pub const SCIP_ConflictType_SCIP_CONFTYPE_PROPAGATION: SCIP_ConflictType = 1;
#[doc = "< conflict results from an infeasible LP relaxation"]
pub const SCIP_ConflictType_SCIP_CONFTYPE_INFEASLP: SCIP_ConflictType = 2;
#[doc = "< conflict results from a boundexceeding LP relaxation"]
pub const SCIP_ConflictType_SCIP_CONFTYPE_BNDEXCEEDING: SCIP_ConflictType = 3;
#[doc = "< alternative proof of an infeasible LP relaxation"]
pub const SCIP_ConflictType_SCIP_CONFTYPE_ALTINFPROOF: SCIP_ConflictType = 4;
#[doc = "< alternative proof of a boundexceeding LP relaxation"]
pub const SCIP_ConflictType_SCIP_CONFTYPE_ALTBNDPROOF: SCIP_ConflictType = 5;
#[doc = " types of conflicts"]
pub type SCIP_ConflictType = ::std::os::raw::c_int;
pub use self::SCIP_ConflictType as SCIP_CONFTYPE;
#[doc = "< no presolving"]
pub const SCIP_ConflictPresolStrat_SCIP_CONFPRES_DISABLED: SCIP_ConflictPresolStrat = 0;
#[doc = "< keep variables contributing with its local bound"]
pub const SCIP_ConflictPresolStrat_SCIP_CONFPRES_ONLYLOCAL: SCIP_ConflictPresolStrat = 1;
#[doc = "< keep variables contributing with its global bound"]
pub const SCIP_ConflictPresolStrat_SCIP_CONFPRES_ONLYGLOBAL: SCIP_ConflictPresolStrat = 2;
#[doc = "< keep variables contributing with its global bound and add a few"]
#[doc = "   variables contributing with its local bound such that the"]
#[doc = "   constraint is not globally redundant"]
pub const SCIP_ConflictPresolStrat_SCIP_CONFPRES_BOTH: SCIP_ConflictPresolStrat = 3;
#[doc = " dualray presolving strategy"]
pub type SCIP_ConflictPresolStrat = ::std::os::raw::c_int;
pub use self::SCIP_ConflictPresolStrat as SCIP_CONFPRES;
#[doc = "< solution describes original variables; non-cached elements are zero"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_ORIGINAL: SCIP_SolOrigin = 0;
#[doc = "< all non-cached elements in solution are equal to zero"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_ZERO: SCIP_SolOrigin = 1;
#[doc = "< all non-cached elements in solution are equal to current LP solution"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_LPSOL: SCIP_SolOrigin = 2;
#[doc = "< all non-cached elements in solution are equal to current NLP solution"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_NLPSOL: SCIP_SolOrigin = 3;
#[doc = "< all non-cached elements in solution are equal to current relaxation solution"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_RELAXSOL: SCIP_SolOrigin = 4;
#[doc = "< all non-cached elements in solution are equal to current pseudo solution"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_PSEUDOSOL: SCIP_SolOrigin = 5;
#[doc = "< solution describes original solution; all non-cached elements in solution"]
#[doc = "   are treated as being an arbitrary value in the variable's bounds"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_PARTIAL: SCIP_SolOrigin = 6;
#[doc = "< all non-cached elements in solution are unknown; they have to be treated"]
#[doc = "   as being an arbitrary value in the variable's bounds"]
pub const SCIP_SolOrigin_SCIP_SOLORIGIN_UNKNOWN: SCIP_SolOrigin = 7;
#[doc = " origin of solution: where to retrieve uncached elements"]
pub type SCIP_SolOrigin = ::std::os::raw::c_int;
pub use self::SCIP_SolOrigin as SCIP_SOLORIGIN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Sol {
    _unused: [u8; 0],
}
pub type SCIP_SOL = SCIP_Sol;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Viol {
    _unused: [u8; 0],
}
pub type SCIP_VIOL = SCIP_Viol;
#[doc = "< type of solution unspecified (the default)"]
pub const SCIP_SolType_SCIP_SOLTYPE_UNKNOWN: SCIP_SolType = 0;
#[doc = "< solution was found by a heuristic"]
pub const SCIP_SolType_SCIP_SOLTYPE_HEUR: SCIP_SolType = 1;
#[doc = "< solution was found by a relaxation"]
pub const SCIP_SolType_SCIP_SOLTYPE_RELAX: SCIP_SolType = 2;
#[doc = "< solution was found by the LP relaxation"]
pub const SCIP_SolType_SCIP_SOLTYPE_LPRELAX: SCIP_SolType = 3;
#[doc = "< solution was found during strong branching"]
pub const SCIP_SolType_SCIP_SOLTYPE_STRONGBRANCH: SCIP_SolType = 4;
#[doc = "< solution originates from a pseudo solution"]
pub const SCIP_SolType_SCIP_SOLTYPE_PSEUDO: SCIP_SolType = 5;
#[doc = " type of solution: heuristic or (LP) relaxation solution, or unspecified origin"]
pub type SCIP_SolType = ::std::os::raw::c_int;
pub use self::SCIP_SolType as SCIP_SOLTYPE;
pub type SCIP_DIVETYPE = ::std::os::raw::c_uint;
#[doc = "< all contexts combined"]
pub const SCIP_DiveContext_SCIP_DIVECONTEXT_TOTAL: SCIP_DiveContext = 0;
#[doc = "< single heuristic context"]
pub const SCIP_DiveContext_SCIP_DIVECONTEXT_SINGLE: SCIP_DiveContext = 1;
#[doc = "< within adaptive diving"]
pub const SCIP_DiveContext_SCIP_DIVECONTEXT_ADAPTIVE: SCIP_DiveContext = 2;
#[doc = " context for diving statistics"]
pub type SCIP_DiveContext = ::std::os::raw::c_int;
pub use self::SCIP_DiveContext as SCIP_DIVECONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Heur {
    _unused: [u8; 0],
}
pub type SCIP_HEUR = SCIP_Heur;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_HeurData {
    _unused: [u8; 0],
}
pub type SCIP_HEURDATA = SCIP_HeurData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Diveset {
    _unused: [u8; 0],
}
pub type SCIP_DIVESET = SCIP_Diveset;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_VGraph {
    _unused: [u8; 0],
}
pub type SCIP_VGRAPH = SCIP_VGraph;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Conshdlr {
    _unused: [u8; 0],
}
pub type SCIP_CONSHDLR = SCIP_Conshdlr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Cons {
    _unused: [u8; 0],
}
pub type SCIP_CONS = SCIP_Cons;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConshdlrData {
    _unused: [u8; 0],
}
pub type SCIP_CONSHDLRDATA = SCIP_ConshdlrData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConsData {
    _unused: [u8; 0],
}
pub type SCIP_CONSDATA = SCIP_ConsData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConsSetChg {
    _unused: [u8; 0],
}
pub type SCIP_CONSSETCHG = SCIP_ConsSetChg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LinConsStats {
    _unused: [u8; 0],
}
pub type SCIP_LINCONSSTATS = SCIP_LinConsStats;
#[doc = "< linear constraints with no variables"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_EMPTY: SCIP_LinConstype = 0;
#[doc = "< linear constraints with no finite side"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_FREE: SCIP_LinConstype = 1;
#[doc = "< linear constraints with a single variable"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_SINGLETON: SCIP_LinConstype = 2;
#[doc = "< linear constraints of the type \\f$ ax + by = c\\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_AGGREGATION: SCIP_LinConstype = 3;
#[doc = "< linear constraints of the type \\f$ a x - a y \\leq b\\f$ where \\f$x\\f$ and \\f$y\\f$ must have the same type"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_PRECEDENCE: SCIP_LinConstype = 4;
#[doc = "< linear constraints of the form \\f$ ax + by \\leq c \\, x \\in \\{0,1\\} \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_VARBOUND: SCIP_LinConstype = 5;
#[doc = "< linear constraints of the form \\f$ \\sum x_i = 1\\, x_i \\in \\{0,1\\} \\forall i \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_SETPARTITION: SCIP_LinConstype = 6;
#[doc = "< linear constraints of the form \\f$ \\sum x_i \\leq 1\\, x_i \\in \\{0,1\\} \\forall i \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_SETPACKING: SCIP_LinConstype = 7;
#[doc = "< linear constraints of the form \\f$ \\sum x_i \\geq 1\\, x_i \\in \\{0,1\\} \\forall i \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_SETCOVERING: SCIP_LinConstype = 8;
#[doc = "< linear constraints of the form \\f$ \\sum x_i = k\\, x_i \\in \\{0,1\\} \\forall i, \\, k\\geq 2 \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_CARDINALITY: SCIP_LinConstype = 9;
#[doc = "< linear constraints of the form \\f$ \\sum x_i \\leq b\\, x_i \\in \\{0,1\\} \\forall i, \\, b\\in \\mathbb{n} \\geq 2 \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_INVKNAPSACK: SCIP_LinConstype = 10;
#[doc = "< linear constraints of the form \\f$ \\sum a_i x_i = b\\, x_i \\in \\{0,1\\} \\forall i, \\, b\\in \\mathbb{n} \\geq 2 \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_EQKNAPSACK: SCIP_LinConstype = 11;
#[doc = "< linear constraints of the form \\f$ \\sum a_i x_i + a x \\leq a\\, x, x_i \\in \\{0,1\\} \\forall i, \\, a\\in \\mathbb{n} \\geq 2 \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_BINPACKING: SCIP_LinConstype = 12;
#[doc = "< linear constraints of the form \\f$ \\sum a_k x_k \\leq b\\, x_i \\in \\{0,1\\} \\forall i, \\, b\\in \\mathbb{n} \\geq 2 \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_KNAPSACK: SCIP_LinConstype = 13;
#[doc = "< linear constraints of the form \\f$ \\sum a_k x_k \\leq b\\, x_i \\in \\mathbb{Z} \\forall i, \\, b\\in \\mathbb{n} \\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_INTKNAPSACK: SCIP_LinConstype = 14;
#[doc = "< linear constraints of the form \\f$ \\sum a_k x_k + \\sum p_j s_j \\leq/= b\\, x_i \\in \\{0,1\\} \\forall i, s_j \\in \\text{ cont. } \\forall j\\f$"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_MIXEDBINARY: SCIP_LinConstype = 15;
#[doc = "< general linear constraints with no special structure"]
pub const SCIP_LinConstype_SCIP_LINCONSTYPE_GENERAL: SCIP_LinConstype = 16;
#[doc = " linear constraint types recognizable"]
pub type SCIP_LinConstype = ::std::os::raw::c_int;
pub use self::SCIP_LinConstype as SCIP_LINCONSTYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Dialog {
    _unused: [u8; 0],
}
pub type SCIP_DIALOG = SCIP_Dialog;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DialogData {
    _unused: [u8; 0],
}
pub type SCIP_DIALOGDATA = SCIP_DialogData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Dialoghdlr {
    _unused: [u8; 0],
}
pub type SCIP_DIALOGHDLR = SCIP_Dialoghdlr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Linelist {
    _unused: [u8; 0],
}
pub type SCIP_LINELIST = SCIP_Linelist;
#[doc = "< display column is not displayed"]
pub const SCIP_DispStatus_SCIP_DISPSTATUS_OFF: SCIP_DispStatus = 0;
#[doc = "< display column is switched on and off automatically"]
pub const SCIP_DispStatus_SCIP_DISPSTATUS_AUTO: SCIP_DispStatus = 1;
#[doc = "< display column is displayed"]
pub const SCIP_DispStatus_SCIP_DISPSTATUS_ON: SCIP_DispStatus = 2;
#[doc = " display activation status of display column"]
pub type SCIP_DispStatus = ::std::os::raw::c_int;
pub use self::SCIP_DispStatus as SCIP_DISPSTATUS;
#[doc = "< display column is displayed only in sequential mode"]
pub const SCIP_DispMode_SCIP_DISPMODE_DEFAULT: SCIP_DispMode = 1;
#[doc = "< display column is displayed only in concurrent mode"]
pub const SCIP_DispMode_SCIP_DISPMODE_CONCURRENT: SCIP_DispMode = 2;
#[doc = "< display column is displayed in concurrent and sequential mode"]
pub const SCIP_DispMode_SCIP_DISPMODE_ALL: SCIP_DispMode = 3;
#[doc = " display activation status of display column"]
pub type SCIP_DispMode = ::std::os::raw::c_int;
pub use self::SCIP_DispMode as SCIP_DISPMODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Disp {
    _unused: [u8; 0],
}
pub type SCIP_DISP = SCIP_Disp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DispData {
    _unused: [u8; 0],
}
pub type SCIP_DISPDATA = SCIP_DispData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Compr {
    _unused: [u8; 0],
}
pub type SCIP_COMPR = SCIP_Compr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ComprData {
    _unused: [u8; 0],
}
pub type SCIP_COMPRDATA = SCIP_ComprData;
#[doc = "< downwards branching: decreasing upper bound"]
pub const SCIP_BranchDir_SCIP_BRANCHDIR_DOWNWARDS: SCIP_BranchDir = 0;
#[doc = "< upwards branching: increasing lower bound"]
pub const SCIP_BranchDir_SCIP_BRANCHDIR_UPWARDS: SCIP_BranchDir = 1;
#[doc = "< fixed branching: both bounds changed"]
pub const SCIP_BranchDir_SCIP_BRANCHDIR_FIXED: SCIP_BranchDir = 2;
#[doc = "< automatic setting for choosing bound changes"]
pub const SCIP_BranchDir_SCIP_BRANCHDIR_AUTO: SCIP_BranchDir = 3;
#[doc = " branching direction for branching on variables"]
pub type SCIP_BranchDir = ::std::os::raw::c_int;
pub use self::SCIP_BranchDir as SCIP_BRANCHDIR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_History {
    _unused: [u8; 0],
}
pub type SCIP_HISTORY = SCIP_History;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ValueHistory {
    _unused: [u8; 0],
}
#[doc = " Value history data structure"]
#[doc = ""]
#[doc = "  branching and inference history informations for single variable dependent on the domain value"]
#[doc = ""]
#[doc = "  - \\ref SCIP_VALUEHISTORY \"List of all available methods\""]
pub type SCIP_VALUEHISTORY = SCIP_ValueHistory;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NodePQ {
    _unused: [u8; 0],
}
pub type SCIP_NODEPQ = SCIP_NodePQ;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Nodesel {
    _unused: [u8; 0],
}
pub type SCIP_NODESEL = SCIP_Nodesel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NodeselData {
    _unused: [u8; 0],
}
pub type SCIP_NODESELDATA = SCIP_NodeselData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Presol {
    _unused: [u8; 0],
}
pub type SCIP_PRESOL = SCIP_Presol;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_PresolData {
    _unused: [u8; 0],
}
pub type SCIP_PRESOLDATA = SCIP_PresolData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Pricer {
    _unused: [u8; 0],
}
pub type SCIP_PRICER = SCIP_Pricer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_PricerData {
    _unused: [u8; 0],
}
pub type SCIP_PRICERDATA = SCIP_PricerData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Reader {
    _unused: [u8; 0],
}
pub type SCIP_READER = SCIP_Reader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ReaderData {
    _unused: [u8; 0],
}
pub type SCIP_READERDATA = SCIP_ReaderData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Relax {
    _unused: [u8; 0],
}
pub type SCIP_RELAX = SCIP_Relax;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Relaxation {
    _unused: [u8; 0],
}
pub type SCIP_RELAXATION = SCIP_Relaxation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_RelaxData {
    _unused: [u8; 0],
}
pub type SCIP_RELAXDATA = SCIP_RelaxData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Reopt {
    _unused: [u8; 0],
}
pub type SCIP_REOPT = SCIP_Reopt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SolTree {
    _unused: [u8; 0],
}
pub type SCIP_SOLTREE = SCIP_SolTree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SolNode {
    _unused: [u8; 0],
}
pub type SCIP_SOLNODE = SCIP_SolNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ReoptTree {
    _unused: [u8; 0],
}
pub type SCIP_REOPTTREE = SCIP_ReoptTree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ReoptNode {
    _unused: [u8; 0],
}
pub type SCIP_REOPTNODE = SCIP_ReoptNode;
pub type SCIP_REPRESENTATIVE = SCIP_ReoptNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ReoptConsData {
    _unused: [u8; 0],
}
pub type SCIP_REOPTCONSDATA = SCIP_ReoptConsData;
#[doc = "< node is not part of the reoptimizationtree"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_NONE: SCIP_ReoptType = 0;
#[doc = "< node is only needed for reconstructing the tree"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_TRANSIT: SCIP_ReoptType = 1;
#[doc = "< node contains dual reductions which leed to LP infeasibility"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_INFSUBTREE: SCIP_ReoptType = 2;
#[doc = "< node contains dual reductions"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_STRBRANCHED: SCIP_ReoptType = 3;
#[doc = "< node contains additional constraints"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_LOGICORNODE: SCIP_ReoptType = 4;
#[doc = "< node is a leaf node"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_LEAF: SCIP_ReoptType = 5;
#[doc = "< node is a leaf node and pruned by boudning"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_PRUNED: SCIP_ReoptType = 6;
#[doc = "< node is a leaf node and has an integral optimal LP solution"]
pub const SCIP_ReoptType_SCIP_REOPTTYPE_FEASIBLE: SCIP_ReoptType = 7;
pub type SCIP_ReoptType = ::std::os::raw::c_int;
pub use self::SCIP_ReoptType as SCIP_REOPTTYPE;
#[doc = "< constraint cutoffs an LP infeasible subtree"]
pub const Reopt_ConsType_REOPT_CONSTYPE_INFSUBTREE: Reopt_ConsType = 0;
#[doc = "< constraint reconstructs dual reductions"]
pub const Reopt_ConsType_REOPT_CONSTYPE_DUALREDS: Reopt_ConsType = 1;
#[doc = "< constraint representing a cut, e.g., to separate a solution"]
pub const Reopt_ConsType_REOPT_CONSTYPE_CUT: Reopt_ConsType = 2;
#[doc = "< constraint was added by SCIP, e.g., a (local) conflict"]
pub const Reopt_ConsType_REOPT_CONSTYPE_UNKNOWN: Reopt_ConsType = 3;
pub type Reopt_ConsType = ::std::os::raw::c_int;
pub use self::Reopt_ConsType as REOPT_CONSTYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Sepa {
    _unused: [u8; 0],
}
pub type SCIP_SEPA = SCIP_Sepa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SepaData {
    _unused: [u8; 0],
}
pub type SCIP_SEPADATA = SCIP_SepaData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Table {
    _unused: [u8; 0],
}
pub type SCIP_TABLE = SCIP_Table;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_TableData {
    _unused: [u8; 0],
}
pub type SCIP_TABLEDATA = SCIP_TableData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Prop {
    _unused: [u8; 0],
}
pub type SCIP_PROP = SCIP_Prop;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_PropData {
    _unused: [u8; 0],
}
pub type SCIP_PROPDATA = SCIP_PropData;
#[doc = "< variable given by index (stored in data.idx)"]
pub const SCIP_ExprOp_SCIP_EXPR_VARIDX: SCIP_ExprOp = 1;
#[doc = "< constant (value stored in data.dbl)"]
pub const SCIP_ExprOp_SCIP_EXPR_CONST: SCIP_ExprOp = 2;
#[doc = "< parameter = a constant that can be modified (should not be simplified away)"]
pub const SCIP_ExprOp_SCIP_EXPR_PARAM: SCIP_ExprOp = 3;
#[doc = "< addition (2 operands)"]
pub const SCIP_ExprOp_SCIP_EXPR_PLUS: SCIP_ExprOp = 8;
#[doc = "< substraction (2 operands)"]
pub const SCIP_ExprOp_SCIP_EXPR_MINUS: SCIP_ExprOp = 9;
#[doc = "< multiplication (2 operands)"]
pub const SCIP_ExprOp_SCIP_EXPR_MUL: SCIP_ExprOp = 10;
#[doc = "< division (2 operands)"]
pub const SCIP_ExprOp_SCIP_EXPR_DIV: SCIP_ExprOp = 11;
#[doc = "< square (1 operand)"]
pub const SCIP_ExprOp_SCIP_EXPR_SQUARE: SCIP_ExprOp = 12;
#[doc = "< square root (1 operand)"]
pub const SCIP_ExprOp_SCIP_EXPR_SQRT: SCIP_ExprOp = 13;
#[doc = "< power with real exponent (1 operand!, assumed to be nonnegative, exponent is stored in expression data)"]
pub const SCIP_ExprOp_SCIP_EXPR_REALPOWER: SCIP_ExprOp = 14;
#[doc = "< power with integer exponent (1 operand!, exponent stored in expression data)"]
pub const SCIP_ExprOp_SCIP_EXPR_INTPOWER: SCIP_ExprOp = 15;
#[doc = "< signed power (sign(x)|x|^a, 1 operand!, exponent is stored in expression data)"]
pub const SCIP_ExprOp_SCIP_EXPR_SIGNPOWER: SCIP_ExprOp = 16;
#[doc = "< exponential (e^x, 1 operand)"]
pub const SCIP_ExprOp_SCIP_EXPR_EXP: SCIP_ExprOp = 17;
#[doc = "< natural logarithm (ln(x), 1 operand)"]
pub const SCIP_ExprOp_SCIP_EXPR_LOG: SCIP_ExprOp = 18;
#[doc = "< sinus (1 operand)"]
pub const SCIP_ExprOp_SCIP_EXPR_SIN: SCIP_ExprOp = 19;
#[doc = "< cosinus (1 operand)"]
pub const SCIP_ExprOp_SCIP_EXPR_COS: SCIP_ExprOp = 20;
#[doc = "< tangent (1 operand)"]
pub const SCIP_ExprOp_SCIP_EXPR_TAN: SCIP_ExprOp = 21;
#[doc = "< minimum (2 operands)"]
pub const SCIP_ExprOp_SCIP_EXPR_MIN: SCIP_ExprOp = 24;
#[doc = "< maximum (2 operands)"]
pub const SCIP_ExprOp_SCIP_EXPR_MAX: SCIP_ExprOp = 25;
#[doc = "< absolute value (1 operand)"]
pub const SCIP_ExprOp_SCIP_EXPR_ABS: SCIP_ExprOp = 26;
#[doc = "< sign of value (1 operand)"]
pub const SCIP_ExprOp_SCIP_EXPR_SIGN: SCIP_ExprOp = 27;
#[doc = "< summation sum_{i=1}^n op_i (n operands)"]
pub const SCIP_ExprOp_SCIP_EXPR_SUM: SCIP_ExprOp = 64;
#[doc = "< product prod_{i=1}^n op_i (n operands)"]
pub const SCIP_ExprOp_SCIP_EXPR_PRODUCT: SCIP_ExprOp = 65;
#[doc = "< linear term sum_{i=1}^n a_i op_i (n operands)"]
pub const SCIP_ExprOp_SCIP_EXPR_LINEAR: SCIP_ExprOp = 66;
#[doc = "< quadratic term sum_{i,j=1}^n a_{i,j} op_i op_j (n operands)"]
pub const SCIP_ExprOp_SCIP_EXPR_QUADRATIC: SCIP_ExprOp = 67;
#[doc = "< polynomial term sum_{I} a_{I}ops^I (I a multiindex, n operands)"]
pub const SCIP_ExprOp_SCIP_EXPR_POLYNOMIAL: SCIP_ExprOp = 68;
#[doc = "< a user defined expression"]
pub const SCIP_ExprOp_SCIP_EXPR_USER: SCIP_ExprOp = 69;
#[doc = "< no expression, used for counting reasons"]
pub const SCIP_ExprOp_SCIP_EXPR_LAST: SCIP_ExprOp = 70;
#[doc = " Operators of expressions."]
pub type SCIP_ExprOp = ::std::os::raw::c_int;
#[doc = "< unknown curvature (or indefinite)"]
pub const SCIP_ExprCurv_SCIP_EXPRCURV_UNKNOWN: SCIP_ExprCurv = 0;
#[doc = "< convex"]
pub const SCIP_ExprCurv_SCIP_EXPRCURV_CONVEX: SCIP_ExprCurv = 1;
#[doc = "< concave"]
pub const SCIP_ExprCurv_SCIP_EXPRCURV_CONCAVE: SCIP_ExprCurv = 2;
#[doc = "< linear = convex and concave"]
pub const SCIP_ExprCurv_SCIP_EXPRCURV_LINEAR: SCIP_ExprCurv = 3;
#[doc = " Curvature types"]
pub type SCIP_ExprCurv = ::std::os::raw::c_int;
pub use self::SCIP_ExprOp as SCIP_EXPROP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SCIP_ExprOpData {
    _unused: [u8; 0],
}
pub type SCIP_EXPROPDATA = SCIP_ExprOpData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Expr {
    _unused: [u8; 0],
}
pub type SCIP_EXPR = SCIP_Expr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ExprTree {
    _unused: [u8; 0],
}
pub type SCIP_EXPRTREE = SCIP_ExprTree;
pub use self::SCIP_ExprCurv as SCIP_EXPRCURV;
#[doc = " An element of a quadratic term: two variable indices and a coefficient."]
#[doc = " The convention is to have idx1 <= idx2."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_QuadElement {
    #[doc = "< index of first variable"]
    pub idx1: ::std::os::raw::c_int,
    #[doc = "< index of second variable"]
    pub idx2: ::std::os::raw::c_int,
    #[doc = "< value of coefficient at position (idx1, idx2)"]
    pub coef: f64,
}
#[test]
fn bindgen_test_layout_SCIP_QuadElement() {
    assert_eq!(
        ::std::mem::size_of::<SCIP_QuadElement>(),
        16usize,
        concat!("Size of: ", stringify!(SCIP_QuadElement))
    );
    assert_eq!(
        ::std::mem::align_of::<SCIP_QuadElement>(),
        8usize,
        concat!("Alignment of ", stringify!(SCIP_QuadElement))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCIP_QuadElement>())).idx1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_QuadElement),
            "::",
            stringify!(idx1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCIP_QuadElement>())).idx2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_QuadElement),
            "::",
            stringify!(idx2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCIP_QuadElement>())).coef as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_QuadElement),
            "::",
            stringify!(coef)
        )
    );
}
pub type SCIP_QUADELEM = SCIP_QuadElement;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ExprData_Quadratic {
    _unused: [u8; 0],
}
pub type SCIP_EXPRDATA_QUADRATIC = SCIP_ExprData_Quadratic;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ExprData_Monomial {
    _unused: [u8; 0],
}
pub type SCIP_EXPRDATA_MONOMIAL = SCIP_ExprData_Monomial;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ExprData_Polynomial {
    _unused: [u8; 0],
}
pub type SCIP_EXPRDATA_POLYNOMIAL = SCIP_ExprData_Polynomial;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ExprData_User {
    _unused: [u8; 0],
}
pub type SCIP_EXPRDATA_USER = SCIP_ExprData_User;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ExprGraphNode {
    _unused: [u8; 0],
}
pub type SCIP_EXPRGRAPHNODE = SCIP_ExprGraphNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ExprGraph {
    _unused: [u8; 0],
}
pub type SCIP_EXPRGRAPH = SCIP_ExprGraph;
pub type SCIP_EXPRBOUNDSTATUS = ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_UserExprData {
    _unused: [u8; 0],
}
pub type SCIP_USEREXPRDATA = SCIP_UserExprData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Nlpi {
    _unused: [u8; 0],
}
pub type SCIP_NLPI = SCIP_Nlpi;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NlpiData {
    _unused: [u8; 0],
}
pub type SCIP_NLPIDATA = SCIP_NlpiData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NlpiProblem {
    _unused: [u8; 0],
}
pub type SCIP_NLPIPROBLEM = SCIP_NlpiProblem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_NlpStatistics {
    _unused: [u8; 0],
}
pub type SCIP_NLPSTATISTICS = SCIP_NlpStatistics;
#[doc = "< solver should start from scratch at next call?: 0 no, 1 yes (int)"]
pub const SCIP_NlpParam_SCIP_NLPPAR_FROMSCRATCH: SCIP_NlpParam = 0;
#[doc = "< verbosity level of output of NLP solver to the screen: 0 off, 1 normal, 2 debug, > 2 more debug (int)"]
pub const SCIP_NlpParam_SCIP_NLPPAR_VERBLEVEL: SCIP_NlpParam = 1;
#[doc = "< feasibility tolerance for primal variables and slacks (real)"]
pub const SCIP_NlpParam_SCIP_NLPPAR_FEASTOL: SCIP_NlpParam = 2;
#[doc = "< relative objective tolerance (real)"]
pub const SCIP_NlpParam_SCIP_NLPPAR_RELOBJTOL: SCIP_NlpParam = 3;
#[doc = "< lower objective limit (cutoff) (real)"]
pub const SCIP_NlpParam_SCIP_NLPPAR_LOBJLIM: SCIP_NlpParam = 4;
#[doc = "< value for infinity used to decide unbounded sides, unbounded variable and constraint bounds, and upper objective limit (real)"]
pub const SCIP_NlpParam_SCIP_NLPPAR_INFINITY: SCIP_NlpParam = 5;
#[doc = "< NLP iteration limit (int)"]
pub const SCIP_NlpParam_SCIP_NLPPAR_ITLIM: SCIP_NlpParam = 6;
#[doc = "< NLP time limit (real)"]
pub const SCIP_NlpParam_SCIP_NLPPAR_TILIM: SCIP_NlpParam = 7;
#[doc = "< name of a solver specific option file (string)"]
pub const SCIP_NlpParam_SCIP_NLPPAR_OPTFILE: SCIP_NlpParam = 8;
#[doc = "< should the NLP solver stop early if convergence is slow?: 0 no, 1 yes (int)"]
pub const SCIP_NlpParam_SCIP_NLPPAR_FASTFAIL: SCIP_NlpParam = 9;
#[doc = " NLP solver parameter"]
pub type SCIP_NlpParam = ::std::os::raw::c_int;
pub use self::SCIP_NlpParam as SCIP_NLPPARAM;
#[doc = "< solved to global optimality"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_GLOBOPT: SCIP_NlpSolStat = 0;
#[doc = "< solved to local optimality"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_LOCOPT: SCIP_NlpSolStat = 1;
#[doc = "< feasible solution found"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_FEASIBLE: SCIP_NlpSolStat = 2;
#[doc = "< solution found is local infeasible"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_LOCINFEASIBLE: SCIP_NlpSolStat = 3;
#[doc = "< problem is proven infeasible"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_GLOBINFEASIBLE: SCIP_NlpSolStat = 4;
#[doc = "< problem is unbounded"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_UNBOUNDED: SCIP_NlpSolStat = 5;
#[doc = "< unknown solution status (e.g., problem not solved yet)"]
pub const SCIP_NlpSolStat_SCIP_NLPSOLSTAT_UNKNOWN: SCIP_NlpSolStat = 6;
#[doc = " NLP solution status"]
pub type SCIP_NlpSolStat = ::std::os::raw::c_int;
pub use self::SCIP_NlpSolStat as SCIP_NLPSOLSTAT;
#[doc = "< terminated successfully"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_OKAY: SCIP_NlpTermStat = 0;
#[doc = "< time limit exceeded"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_TILIM: SCIP_NlpTermStat = 1;
#[doc = "< iteration limit exceeded"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_ITLIM: SCIP_NlpTermStat = 2;
#[doc = "< lower objective limit reached"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_LOBJLIM: SCIP_NlpTermStat = 3;
#[doc = "< stopped on numerical error"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_NUMERR: SCIP_NlpTermStat = 5;
#[doc = "< stopped on function evaluation error"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_EVALERR: SCIP_NlpTermStat = 6;
#[doc = "< memory exceeded"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_MEMERR: SCIP_NlpTermStat = 7;
#[doc = "< licence error"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_LICERR: SCIP_NlpTermStat = 8;
#[doc = "< other error (= this should never happen)"]
pub const SCIP_NlpTermStat_SCIP_NLPTERMSTAT_OTHER: SCIP_NlpTermStat = 9;
#[doc = " NLP solver termination status"]
pub type SCIP_NlpTermStat = ::std::os::raw::c_int;
pub use self::SCIP_NlpTermStat as SCIP_NLPTERMSTAT;
#[doc = "< the solving status is not yet known"]
pub const SCIP_Status_SCIP_STATUS_UNKNOWN: SCIP_Status = 0;
#[doc = "< the user interrupted the solving process (by pressing CTRL-C)"]
pub const SCIP_Status_SCIP_STATUS_USERINTERRUPT: SCIP_Status = 1;
#[doc = "< the solving process was interrupted because the node limit was reached"]
pub const SCIP_Status_SCIP_STATUS_NODELIMIT: SCIP_Status = 2;
#[doc = "< the solving process was interrupted because the total node limit was"]
#[doc = "   reached (incl. restarts)"]
pub const SCIP_Status_SCIP_STATUS_TOTALNODELIMIT: SCIP_Status = 3;
#[doc = "< the solving process was interrupted because the stalling node limit was"]
#[doc = "   reached (no inprovement w.r.t. primal bound)"]
pub const SCIP_Status_SCIP_STATUS_STALLNODELIMIT: SCIP_Status = 4;
#[doc = "< the solving process was interrupted because the time limit was reached"]
pub const SCIP_Status_SCIP_STATUS_TIMELIMIT: SCIP_Status = 5;
#[doc = "< the solving process was interrupted because the memory limit was reached"]
pub const SCIP_Status_SCIP_STATUS_MEMLIMIT: SCIP_Status = 6;
#[doc = "< the solving process was interrupted because the gap limit was reached"]
pub const SCIP_Status_SCIP_STATUS_GAPLIMIT: SCIP_Status = 7;
#[doc = "< the solving process was interrupted because the solution limit was"]
#[doc = "  reached"]
pub const SCIP_Status_SCIP_STATUS_SOLLIMIT: SCIP_Status = 8;
#[doc = "< the solving process was interrupted because the solution improvement limit"]
#[doc = "   was reached"]
pub const SCIP_Status_SCIP_STATUS_BESTSOLLIMIT: SCIP_Status = 9;
#[doc = "< the solving process was interrupted because the restart limit was reached"]
pub const SCIP_Status_SCIP_STATUS_RESTARTLIMIT: SCIP_Status = 10;
#[doc = "< the problem was solved to optimality, an optimal solution is available"]
pub const SCIP_Status_SCIP_STATUS_OPTIMAL: SCIP_Status = 11;
#[doc = "< the problem was proven to be infeasible"]
pub const SCIP_Status_SCIP_STATUS_INFEASIBLE: SCIP_Status = 12;
#[doc = "< the problem was proven to be unbounded"]
pub const SCIP_Status_SCIP_STATUS_UNBOUNDED: SCIP_Status = 13;
#[doc = "< the problem was proven to be either infeasible or unbounded"]
pub const SCIP_Status_SCIP_STATUS_INFORUNBD: SCIP_Status = 14;
#[doc = "< status if the process received a SIGTERM signal"]
pub const SCIP_Status_SCIP_STATUS_TERMINATE: SCIP_Status = 15;
#[doc = " SCIP solving status"]
pub type SCIP_Status = ::std::os::raw::c_int;
pub use self::SCIP_Status as SCIP_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Stat {
    _unused: [u8; 0],
}
pub type SCIP_STAT = SCIP_Stat;
pub const SCIP_Parallelmode_SCIP_PARA_OPPORTUNISTIC: SCIP_Parallelmode = 0;
pub const SCIP_Parallelmode_SCIP_PARA_DETERMINISTIC: SCIP_Parallelmode = 1;
#[doc = " The parallel mode"]
pub type SCIP_Parallelmode = ::std::os::raw::c_int;
pub use self::SCIP_Parallelmode as SCIP_PARALLELMODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SyncStore {
    _unused: [u8; 0],
}
pub type SCIP_SYNCSTORE = SCIP_SyncStore;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SyncData {
    _unused: [u8; 0],
}
pub type SCIP_SYNCDATA = SCIP_SyncData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BoundStore {
    _unused: [u8; 0],
}
pub type SCIP_BOUNDSTORE = SCIP_BoundStore;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConcSolverType {
    _unused: [u8; 0],
}
pub type SCIP_CONCSOLVERTYPE = SCIP_ConcSolverType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConcSolverTypeData {
    _unused: [u8; 0],
}
pub type SCIP_CONCSOLVERTYPEDATA = SCIP_ConcSolverTypeData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConcSolver {
    _unused: [u8; 0],
}
pub type SCIP_CONCSOLVER = SCIP_ConcSolver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ConcSolverData {
    _unused: [u8; 0],
}
pub type SCIP_CONCSOLVERDATA = SCIP_ConcSolverData;
#[doc = "< the Benders' subproblems are solved during the enforcement of an LP solution"]
pub const SCIP_BendersEnfoType_SCIP_BENDERSENFOTYPE_LP: SCIP_BendersEnfoType = 1;
#[doc = "< the Benders' subproblems are solved during the enforcement of a relaxation solution"]
pub const SCIP_BendersEnfoType_SCIP_BENDERSENFOTYPE_RELAX: SCIP_BendersEnfoType = 2;
#[doc = "< the Benders' subproblems are solved during the enforcement of a pseudo solution"]
pub const SCIP_BendersEnfoType_SCIP_BENDERSENFOTYPE_PSEUDO: SCIP_BendersEnfoType = 3;
#[doc = "< the Benders' subproblems are solved during the checking of a solution for feasibility"]
pub const SCIP_BendersEnfoType_SCIP_BENDERSENFOTYPE_CHECK: SCIP_BendersEnfoType = 4;
pub type SCIP_BendersEnfoType = ::std::os::raw::c_int;
pub use self::SCIP_BendersEnfoType as SCIP_BENDERSENFOTYPE;
#[doc = "< the relaxation is solved in this iteration of the loop"]
pub const SCIP_BendersSolveLoop_SCIP_BENDERSSOLVELOOP_CONVEX: SCIP_BendersSolveLoop = 0;
#[doc = "< the CIP is solved in this iteration of the loop"]
pub const SCIP_BendersSolveLoop_SCIP_BENDERSSOLVELOOP_CIP: SCIP_BendersSolveLoop = 1;
#[doc = "< the user defined solve function is called"]
pub const SCIP_BendersSolveLoop_SCIP_BENDERSSOLVELOOP_USERCONVEX: SCIP_BendersSolveLoop = 2;
#[doc = "< the user defined solve function is called"]
pub const SCIP_BendersSolveLoop_SCIP_BENDERSSOLVELOOP_USERCIP: SCIP_BendersSolveLoop = 3;
pub type SCIP_BendersSolveLoop = ::std::os::raw::c_int;
pub use self::SCIP_BendersSolveLoop as SCIP_BENDERSSOLVELOOP;
#[doc = "< the subsystem status is unknown"]
pub const SCIP_BendersSubStatus_SCIP_BENDERSSUBSTATUS_UNKNOWN: SCIP_BendersSubStatus = 0;
#[doc = "< the subsystem is solved to be optimal"]
pub const SCIP_BendersSubStatus_SCIP_BENDERSSUBSTATUS_OPTIMAL: SCIP_BendersSubStatus = 1;
#[doc = "< the subproblem is optimal, but the auxiliary variable is violated"]
pub const SCIP_BendersSubStatus_SCIP_BENDERSSUBSTATUS_AUXVIOL: SCIP_BendersSubStatus = 2;
#[doc = "< the subproblem is solved to be infeasible"]
pub const SCIP_BendersSubStatus_SCIP_BENDERSSUBSTATUS_INFEAS: SCIP_BendersSubStatus = 3;
pub type SCIP_BendersSubStatus = ::std::os::raw::c_int;
pub use self::SCIP_BendersSubStatus as SCIP_BENDERSSUBSTATUS;
#[doc = "< the subproblem has convex constraints and continuous variables"]
pub const SCIP_BendersSubType_SCIP_BENDERSSUBTYPE_CONVEXCONT: SCIP_BendersSubType = 0;
#[doc = "< the subproblem has convex constraints and discrete variables"]
pub const SCIP_BendersSubType_SCIP_BENDERSSUBTYPE_CONVEXDIS: SCIP_BendersSubType = 1;
#[doc = "< the subproblem has non-convex constraints and continuous variables"]
pub const SCIP_BendersSubType_SCIP_BENDERSSUBTYPE_NONCONVEXCONT: SCIP_BendersSubType = 2;
#[doc = "< the subproblem has non-convex constraints and discrete variables"]
pub const SCIP_BendersSubType_SCIP_BENDERSSUBTYPE_NONCONVEXDIS: SCIP_BendersSubType = 3;
#[doc = "< the default type before the type is known"]
pub const SCIP_BendersSubType_SCIP_BENDERSSUBTYPE_UNKNOWN: SCIP_BendersSubType = 4;
pub type SCIP_BendersSubType = ::std::os::raw::c_int;
pub use self::SCIP_BendersSubType as SCIP_BENDERSSUBTYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Benders {
    _unused: [u8; 0],
}
pub type SCIP_BENDERS = SCIP_Benders;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BendersData {
    _unused: [u8; 0],
}
pub type SCIP_BENDERSDATA = SCIP_BendersData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_SubproblemSolveStat {
    _unused: [u8; 0],
}
pub type SCIP_SUBPROBLEMSOLVESTAT = SCIP_SubproblemSolveStat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Benderscut {
    _unused: [u8; 0],
}
pub type SCIP_BENDERSCUT = SCIP_Benderscut;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_BenderscutData {
    _unused: [u8; 0],
}
pub type SCIP_BENDERSCUTDATA = SCIP_BenderscutData;
extern "C" {
    #[doc = " create and resets an epsilon greedy bandit algorithm"]
    pub fn SCIPcreateBanditEpsgreedy(
        scip: *mut SCIP,
        epsgreedy: *mut *mut SCIP_BANDIT,
        priorities: *mut f64,
        eps: f64,
        preferrecent: ::std::os::raw::c_uint,
        decayfactor: f64,
        avglim: ::std::os::raw::c_int,
        nactions: ::std::os::raw::c_int,
        initseed: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get weights array of epsilon greedy bandit algorithm"]
    pub fn SCIPgetWeightsEpsgreedy(epsgreedy: *mut SCIP_BANDIT) -> *mut f64;
}
extern "C" {
    #[doc = " set epsilon parameter of epsilon greedy bandit algorithm"]
    pub fn SCIPsetEpsilonEpsgreedy(epsgreedy: *mut SCIP_BANDIT, eps: f64);
}
extern "C" {
    #[doc = " creates and resets an Exp.3 bandit algorithm using \\p scip pointer"]
    pub fn SCIPcreateBanditExp3(
        scip: *mut SCIP,
        exp3: *mut *mut SCIP_BANDIT,
        priorities: *mut f64,
        gammaparam: f64,
        beta: f64,
        nactions: ::std::os::raw::c_int,
        initseed: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set gamma parameter of Exp.3 bandit algorithm to increase weight of uniform distribution"]
    pub fn SCIPsetGammaExp3(exp3: *mut SCIP_BANDIT, gammaparam: f64);
}
extern "C" {
    #[doc = " set beta parameter of Exp.3 bandit algorithm to increase gain offset for actions that were not played"]
    pub fn SCIPsetBetaExp3(exp3: *mut SCIP_BANDIT, beta: f64);
}
extern "C" {
    #[doc = " returns probability to play an action"]
    pub fn SCIPgetProbabilityExp3(exp3: *mut SCIP_BANDIT, action: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " create and reset UCB bandit algorithm"]
    pub fn SCIPcreateBanditUcb(
        scip: *mut SCIP,
        ucb: *mut *mut SCIP_BANDIT,
        priorities: *mut f64,
        alpha: f64,
        nactions: ::std::os::raw::c_int,
        initseed: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the upper confidence bound of a selected action"]
    pub fn SCIPgetConfidenceBoundUcb(ucb: *mut SCIP_BANDIT, action: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " return start permutation of the UCB bandit algorithm"]
    pub fn SCIPgetStartPermutationUcb(ucb: *mut SCIP_BANDIT) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " select the next action"]
    pub fn SCIPbanditSelect(
        bandit: *mut SCIP_BANDIT,
        action: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " update the score of the selected action"]
    pub fn SCIPbanditUpdate(
        bandit: *mut SCIP_BANDIT,
        action: ::std::os::raw::c_int,
        score: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " return the name of this bandit virtual function table"]
    pub fn SCIPbanditvtableGetName(
        banditvtable: *mut SCIP_BANDITVTABLE,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " return the random number generator of a bandit algorithm"]
    pub fn SCIPbanditGetRandnumgen(bandit: *mut SCIP_BANDIT) -> *mut SCIP_RANDNUMGEN;
}
extern "C" {
    #[doc = " return number of actions of this bandit algorithm"]
    pub fn SCIPbanditGetNActions(bandit: *mut SCIP_BANDIT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPbendersComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPbendersCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of Benders' decomposition"]
    pub fn SCIPbendersGetData(benders: *mut SCIP_BENDERS) -> *mut SCIP_BENDERSDATA;
}
extern "C" {
    #[doc = " sets user data of Benders' decomposition; user has to free old data in advance!"]
    pub fn SCIPbendersSetData(benders: *mut SCIP_BENDERS, bendersdata: *mut SCIP_BENDERSDATA);
}
extern "C" {
    #[doc = " gets name of Benders' decomposition"]
    pub fn SCIPbendersGetName(benders: *mut SCIP_BENDERS) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of Benders' decomposition"]
    pub fn SCIPbendersGetDesc(benders: *mut SCIP_BENDERS) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of Benders' decomposition"]
    pub fn SCIPbendersGetPriority(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of subproblems for the Benders' decomposition"]
    pub fn SCIPbendersGetNSubproblems(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the SCIP instance for a given subproblem"]
    pub fn SCIPbendersSubproblem(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> *mut SCIP;
}
extern "C" {
    #[doc = " gets the number of times, the Bender' decomposition was called and tried to find a violated second stage constraint"]
    pub fn SCIPbendersGetNCalls(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of optimality cuts found by the collection of Benders' decomposition subproblems"]
    pub fn SCIPbendersGetNCutsFound(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of cuts found from the strengthening round"]
    pub fn SCIPbendersGetNStrengthenCutsFound(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of calls to the strengthening round"]
    pub fn SCIPbendersGetNStrengthenCalls(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of calls to the strengthening round that fail"]
    pub fn SCIPbendersGetNStrengthenFails(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets time in seconds used in this Benders' decomposition for setting up for next stages"]
    pub fn SCIPbendersGetSetupTime(benders: *mut SCIP_BENDERS) -> f64;
}
extern "C" {
    #[doc = " gets execution time in seconds used in this Benders' decomposition"]
    pub fn SCIPbendersGetTime(benders: *mut SCIP_BENDERS) -> f64;
}
extern "C" {
    #[doc = " Is Benders' decomposition initialized?"]
    pub fn SCIPbendersIsInitialized(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the given Benders' decomposition is in use in the current problem"]
    pub fn SCIPbendersIsActive(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns whether only the convex relaxations will be checked in this solve loop"]
    #[doc = "  when Benders' is used in the LNS heuristics, only the convex relaxations of the master/subproblems are checked,"]
    #[doc = "  i.e. no integer cuts are generated. In this case, then Benders' decomposition is performed under the assumption"]
    #[doc = "  that all subproblems are convex relaxations."]
    pub fn SCIPbendersOnlyCheckConvexRelax(
        benders: *mut SCIP_BENDERS,
        subscipsoff: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Are Benders' cuts generated from the LP solutions?"]
    pub fn SCIPbendersCutLP(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Are Benders' cuts generated from the pseudo solutions?"]
    pub fn SCIPbendersCutPseudo(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Are Benders' cuts generated from the relaxation solutions?"]
    pub fn SCIPbendersCutRelaxation(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Should this Benders' use the auxiliary variables from the highest priority Benders'?"]
    pub fn SCIPbendersShareAuxVars(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets the subproblem setup flag"]
    pub fn SCIPbendersSetSubproblemIsSetup(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        issetup: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns the subproblem setup flag"]
    pub fn SCIPbendersSubproblemIsSetup(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the auxiliary variable for the given subproblem"]
    pub fn SCIPbendersGetAuxiliaryVar(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " returns all auxiliary variables"]
    pub fn SCIPbendersGetAuxiliaryVars(benders: *mut SCIP_BENDERS) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " stores the objective function value of the subproblem for use in cut generation"]
    pub fn SCIPbendersSetSubproblemObjval(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        objval: f64,
    );
}
extern "C" {
    #[doc = " returns the objective function value of the subproblem for use in cut generation"]
    pub fn SCIPbendersGetSubproblemObjval(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the number of cuts that have been added for storage"]
    pub fn SCIPbendersGetNStoredCuts(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the data for the cuts that have been added by the Benders' cut plugin"]
    pub fn SCIPbendersGetStoredCutData(
        benders: *mut SCIP_BENDERS,
        cutidx: ::std::os::raw::c_int,
        vars: *mut *mut *mut SCIP_VAR,
        vals: *mut *mut f64,
        lhs: *mut f64,
        rhs: *mut f64,
        nvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the original problem data for the cuts that have been added by the Benders' cut plugin. The stored"]
    #[doc = "  variables and values will populate the input vars and vals arrays. Thus, memory must be allocated for the vars and"]
    #[doc = "  vals arrays"]
    pub fn SCIPbendersGetStoredCutOrigData(
        benders: *mut SCIP_BENDERS,
        cutidx: ::std::os::raw::c_int,
        vars: *mut *mut *mut SCIP_VAR,
        vals: *mut *mut f64,
        lhs: *mut f64,
        rhs: *mut f64,
        nvars: *mut ::std::os::raw::c_int,
        varssize: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the Benders' cut of the given name, or NULL if not existing"]
    pub fn SCIPfindBenderscut(
        benders: *mut SCIP_BENDERS,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_BENDERSCUT;
}
extern "C" {
    #[doc = " returns the array of currently available Benders' cuts; active Benders' decomposition are in the first slots of"]
    #[doc = " the array"]
    pub fn SCIPbendersGetBenderscuts(benders: *mut SCIP_BENDERS) -> *mut *mut SCIP_BENDERSCUT;
}
extern "C" {
    #[doc = " returns the number of currently available Benders' cuts"]
    pub fn SCIPbendersGetNBenderscuts(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a Benders' decomposition"]
    pub fn SCIPbendersSetBenderscutPriority(
        benders: *mut SCIP_BENDERS,
        benderscut: *mut SCIP_BENDERSCUT,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether the solution has non-zero slack variables"]
    pub fn SCIPbendersSolSlackVarsActive(
        benders: *mut SCIP_BENDERS,
        activeslack: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the subproblem type"]
    #[doc = ""]
    #[doc = " The subproblem types are:"]
    #[doc = "    - Convex constraints with continuous variables"]
    #[doc = "    - Convex constraints with discrete variables"]
    #[doc = "    - Non-convex constraints with continuous variables"]
    #[doc = "    - Non-convex constraints with discrete variables"]
    pub fn SCIPbendersSetSubproblemType(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        subprobtype: SCIP_BENDERSSUBTYPE,
    );
}
extern "C" {
    #[doc = " returns the type of the subproblem"]
    #[doc = ""]
    #[doc = "  This type is used to determine whether the duals of the problem can be used to generate cuts"]
    pub fn SCIPbendersGetSubproblemType(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> SCIP_BENDERSSUBTYPE;
}
extern "C" {
    #[doc = " sets the flag indicating whether a subproblem is convex"]
    #[doc = ""]
    #[doc = "  It is possible that this can change during the solving process. One example is when the three-phase method is"]
    #[doc = "  employed, where the first phase solves the convex relaxation of both the master and subproblems, the second phase"]
    #[doc = "  reintroduces the integrality constraints to the master problem and the third phase then reintroduces integrality"]
    #[doc = "  constraints to the subproblems."]
    pub fn SCIPbendersSetSubproblemIsConvex(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        isconvex: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns whether the subproblem is convex"]
    #[doc = ""]
    #[doc = "  This means that the dual solution can be used to generate cuts."]
    pub fn SCIPbendersSubproblemIsConvex(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the number of subproblems that are convex"]
    pub fn SCIPbendersGetNConvexSubproblems(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the flag indicating whether a subproblem contains non-linear constraints"]
    pub fn SCIPbendersSetSubproblemIsNonlinear(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        isnonlinear: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns whether the subproblem contains non-linear constraints."]
    pub fn SCIPbendersSubproblemIsNonlinear(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the number of subproblems that contain non-linear constraints"]
    pub fn SCIPbendersGetNNonlinearSubproblems(benders: *mut SCIP_BENDERS)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the flag indicating whether the master problem contains non-linear constraints"]
    pub fn SCIPbendersSetMasterIsNonlinear(
        benders: *mut SCIP_BENDERS,
        isnonlinear: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns whether the master problem contains non-linear constraints."]
    pub fn SCIPbendersMasterIsNonlinear(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the flag indicating that Benders' decomposition is in a cut strengthening round"]
    pub fn SCIPbendersInStrengthenRound(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " solves the LP of the Benders' decomposition subproblem"]
    #[doc = ""]
    #[doc = "  This requires that the subproblem is in probing mode."]
    pub fn SCIPbendersSolveSubproblemLP(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        solvestatus: *mut SCIP_STATUS,
        objective: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " solves the Benders' decomposition subproblem"]
    pub fn SCIPbendersSolveSubproblemCIP(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        solvestatus: *mut SCIP_STATUS,
        solvecip: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the number of cuts that have been transferred from sub SCIPs to the master SCIP"]
    pub fn SCIPbendersGetNTransferredCuts(benders: *mut SCIP_BENDERS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " updates the lower bound for the subproblem. If the lower bound is not greater than the previously stored lowerbound,"]
    #[doc = " then no update occurs."]
    pub fn SCIPbendersUpdateSubproblemLowerbound(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        lowerbound: f64,
    );
}
extern "C" {
    #[doc = " returns the stored lower bound for the given subproblem"]
    pub fn SCIPbendersGetSubproblemLowerbound(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " sets the independent subproblem flag"]
    pub fn SCIPbendersSetSubproblemIsIndependent(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        isindep: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns whether the subproblem is independent"]
    pub fn SCIPbendersSubproblemIsIndependent(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the subproblem is enabled, i.e. the subproblem is still solved in the solving loop."]
    pub fn SCIPbendersSubproblemIsEnabled(
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPbenderscutComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPbenderscutCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of the Benders' decomposition cut"]
    pub fn SCIPbenderscutGetData(benderscut: *mut SCIP_BENDERSCUT) -> *mut SCIP_BENDERSCUTDATA;
}
extern "C" {
    #[doc = " sets user data of the Benders' decomposition cut; user has to free old data in advance!"]
    pub fn SCIPbenderscutSetData(
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutdata: *mut SCIP_BENDERSCUTDATA,
    );
}
extern "C" {
    #[doc = " gets name of the Benders' decomposition cut"]
    pub fn SCIPbenderscutGetName(benderscut: *mut SCIP_BENDERSCUT)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of the Benders' decomposition cut"]
    pub fn SCIPbenderscutGetDesc(benderscut: *mut SCIP_BENDERSCUT)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of the Benders' decomposition cut"]
    pub fn SCIPbenderscutGetPriority(benderscut: *mut SCIP_BENDERSCUT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of times, the Benders' decomposition cut was called and tried to find a violated cut"]
    pub fn SCIPbenderscutGetNCalls(benderscut: *mut SCIP_BENDERSCUT) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the number of the cuts found by this Benders' decomposition cut"]
    pub fn SCIPbenderscutGetNFound(benderscut: *mut SCIP_BENDERSCUT) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " is the Benders' decomposition cut initialized?"]
    pub fn SCIPbenderscutIsInitialized(benderscut: *mut SCIP_BENDERSCUT) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets time in seconds used in this Benders' decomposition cut for setting up for next stages"]
    pub fn SCIPbenderscutGetSetupTime(benderscut: *mut SCIP_BENDERSCUT) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this Benders' decomposition cut"]
    pub fn SCIPbenderscutGetTime(benderscut: *mut SCIP_BENDERSCUT) -> f64;
}
extern "C" {
    #[doc = " returns whether the Benders' cut uses the LP information"]
    pub fn SCIPbenderscutIsLPCut(benderscut: *mut SCIP_BENDERSCUT) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets the enabled flag of the Benders' decomposition cut method"]
    pub fn SCIPbenderscutSetEnabled(
        benderscut: *mut SCIP_BENDERSCUT,
        enabled: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SCIPbranchruleComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPbranchruleCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of branching rule"]
    pub fn SCIPbranchruleGetData(branchrule: *mut SCIP_BRANCHRULE) -> *mut SCIP_BRANCHRULEDATA;
}
extern "C" {
    #[doc = " sets user data of branching rule; user has to free old data in advance!"]
    pub fn SCIPbranchruleSetData(
        branchrule: *mut SCIP_BRANCHRULE,
        branchruledata: *mut SCIP_BRANCHRULEDATA,
    );
}
extern "C" {
    #[doc = " gets name of branching rule"]
    pub fn SCIPbranchruleGetName(branchrule: *mut SCIP_BRANCHRULE)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of branching rule"]
    pub fn SCIPbranchruleGetDesc(branchrule: *mut SCIP_BRANCHRULE)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of branching rule"]
    pub fn SCIPbranchruleGetPriority(branchrule: *mut SCIP_BRANCHRULE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets maximal depth level, up to which this branching rule should be used (-1 for no limit)"]
    pub fn SCIPbranchruleGetMaxdepth(branchrule: *mut SCIP_BRANCHRULE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets maximal relative distance from current node's dual bound to primal bound for applying branching rule"]
    pub fn SCIPbranchruleGetMaxbounddist(branchrule: *mut SCIP_BRANCHRULE) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this branching rule for setting up for next stages"]
    pub fn SCIPbranchruleGetSetupTime(branchrule: *mut SCIP_BRANCHRULE) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this branching rule"]
    pub fn SCIPbranchruleGetTime(branchrule: *mut SCIP_BRANCHRULE) -> f64;
}
extern "C" {
    #[doc = " gets the total number of times, the branching rule was called on an LP solution"]
    pub fn SCIPbranchruleGetNLPCalls(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of times, the branching rule was called on external candidates"]
    pub fn SCIPbranchruleGetNExternCalls(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of times, the branching rule was called on a pseudo solution"]
    pub fn SCIPbranchruleGetNPseudoCalls(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of times, the branching rule detected a cutoff"]
    pub fn SCIPbranchruleGetNCutoffs(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of cuts, the branching rule separated"]
    pub fn SCIPbranchruleGetNCutsFound(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of constraints, the branching rule added to the respective local nodes (not counting constraints"]
    #[doc = "  that were added to the child nodes as branching decisions)"]
    pub fn SCIPbranchruleGetNConssFound(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of domain reductions, the branching rule found"]
    pub fn SCIPbranchruleGetNDomredsFound(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of children, the branching rule created"]
    pub fn SCIPbranchruleGetNChildren(
        branchrule: *mut SCIP_BRANCHRULE,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " is branching rule initialized?"]
    pub fn SCIPbranchruleIsInitialized(branchrule: *mut SCIP_BRANCHRULE) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPconflicthdlrComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPconflicthdlrCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of conflict handler"]
    pub fn SCIPconflicthdlrGetData(
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
    ) -> *mut SCIP_CONFLICTHDLRDATA;
}
extern "C" {
    #[doc = " sets user data of conflict handler; user has to free old data in advance!"]
    pub fn SCIPconflicthdlrSetData(
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflicthdlrdata: *mut SCIP_CONFLICTHDLRDATA,
    );
}
extern "C" {
    #[doc = " gets name of conflict handler"]
    pub fn SCIPconflicthdlrGetName(
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of conflict handler"]
    pub fn SCIPconflicthdlrGetDesc(
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of conflict handler"]
    pub fn SCIPconflicthdlrGetPriority(
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " is conflict handler initialized?"]
    pub fn SCIPconflicthdlrIsInitialized(
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets time in seconds used in this conflict handler for setting up for next stages"]
    pub fn SCIPconflicthdlrGetSetupTime(conflicthdlr: *mut SCIP_CONFLICTHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this conflict handler"]
    pub fn SCIPconflicthdlrGetTime(conflicthdlr: *mut SCIP_CONFLICTHDLR) -> f64;
}
extern "C" {
    pub fn SCIPconshdlrCompSepa(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPconshdlrCompEnfo(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPconshdlrCompCheck(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets name of constraint handler"]
    pub fn SCIPconshdlrGetName(conshdlr: *mut SCIP_CONSHDLR) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of constraint handler"]
    pub fn SCIPconshdlrGetDesc(conshdlr: *mut SCIP_CONSHDLR) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets user data of constraint handler"]
    pub fn SCIPconshdlrGetData(conshdlr: *mut SCIP_CONSHDLR) -> *mut SCIP_CONSHDLRDATA;
}
extern "C" {
    #[doc = " sets user data of constraint handler; user has to free old data in advance!"]
    pub fn SCIPconshdlrSetData(conshdlr: *mut SCIP_CONSHDLR, conshdlrdata: *mut SCIP_CONSHDLRDATA);
}
extern "C" {
    #[doc = " sets all separation related callbacks of the constraint handler"]
    pub fn SCIPconshdlrSetSepa(
        conshdlr: *mut SCIP_CONSHDLR,
        conssepalp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conssepasol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                sol: *mut SCIP_SOL,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        sepafreq: ::std::os::raw::c_int,
        sepapriority: ::std::os::raw::c_int,
        delaysepa: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " sets both the propagation callback and the propagation frequency of the constraint handler"]
    pub fn SCIPconshdlrSetProp(
        conshdlr: *mut SCIP_CONSHDLR,
        consprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                nmarkedconss: ::std::os::raw::c_int,
                proptiming: SCIP_PROPTIMING,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        propfreq: ::std::os::raw::c_int,
        delayprop: ::std::os::raw::c_uint,
        timingmask: SCIP_PROPTIMING,
    );
}
extern "C" {
    #[doc = " sets the relaxation enforcement method of the constraint handler"]
    pub fn SCIPconshdlrSetEnforelax(
        conshdlr: *mut SCIP_CONSHDLR,
        consenforelax: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sol: *mut SCIP_SOL,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " gets array with constraints of constraint handler; the first SCIPconshdlrGetNActiveConss() entries are the active"]
    #[doc = "  constraints, the last SCIPconshdlrGetNConss() - SCIPconshdlrGetNActiveConss() constraints are deactivated"]
    #[doc = ""]
    #[doc = "  @note A constraint is active if it is global and was not removed or it was added locally (in that case the local"]
    #[doc = "        flag is TRUE) and the current node belongs to the corresponding sub tree."]
    pub fn SCIPconshdlrGetConss(conshdlr: *mut SCIP_CONSHDLR) -> *mut *mut SCIP_CONS;
}
extern "C" {
    #[doc = " gets array with enforced constraints of constraint handler; this is local information"]
    pub fn SCIPconshdlrGetEnfoConss(conshdlr: *mut SCIP_CONSHDLR) -> *mut *mut SCIP_CONS;
}
extern "C" {
    #[doc = " gets array with checked constraints of constraint handler; this is local information"]
    pub fn SCIPconshdlrGetCheckConss(conshdlr: *mut SCIP_CONSHDLR) -> *mut *mut SCIP_CONS;
}
extern "C" {
    #[doc = " gets array with delayed update constraints"]
    #[doc = ""]
    #[doc = " @attention Usually, there should be no need to access this array. Use this only if you are absolutely sure what you are doing."]
    pub fn SCIPconshdlrGetUpdateConss(conshdlr: *mut SCIP_CONSHDLR) -> *mut *mut SCIP_CONS;
}
extern "C" {
    #[doc = " gets total number of existing transformed constraints of constraint handler"]
    pub fn SCIPconshdlrGetNConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of enforced constraints of constraint handler; this is local information"]
    pub fn SCIPconshdlrGetNEnfoConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of checked constraints of constraint handler; this is local information"]
    pub fn SCIPconshdlrGetNCheckConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of active constraints of constraint handler"]
    #[doc = ""]
    #[doc = "  @note A constraint is active if it is global and was not removed or it was added locally (in that case the local"]
    #[doc = "        flag is TRUE) and the current node belongs to the corresponding sub tree."]
    pub fn SCIPconshdlrGetNActiveConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of enabled constraints of constraint handler"]
    pub fn SCIPconshdlrGetNEnabledConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraints that have delayed updates"]
    pub fn SCIPconshdlrGetNUpdateConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets time in seconds used for setting up this constraint handler for new stages"]
    pub fn SCIPconshdlrGetSetupTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used for presolving in this constraint handler"]
    pub fn SCIPconshdlrGetPresolTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used for separation in this constraint handler"]
    pub fn SCIPconshdlrGetSepaTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used for LP enforcement in this constraint handler"]
    pub fn SCIPconshdlrGetEnfoLPTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used for pseudo enforcement in this constraint handler"]
    pub fn SCIPconshdlrGetEnfoPSTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used for relaxation enforcement in this constraint handler"]
    pub fn SCIPconshdlrGetEnfoRelaxTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used for propagation in this constraint handler"]
    pub fn SCIPconshdlrGetPropTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used for propagation in this constraint handler during strong branching"]
    pub fn SCIPconshdlrGetStrongBranchPropTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used for feasibility checking in this constraint handler"]
    pub fn SCIPconshdlrGetCheckTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used for resolving propagation in this constraint handler"]
    pub fn SCIPconshdlrGetRespropTime(conshdlr: *mut SCIP_CONSHDLR) -> f64;
}
extern "C" {
    #[doc = " gets number of calls to the constraint handler's separation method"]
    pub fn SCIPconshdlrGetNSepaCalls(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of calls to the constraint handler's LP enforcing method"]
    pub fn SCIPconshdlrGetNEnfoLPCalls(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of calls to the constraint handler's pseudo enforcing method"]
    pub fn SCIPconshdlrGetNEnfoPSCalls(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of calls to the constraint handler's relaxation enforcing method"]
    pub fn SCIPconshdlrGetNEnfoRelaxCalls(
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of calls to the constraint handler's propagation method"]
    pub fn SCIPconshdlrGetNPropCalls(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of calls to the constraint handler's checking method"]
    pub fn SCIPconshdlrGetNCheckCalls(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of calls to the constraint handler's resolve propagation method"]
    pub fn SCIPconshdlrGetNRespropCalls(conshdlr: *mut SCIP_CONSHDLR)
        -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of times, this constraint handler detected a cutoff"]
    pub fn SCIPconshdlrGetNCutoffs(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of cuts found by this constraint handler"]
    pub fn SCIPconshdlrGetNCutsFound(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of cuts found by this constraint handler applied to lp"]
    pub fn SCIPconshdlrGetNCutsApplied(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of additional constraints added by this constraint handler"]
    pub fn SCIPconshdlrGetNConssFound(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of domain reductions found by this constraint handler"]
    pub fn SCIPconshdlrGetNDomredsFound(conshdlr: *mut SCIP_CONSHDLR)
        -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of children created by this constraint handler"]
    pub fn SCIPconshdlrGetNChildren(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets maximum number of active constraints of constraint handler existing at the same time"]
    pub fn SCIPconshdlrGetMaxNActiveConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets initial number of active constraints of constraint handler"]
    pub fn SCIPconshdlrGetStartNActiveConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of variables fixed in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNFixedVars(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of variables aggregated in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNAggrVars(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of variable types changed in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNChgVarTypes(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of bounds changed in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNChgBds(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of holes added to domains of variables in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNAddHoles(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraints deleted in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNDelConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraints added in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNAddConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraints upgraded in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNUpgdConss(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of coefficients changed in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNChgCoefs(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraint sides changed in presolving method of constraint handler"]
    pub fn SCIPconshdlrGetNChgSides(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of times the presolving method of the constraint handler was called and tried to find reductions"]
    pub fn SCIPconshdlrGetNPresolCalls(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets separation priority of constraint handler"]
    pub fn SCIPconshdlrGetSepaPriority(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets enforcing priority of constraint handler"]
    pub fn SCIPconshdlrGetEnfoPriority(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets checking priority of constraint handler"]
    pub fn SCIPconshdlrGetCheckPriority(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets separation frequency of constraint handler"]
    pub fn SCIPconshdlrGetSepaFreq(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets propagation frequency of constraint handler"]
    pub fn SCIPconshdlrGetPropFreq(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets frequency of constraint handler for eager evaluations in separation, propagation and enforcement"]
    pub fn SCIPconshdlrGetEagerFreq(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " needs constraint handler a constraint to be called?"]
    pub fn SCIPconshdlrNeedsCons(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " does the constraint handler perform presolving?"]
    pub fn SCIPconshdlrDoesPresolve(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " should separation method be delayed, if other separators found cuts?"]
    pub fn SCIPconshdlrIsSeparationDelayed(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " should propagation method be delayed, if other propagators found reductions?"]
    pub fn SCIPconshdlrIsPropagationDelayed(conshdlr: *mut SCIP_CONSHDLR)
        -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " was LP separation method delayed at the last call?"]
    pub fn SCIPconshdlrWasLPSeparationDelayed(
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " was primal solution separation method delayed at the last call?"]
    pub fn SCIPconshdlrWasSolSeparationDelayed(
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " was propagation method delayed at the last call?"]
    pub fn SCIPconshdlrWasPropagationDelayed(
        conshdlr: *mut SCIP_CONSHDLR,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " is constraint handler initialized?"]
    pub fn SCIPconshdlrIsInitialized(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " does the constraint handler have a copy function?"]
    pub fn SCIPconshdlrIsClonable(conshdlr: *mut SCIP_CONSHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the timing mask of the propagation method of the constraint handler"]
    pub fn SCIPconshdlrGetPropTiming(conshdlr: *mut SCIP_CONSHDLR) -> SCIP_PROPTIMING;
}
extern "C" {
    #[doc = " gets added constraints data for a constraint set change"]
    pub fn SCIPconssetchgGetAddedConsData(
        conssetchg: *mut SCIP_CONSSETCHG,
        conss: *mut *mut *mut SCIP_CONS,
        nconss: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sets the timing mask of the propagation method of the constraint handler"]
    pub fn SCIPconshdlrSetPropTiming(conshdlr: *mut SCIP_CONSHDLR, proptiming: SCIP_PROPTIMING);
}
extern "C" {
    #[doc = " returns the timing mask of the presolving method of the constraint handler"]
    pub fn SCIPconshdlrGetPresolTiming(conshdlr: *mut SCIP_CONSHDLR) -> SCIP_PRESOLTIMING;
}
extern "C" {
    #[doc = " sets the timing mask of the presolving method of the constraint handler"]
    pub fn SCIPconshdlrSetPresolTiming(
        conshdlr: *mut SCIP_CONSHDLR,
        presoltiming: SCIP_PRESOLTIMING,
    );
}
extern "C" {
    #[doc = " returns the name of the constraint"]
    #[doc = ""]
    #[doc = "  @note to change the name of a constraint, use SCIPchgConsName() from scip.h"]
    pub fn SCIPconsGetName(cons: *mut SCIP_CONS) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns the position of constraint in the corresponding handler's conss array"]
    pub fn SCIPconsGetPos(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the constraint handler of the constraint"]
    pub fn SCIPconsGetHdlr(cons: *mut SCIP_CONS) -> *mut SCIP_CONSHDLR;
}
extern "C" {
    #[doc = " returns the constraint data field of the constraint"]
    pub fn SCIPconsGetData(cons: *mut SCIP_CONS) -> *mut SCIP_CONSDATA;
}
extern "C" {
    #[doc = " gets number of times, the constraint is currently captured"]
    pub fn SCIPconsGetNUses(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " for an active constraint, returns the depth in the tree at which the constraint was activated"]
    pub fn SCIPconsGetActiveDepth(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the depth in the tree at which the constraint is valid; returns INT_MAX, if the constraint is local"]
    #[doc = "  and currently not active"]
    pub fn SCIPconsGetValidDepth(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is active in the current node"]
    pub fn SCIPconsIsActive(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint has to be deactivated in update phase"]
    pub fn SCIPconsIsUpdatedeactivate(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is enabled in the current node"]
    pub fn SCIPconsIsEnabled(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint's separation is enabled in the current node"]
    pub fn SCIPconsIsSeparationEnabled(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint's propagation is enabled in the current node"]
    pub fn SCIPconsIsPropagationEnabled(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is deleted or marked to be deleted"]
    pub fn SCIPconsIsDeleted(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is marked obsolete"]
    pub fn SCIPconsIsObsolete(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is marked as a conflict"]
    pub fn SCIPconsIsConflict(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets age of constraint"]
    pub fn SCIPconsGetAge(cons: *mut SCIP_CONS) -> f64;
}
extern "C" {
    #[doc = " returns TRUE iff the LP relaxation of constraint should be in the initial LP"]
    pub fn SCIPconsIsInitial(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint should be separated during LP processing"]
    pub fn SCIPconsIsSeparated(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint should be enforced during node processing"]
    pub fn SCIPconsIsEnforced(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint should be checked for feasibility"]
    pub fn SCIPconsIsChecked(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the constraint is marked for propagation"]
    pub fn SCIPconsIsMarkedPropagate(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint should be propagated during node processing"]
    pub fn SCIPconsIsPropagated(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is globally valid"]
    pub fn SCIPconsIsGlobal(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is only locally valid or not added to any (sub)problem"]
    pub fn SCIPconsIsLocal(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is modifiable (subject to column generation)"]
    pub fn SCIPconsIsModifiable(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is subject to aging"]
    pub fn SCIPconsIsDynamic(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint's relaxation should be removed from the LP due to aging or cleanup"]
    pub fn SCIPconsIsRemovable(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint's relaxation should be removed from the LP due to aging or cleanup"]
    pub fn SCIPconsIsStickingAtNode(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint belongs to the global problem"]
    pub fn SCIPconsIsInProb(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is belonging to original space"]
    pub fn SCIPconsIsOriginal(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff constraint is belonging to transformed space"]
    pub fn SCIPconsIsTransformed(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff roundings for variables in constraint are locked"]
    pub fn SCIPconsIsLockedPos(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff roundings for variables in constraint's negation are locked"]
    pub fn SCIPconsIsLockedNeg(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff roundings for variables in constraint or in constraint's negation are locked"]
    pub fn SCIPconsIsLocked(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " get number of times the roundings for variables in constraint are locked"]
    pub fn SCIPconsGetNLocksPos(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of times the roundings for variables in constraint's negation are locked"]
    pub fn SCIPconsGetNLocksNeg(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns TRUE iff roundings of the given locktype for variables in constraint are locked"]
    pub fn SCIPconsIsLockedTypePos(
        cons: *mut SCIP_CONS,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff roundings of the given locktype for variables in constraint are locked"]
    pub fn SCIPconsIsLockedTypeNeg(
        cons: *mut SCIP_CONS,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff roundings of the given locktype for variables in constraint or in constraint's negation are locked"]
    pub fn SCIPconsIsLockedType(
        cons: *mut SCIP_CONS,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " get number of times the roundings of given locktype for variables in constraint are locked"]
    pub fn SCIPconsGetNLocksTypePos(
        cons: *mut SCIP_CONS,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of times the roundings of given locktype for variables in constraint's negation are locked"]
    pub fn SCIPconsGetNLocksTypeNeg(
        cons: *mut SCIP_CONS,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns if the constraint was already added to a SCIP instance"]
    pub fn SCIPconsIsAdded(cons: *mut SCIP_CONS) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " adds locks to (dis-)allow upgrading of constraint"]
    pub fn SCIPconsAddUpgradeLocks(cons: *mut SCIP_CONS, nlocks: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " gets number of locks against upgrading the constraint, 0 means this constraint can be upgraded"]
    pub fn SCIPconsGetNUpgradeLocks(cons: *mut SCIP_CONS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " create linear constraint statistics"]
    pub fn SCIPlinConsStatsCreate(
        scip: *mut SCIP,
        linconsstats: *mut *mut SCIP_LINCONSSTATS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " free linear constraint statistics"]
    pub fn SCIPlinConsStatsFree(scip: *mut SCIP, linconsstats: *mut *mut SCIP_LINCONSSTATS);
}
extern "C" {
    #[doc = " resets linear constraint statistics"]
    pub fn SCIPlinConsStatsReset(linconsstats: *mut SCIP_LINCONSSTATS);
}
extern "C" {
    #[doc = " returns the number of occurrences of a specific type of linear constraint"]
    pub fn SCIPlinConsStatsGetTypeCount(
        linconsstats: *mut SCIP_LINCONSSTATS,
        linconstype: SCIP_LINCONSTYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the total number of classified constraints"]
    pub fn SCIPlinConsStatsGetSum(linconsstats: *mut SCIP_LINCONSSTATS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " increases the number of occurrences of a specific type of linear constraint"]
    pub fn SCIPlinConsStatsIncTypeCount(
        linconsstats: *mut SCIP_LINCONSSTATS,
        linconstype: SCIP_LINCONSTYPE,
        increment: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " print linear constraint classification statistics"]
    pub fn SCIPprintLinConsStats(
        scip: *mut SCIP,
        file: *mut FILE,
        linconsstats: *mut SCIP_LINCONSSTATS,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Cutpool {
    _unused: [u8; 0],
}
pub type SCIP_CUTPOOL = SCIP_Cutpool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Cut {
    _unused: [u8; 0],
}
pub type SCIP_CUT = SCIP_Cut;
extern "C" {
    #[doc = " gets the row of the cut"]
    pub fn SCIPcutGetRow(cut: *mut SCIP_CUT) -> *mut SCIP_ROW;
}
extern "C" {
    #[doc = " gets the age of the cut: the number of consecutive cut pool separation rounds where the cut was neither in the LP nor violated"]
    pub fn SCIPcutGetAge(cut: *mut SCIP_CUT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the ratio of LPs where the row belonging to this cut was active in an LP solution, i.e."]
    #[doc = "  where the age of its row has not been increased"]
    #[doc = ""]
    #[doc = "  @see SCIPcutGetAge() to get the age of a cut"]
    pub fn SCIPcutGetLPActivityQuot(cut: *mut SCIP_CUT) -> f64;
}
extern "C" {
    #[doc = " gets array of cuts in the cut pool"]
    pub fn SCIPcutpoolGetCuts(cutpool: *mut SCIP_CUTPOOL) -> *mut *mut SCIP_CUT;
}
extern "C" {
    #[doc = " get number of cuts in the cut pool"]
    pub fn SCIPcutpoolGetNCuts(cutpool: *mut SCIP_CUTPOOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get maximum number of cuts that were stored in the cut pool at the same time"]
    pub fn SCIPcutpoolGetMaxNCuts(cutpool: *mut SCIP_CUTPOOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets time in seconds used for separating cuts from the pool"]
    pub fn SCIPcutpoolGetTime(cutpool: *mut SCIP_CUTPOOL) -> f64;
}
extern "C" {
    #[doc = " get number of times, the cut pool was separated"]
    pub fn SCIPcutpoolGetNCalls(cutpool: *mut SCIP_CUTPOOL) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get total number of cuts that were separated from the cut pool"]
    pub fn SCIPcutpoolGetNCutsFound(cutpool: *mut SCIP_CUTPOOL) -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Decomp {
    _unused: [u8; 0],
}
pub type SCIP_DECOMP = SCIP_Decomp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_DecompStore {
    _unused: [u8; 0],
}
pub type SCIP_DECOMPSTORE = SCIP_DecompStore;
extern "C" {
    #[doc = " creates a decomposition"]
    pub fn SCIPdecompCreate(
        decomp: *mut *mut SCIP_DECOMP,
        blkmem: *mut BMS_BLKMEM,
        nblocks: ::std::os::raw::c_int,
        original: ::std::os::raw::c_uint,
        benderslabels: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a decomposition"]
    pub fn SCIPdecompFree(decomp: *mut *mut SCIP_DECOMP, blkmem: *mut BMS_BLKMEM);
}
extern "C" {
    #[doc = " returns TRUE if decomposition is in the original space"]
    pub fn SCIPdecompIsOriginal(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets the parameter that indicates whether the variables must be labeled for the application of Benders'"]
    #[doc = " decomposition"]
    pub fn SCIPdecompSetUseBendersLabels(
        decomp: *mut SCIP_DECOMP,
        benderslabels: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns TRUE if the variables must be labeled for the application of Benders' decomposition"]
    pub fn SCIPdecompUseBendersLabels(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets number of blocks of this decomposition"]
    pub fn SCIPdecompGetNBlocks(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets area score of this decomposition"]
    pub fn SCIPdecompGetAreaScore(decomp: *mut SCIP_DECOMP) -> f64;
}
extern "C" {
    #[doc = " gets modularity of this decomposition"]
    pub fn SCIPdecompGetModularity(decomp: *mut SCIP_DECOMP) -> f64;
}
extern "C" {
    #[doc = " gets number of edges in the block-decomposition graph of this decomposition"]
    pub fn SCIPdecompGetNBlockGraphEdges(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of connected components in the block-decomposition graph of this decomposition"]
    pub fn SCIPdecompGetNBlockGraphComponents(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of articulation points in the block-decomposition graph of this decomposition"]
    pub fn SCIPdecompGetNBlockGraphArticulations(decomp: *mut SCIP_DECOMP)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the maximum degree of the block-decomposition graph of this decomposition"]
    pub fn SCIPdecompGetBlockGraphMaxDegree(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the minimum degree of the block-decomposition graph of this decomposition"]
    pub fn SCIPdecompGetBlockGraphMinDegree(decomp: *mut SCIP_DECOMP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets labels for an array of variables"]
    pub fn SCIPdecompSetVarsLabels(
        decomp: *mut SCIP_DECOMP,
        vars: *mut *mut SCIP_VAR,
        labels: *mut ::std::os::raw::c_int,
        nvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " queries labels for an array of variables"]
    pub fn SCIPdecompGetVarsLabels(
        decomp: *mut SCIP_DECOMP,
        vars: *mut *mut SCIP_VAR,
        labels: *mut ::std::os::raw::c_int,
        nvars: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sets labels for an array of constraints"]
    pub fn SCIPdecompSetConsLabels(
        decomp: *mut SCIP_DECOMP,
        conss: *mut *mut SCIP_CONS,
        labels: *mut ::std::os::raw::c_int,
        nconss: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " queries labels for an array of constraints"]
    pub fn SCIPdecompGetConsLabels(
        decomp: *mut SCIP_DECOMP,
        conss: *mut *mut SCIP_CONS,
        labels: *mut ::std::os::raw::c_int,
        nconss: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " clears the corresponding labeling (constraints, variables, or both) of this decomposition"]
    pub fn SCIPdecompClear(
        decomp: *mut SCIP_DECOMP,
        clearvarlabels: ::std::os::raw::c_uint,
        clearconslabels: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " prints decomposition statistics into string buffer"]
    pub fn SCIPdecompPrintStats(
        decomp: *mut SCIP_DECOMP,
        strbuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@addtogroup PublicDialogMethods"]
    #[doc = ""]
    #[doc = " @{"]
    pub fn SCIPdialoghdlrGetRoot(dialoghdlr: *mut SCIP_DIALOGHDLR) -> *mut SCIP_DIALOG;
}
extern "C" {
    #[doc = " clears the input command buffer of the dialog handler"]
    pub fn SCIPdialoghdlrClearBuffer(dialoghdlr: *mut SCIP_DIALOGHDLR);
}
extern "C" {
    #[doc = " returns TRUE iff input command buffer is empty"]
    pub fn SCIPdialoghdlrIsBufferEmpty(dialoghdlr: *mut SCIP_DIALOGHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the next line in the handler's command buffer; if the buffer is empty, displays the given prompt or the"]
    #[doc = "  current dialog's path and asks the user for further input; the user must not free or modify the returned string"]
    pub fn SCIPdialoghdlrGetLine(
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        dialog: *mut SCIP_DIALOG,
        prompt: *const ::std::os::raw::c_char,
        inputline: *mut *mut ::std::os::raw::c_char,
        endoffile: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the next word in the handler's command buffer; if the buffer is empty, displays the given prompt or the"]
    #[doc = "  current dialog's path and asks the user for further input; the user must not free or modify the returned string"]
    pub fn SCIPdialoghdlrGetWord(
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        dialog: *mut SCIP_DIALOG,
        prompt: *const ::std::os::raw::c_char,
        inputword: *mut *mut ::std::os::raw::c_char,
        endoffile: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a single line of input to the dialog handler which is treated as if the user entered the command line"]
    pub fn SCIPdialoghdlrAddInputLine(
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        inputline: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a command to the command history of the dialog handler; if a dialog is given, the command is preceeded"]
    #[doc = "  by the dialog's command path; if no command is given, only the path to the dialog is added to the command history"]
    pub fn SCIPdialoghdlrAddHistory(
        dialoghdlr: *mut SCIP_DIALOGHDLR,
        dialog: *mut SCIP_DIALOG,
        command: *const ::std::os::raw::c_char,
        escapecommand: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns TRUE iff a dialog entry matching exactly the given name is existing in the given dialog"]
    pub fn SCIPdialogHasEntry(
        dialog: *mut SCIP_DIALOG,
        entryname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " searches the dialog for entries corresponding to the given name;"]
    #[doc = "  If a complete match is found, the entry is returned as \"subdialog\" and"]
    #[doc = "  the return value is 1."]
    #[doc = "  If no dialog entry completely matches the given \"entryname\", the number"]
    #[doc = "  of entries with names beginning with \"entryname\" is returned. If this"]
    #[doc = "  number is 1, the single match is returned as \"subdialog\". Otherwise,"]
    #[doc = "  \"subdialog\" is set to NULL."]
    pub fn SCIPdialogFindEntry(
        dialog: *mut SCIP_DIALOG,
        entryname: *const ::std::os::raw::c_char,
        subdialog: *mut *mut SCIP_DIALOG,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " displays the dialog's menu"]
    pub fn SCIPdialogDisplayMenu(dialog: *mut SCIP_DIALOG, scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " displays the entry for the dialog in it's parent's menu"]
    pub fn SCIPdialogDisplayMenuEntry(dialog: *mut SCIP_DIALOG, scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " displays all dialog entries with names starting with the given \"entryname\""]
    pub fn SCIPdialogDisplayCompletions(
        dialog: *mut SCIP_DIALOG,
        scip: *mut SCIP,
        entryname: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the name of the current path in the dialog tree, separated by the given character"]
    pub fn SCIPdialogGetPath(
        dialog: *mut SCIP_DIALOG,
        sepchar: ::std::os::raw::c_char,
        path: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " gets the command name of the dialog"]
    pub fn SCIPdialogGetName(dialog: *mut SCIP_DIALOG) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets the description of the dialog"]
    pub fn SCIPdialogGetDesc(dialog: *mut SCIP_DIALOG) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns whether the dialog is a sub menu"]
    pub fn SCIPdialogIsSubmenu(dialog: *mut SCIP_DIALOG) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets the parent dialog of the given dialog"]
    pub fn SCIPdialogGetParent(dialog: *mut SCIP_DIALOG) -> *mut SCIP_DIALOG;
}
extern "C" {
    #[doc = " gets the array of sub-dialogs associated with the given dialog"]
    pub fn SCIPdialogGetSubdialogs(dialog: *mut SCIP_DIALOG) -> *mut *mut SCIP_DIALOG;
}
extern "C" {
    #[doc = " gets the number of sub-dialogs associated with the given dialog"]
    pub fn SCIPdialogGetNSubdialogs(dialog: *mut SCIP_DIALOG) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the user defined data associated with the given dialog"]
    pub fn SCIPdialogGetData(dialog: *mut SCIP_DIALOG) -> *mut SCIP_DIALOGDATA;
}
extern "C" {
    #[doc = " sets user data of dialog; user has to free old data in advance!"]
    pub fn SCIPdialogSetData(dialog: *mut SCIP_DIALOG, dialogdata: *mut SCIP_DIALOGDATA);
}
extern "C" {
    #[doc = " writes command history to specified filename"]
    pub fn SCIPdialogWriteHistory(filename: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets user data of display column"]
    pub fn SCIPdispGetData(disp: *mut SCIP_DISP) -> *mut SCIP_DISPDATA;
}
extern "C" {
    #[doc = " sets user data of display column; user has to free old data in advance!"]
    pub fn SCIPdispSetData(disp: *mut SCIP_DISP, dispdata: *mut SCIP_DISPDATA);
}
extern "C" {
    #[doc = " gets name of display column"]
    pub fn SCIPdispGetName(disp: *mut SCIP_DISP) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of display column"]
    pub fn SCIPdispGetDesc(disp: *mut SCIP_DISP) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets head line of display column"]
    pub fn SCIPdispGetHeader(disp: *mut SCIP_DISP) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets width of display column"]
    pub fn SCIPdispGetWidth(disp: *mut SCIP_DISP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets priority of display column"]
    pub fn SCIPdispGetPriority(disp: *mut SCIP_DISP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets position of display column"]
    pub fn SCIPdispGetPosition(disp: *mut SCIP_DISP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets status of display column"]
    pub fn SCIPdispGetStatus(disp: *mut SCIP_DISP) -> SCIP_DISPSTATUS;
}
extern "C" {
    #[doc = " is display column initialized?"]
    pub fn SCIPdispIsInitialized(disp: *mut SCIP_DISP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " displays a long integer in decimal form fitting in a given width"]
    pub fn SCIPdispLongint(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        val: ::std::os::raw::c_longlong,
        width: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " displays an integer in decimal form fitting in a given width"]
    pub fn SCIPdispInt(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        val: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " displays a time value fitting in a given width"]
    pub fn SCIPdispTime(
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        val: f64,
        width: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " gets name of event handler"]
    pub fn SCIPeventhdlrGetName(eventhdlr: *mut SCIP_EVENTHDLR) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets user data of event handler"]
    pub fn SCIPeventhdlrGetData(eventhdlr: *mut SCIP_EVENTHDLR) -> *mut SCIP_EVENTHDLRDATA;
}
extern "C" {
    #[doc = " sets user data of event handler; user has to free old data in advance!"]
    pub fn SCIPeventhdlrSetData(
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventhdlrdata: *mut SCIP_EVENTHDLRDATA,
    );
}
extern "C" {
    #[doc = " is event handler initialized?"]
    pub fn SCIPeventhdlrIsInitialized(eventhdlr: *mut SCIP_EVENTHDLR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets time in seconds used in this event handler for setting up for next stages"]
    pub fn SCIPeventhdlrGetSetupTime(eventhdlr: *mut SCIP_EVENTHDLR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this event handler"]
    pub fn SCIPeventhdlrGetTime(eventhdlr: *mut SCIP_EVENTHDLR) -> f64;
}
extern "C" {
    #[doc = " gets type of event"]
    pub fn SCIPeventGetType(event: *mut SCIP_EVENT) -> SCIP_EVENTTYPE;
}
extern "C" {
    #[doc = " gets variable for a variable event (var added, var deleted, var fixed,"]
    #[doc = "  objective value or domain change, domain hole added or removed)"]
    pub fn SCIPeventGetVar(event: *mut SCIP_EVENT) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets old objective value for an objective value change event"]
    pub fn SCIPeventGetOldobj(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets new objective value for an objective value change event"]
    pub fn SCIPeventGetNewobj(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets old bound for a bound change event"]
    pub fn SCIPeventGetOldbound(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets new bound for a bound change event"]
    pub fn SCIPeventGetNewbound(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets old variable type for a variable type change event"]
    pub fn SCIPeventGetOldtype(event: *mut SCIP_EVENT) -> SCIP_VARTYPE;
}
extern "C" {
    #[doc = " gets new variable type for a variable type change event"]
    pub fn SCIPeventGetNewtype(event: *mut SCIP_EVENT) -> SCIP_VARTYPE;
}
extern "C" {
    #[doc = " gets node for a node or LP event"]
    pub fn SCIPeventGetNode(event: *mut SCIP_EVENT) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets solution for a primal solution event"]
    pub fn SCIPeventGetSol(event: *mut SCIP_EVENT) -> *mut SCIP_SOL;
}
extern "C" {
    #[doc = " gets the left bound of open interval in the hole"]
    pub fn SCIPeventGetHoleLeft(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets the right bound of open interval in the hole"]
    pub fn SCIPeventGetHoleRight(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets row for a row event"]
    pub fn SCIPeventGetRow(event: *mut SCIP_EVENT) -> *mut SCIP_ROW;
}
extern "C" {
    #[doc = " gets column for a row change coefficient event"]
    pub fn SCIPeventGetRowCol(event: *mut SCIP_EVENT) -> *mut SCIP_COL;
}
extern "C" {
    #[doc = " gets old coefficient value for a row change coefficient event"]
    pub fn SCIPeventGetRowOldCoefVal(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets new coefficient value for a row change coefficient event"]
    pub fn SCIPeventGetRowNewCoefVal(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets old constant value for a row change constant event"]
    pub fn SCIPeventGetRowOldConstVal(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets new constant value for a row change constant event"]
    pub fn SCIPeventGetRowNewConstVal(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets side for a row change side event"]
    pub fn SCIPeventGetRowSide(event: *mut SCIP_EVENT) -> SCIP_SIDETYPE;
}
extern "C" {
    #[doc = " gets old side value for a row change side event"]
    pub fn SCIPeventGetRowOldSideVal(event: *mut SCIP_EVENT) -> f64;
}
extern "C" {
    #[doc = " gets new side value for a row change side event"]
    pub fn SCIPeventGetRowNewSideVal(event: *mut SCIP_EVENT) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_File {
    _unused: [u8; 0],
}
pub type SCIP_FILE = SCIP_File;
extern "C" {
    pub fn SCIPfopen(
        path: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_FILE;
}
extern "C" {
    pub fn SCIPfdopen(
        fildes: ::std::os::raw::c_int,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_FILE;
}
extern "C" {
    pub fn SCIPfread(
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
        nmemb: size_t,
        stream: *mut SCIP_FILE,
    ) -> size_t;
}
extern "C" {
    pub fn SCIPfwrite(
        ptr: *const ::std::os::raw::c_void,
        size: size_t,
        nmemb: size_t,
        stream: *mut SCIP_FILE,
    ) -> size_t;
}
extern "C" {
    pub fn SCIPfprintf(
        stream: *mut SCIP_FILE,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPfputc(c: ::std::os::raw::c_int, stream: *mut SCIP_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPfputs(
        s: *const ::std::os::raw::c_char,
        stream: *mut SCIP_FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPfgetc(stream: *mut SCIP_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPfgets(
        s: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        stream: *mut SCIP_FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SCIPfflush(stream: *mut SCIP_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPfseek(
        stream: *mut SCIP_FILE,
        offset: ::std::os::raw::c_long,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPrewind(stream: *mut SCIP_FILE);
}
extern "C" {
    pub fn SCIPftell(stream: *mut SCIP_FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SCIPfeof(stream: *mut SCIP_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPfclose(fp: *mut SCIP_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPheurComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPheurCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of primal heuristic"]
    pub fn SCIPheurGetData(heur: *mut SCIP_HEUR) -> *mut SCIP_HEURDATA;
}
extern "C" {
    #[doc = " sets user data of primal heuristic; user has to free old data in advance!"]
    pub fn SCIPheurSetData(heur: *mut SCIP_HEUR, heurdata: *mut SCIP_HEURDATA);
}
extern "C" {
    #[doc = " gets name of primal heuristic"]
    pub fn SCIPheurGetName(heur: *mut SCIP_HEUR) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of primal heuristic"]
    pub fn SCIPheurGetDesc(heur: *mut SCIP_HEUR) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets display character of primal heuristic"]
    pub fn SCIPheurGetDispchar(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns the timing mask of the heuristic"]
    pub fn SCIPheurGetTimingmask(heur: *mut SCIP_HEUR) -> SCIP_HEURTIMING;
}
extern "C" {
    #[doc = " sets new timing mask for heuristic"]
    pub fn SCIPheurSetTimingmask(heur: *mut SCIP_HEUR, timingmask: SCIP_HEURTIMING);
}
extern "C" {
    #[doc = " does the heuristic use a secondary SCIP instance?"]
    pub fn SCIPheurUsesSubscip(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets priority of primal heuristic"]
    pub fn SCIPheurGetPriority(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets frequency of primal heuristic"]
    pub fn SCIPheurGetFreq(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets frequency of primal heuristic"]
    pub fn SCIPheurSetFreq(heur: *mut SCIP_HEUR, freq: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " gets frequency offset of primal heuristic"]
    pub fn SCIPheurGetFreqofs(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets maximal depth level for calling primal heuristic (returns -1, if no depth limit exists)"]
    pub fn SCIPheurGetMaxdepth(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of times, the heuristic was called and tried to find a solution"]
    pub fn SCIPheurGetNCalls(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the number of primal feasible solutions found by this heuristic"]
    pub fn SCIPheurGetNSolsFound(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the number of new best primal feasible solutions found by this heuristic"]
    pub fn SCIPheurGetNBestSolsFound(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " is primal heuristic initialized?"]
    pub fn SCIPheurIsInitialized(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets time in seconds used in this heuristic for setting up for next stages"]
    pub fn SCIPheurGetSetupTime(heur: *mut SCIP_HEUR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this heuristic"]
    pub fn SCIPheurGetTime(heur: *mut SCIP_HEUR) -> f64;
}
extern "C" {
    #[doc = " returns array of divesets of this primal heuristic, or NULL if it has no divesets"]
    pub fn SCIPheurGetDivesets(heur: *mut SCIP_HEUR) -> *mut *mut SCIP_DIVESET;
}
extern "C" {
    #[doc = " returns the number of divesets of this primal heuristic"]
    pub fn SCIPheurGetNDivesets(heur: *mut SCIP_HEUR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the heuristic to which this diving setting belongs"]
    pub fn SCIPdivesetGetHeur(diveset: *mut SCIP_DIVESET) -> *mut SCIP_HEUR;
}
extern "C" {
    #[doc = " get the working solution of this dive set"]
    pub fn SCIPdivesetGetWorkSolution(diveset: *mut SCIP_DIVESET) -> *mut SCIP_SOL;
}
extern "C" {
    #[doc = " set the working solution for this dive set"]
    pub fn SCIPdivesetSetWorkSolution(diveset: *mut SCIP_DIVESET, sol: *mut SCIP_SOL);
}
extern "C" {
    #[doc = " get the name of the dive set"]
    pub fn SCIPdivesetGetName(diveset: *mut SCIP_DIVESET) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " get the minimum relative depth of the diving settings"]
    pub fn SCIPdivesetGetMinRelDepth(diveset: *mut SCIP_DIVESET) -> f64;
}
extern "C" {
    #[doc = " get the maximum relative depth of the diving settings"]
    pub fn SCIPdivesetGetMaxRelDepth(diveset: *mut SCIP_DIVESET) -> f64;
}
extern "C" {
    #[doc = " get the number of successful runs of the diving settings"]
    pub fn SCIPdivesetGetSolSuccess(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get the number of calls to this dive set"]
    pub fn SCIPdivesetGetNCalls(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the number of calls successfully terminated at a feasible leaf node"]
    pub fn SCIPdivesetGetNSolutionCalls(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the minimum depth reached by this dive set"]
    pub fn SCIPdivesetGetMinDepth(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the maximum depth reached by this dive set"]
    pub fn SCIPdivesetGetMaxDepth(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the average depth this dive set reached during execution"]
    pub fn SCIPdivesetGetAvgDepth(diveset: *mut SCIP_DIVESET, divecontext: SCIP_DIVECONTEXT)
        -> f64;
}
extern "C" {
    #[doc = " get the minimum depth at which this dive set found a solution"]
    pub fn SCIPdivesetGetMinSolutionDepth(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the maximum depth at which this dive set found a solution"]
    pub fn SCIPdivesetGetMaxSolutionDepth(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the average depth at which this dive set found a solution"]
    pub fn SCIPdivesetGetAvgSolutionDepth(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> f64;
}
extern "C" {
    #[doc = " get the total number of LP iterations used by this dive set"]
    pub fn SCIPdivesetGetNLPIterations(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get the total number of probing nodes used by this dive set"]
    pub fn SCIPdivesetGetNProbingNodes(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get the total number of backtracks performed by this dive set"]
    pub fn SCIPdivesetGetNBacktracks(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get the total number of conflicts found by this dive set"]
    pub fn SCIPdivesetGetNConflicts(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get the total number of solutions (leaf and rounded solutions) found by the dive set"]
    pub fn SCIPdivesetGetNSols(
        diveset: *mut SCIP_DIVESET,
        divecontext: SCIP_DIVECONTEXT,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get the maximum LP iterations quotient of the diving settings"]
    pub fn SCIPdivesetGetMaxLPIterQuot(diveset: *mut SCIP_DIVESET) -> f64;
}
extern "C" {
    #[doc = " get the maximum LP iterations offset of the diving settings"]
    pub fn SCIPdivesetGetMaxLPIterOffset(diveset: *mut SCIP_DIVESET) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the maximum upper bound quotient parameter of the diving settings if no solution is available"]
    pub fn SCIPdivesetGetUbQuotNoSol(diveset: *mut SCIP_DIVESET) -> f64;
}
extern "C" {
    #[doc = " get the average quotient parameter of the diving settings if no solution is available"]
    pub fn SCIPdivesetGetAvgQuotNoSol(diveset: *mut SCIP_DIVESET) -> f64;
}
extern "C" {
    #[doc = " get the maximum upper bound quotient parameter of the diving settings if an incumbent solution exists"]
    pub fn SCIPdivesetGetUbQuot(diveset: *mut SCIP_DIVESET) -> f64;
}
extern "C" {
    #[doc = " get the average upper bound quotient parameter of the diving settings if an incumbent solution exists"]
    pub fn SCIPdivesetGetAvgQuot(diveset: *mut SCIP_DIVESET) -> f64;
}
extern "C" {
    #[doc = " should backtracking be applied?"]
    pub fn SCIPdivesetUseBacktrack(diveset: *mut SCIP_DIVESET) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the LP solve frequency for diving LPs (0: dynamically based on number of intermediate domain reductions)"]
    pub fn SCIPdivesetGetLPSolveFreq(diveset: *mut SCIP_DIVESET) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the domain reduction quotient for triggering an immediate resolve of the diving LP (0.0: always resolve)"]
    pub fn SCIPdivesetGetLPResolveDomChgQuot(diveset: *mut SCIP_DIVESET) -> f64;
}
extern "C" {
    #[doc = " should only LP branching candidates be considered instead of the slower but"]
    #[doc = "  more general constraint handler diving variable selection?"]
    pub fn SCIPdivesetUseOnlyLPBranchcands(diveset: *mut SCIP_DIVESET) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE if dive set supports diving of the specified type"]
    pub fn SCIPdivesetSupportsType(
        diveset: *mut SCIP_DIVESET,
        divetype: SCIP_DIVETYPE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the random number generator of this \\p diveset for tie-breaking"]
    pub fn SCIPdivesetGetRandnumgen(diveset: *mut SCIP_DIVESET) -> *mut SCIP_RANDNUMGEN;
}
extern "C" {
    #[doc = " is this dive set publicly available (ie., can be used by other primal heuristics?)"]
    pub fn SCIPdivesetIsPublic(diveset: *mut SCIP_DIVESET) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Perform breadth-first (BFS) search on the variable constraint graph."]
    #[doc = ""]
    #[doc = "  The result of the algorithm is that the \\p distances array contains the correct distances for"]
    #[doc = "  every variable from the start variables. The distance of a variable can then be accessed through its"]
    #[doc = "  problem index (calling SCIPvarGetProbindex())."]
    #[doc = "  Hence, The method assumes that the length of \\p distances is at least"]
    #[doc = "  SCIPgetNVars()."]
    #[doc = "  Variables that are not connected through constraints to the start variables have a distance of -1."]
    #[doc = ""]
    #[doc = "  Limits can be provided to further restrict the breadth-first search. If a distance limit is given,"]
    #[doc = "  the search will be performed until the first variable at this distance is popped from the queue, i.e.,"]
    #[doc = "  all variables with a distance < maxdistance have been labeled by the search."]
    #[doc = "  If a variable limit is given, the search stops after it completes the distance level at which"]
    #[doc = "  the limit was reached. Hence, more variables may be actually labeled."]
    #[doc = "  The start variables are accounted for those variable limits."]
    #[doc = ""]
    #[doc = "  If no variable variable constraint graph is provided, the method will create one and free it at the end"]
    #[doc = "  This is useful for a single use of the variable constraint graph. For several consecutive uses,"]
    #[doc = "  it is advised to create a variable constraint graph via SCIPvariableGraphCreate()."]
    pub fn SCIPvariablegraphBreadthFirst(
        scip: *mut SCIP,
        vargraph: *mut SCIP_VGRAPH,
        startvars: *mut *mut SCIP_VAR,
        nstartvars: ::std::os::raw::c_int,
        distances: *mut ::std::os::raw::c_int,
        maxdistance: ::std::os::raw::c_int,
        maxvars: ::std::os::raw::c_int,
        maxbinintvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " initialization method of variable graph data structure"]
    pub fn SCIPvariableGraphCreate(
        scip: *mut SCIP,
        vargraph: *mut *mut SCIP_VGRAPH,
        relaxdenseconss: ::std::os::raw::c_uint,
        relaxdensity: f64,
        nrelaxedconstraints: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " deinitialization method of variable graph data structure"]
    pub fn SCIPvariableGraphFree(scip: *mut SCIP, vargraph: *mut *mut SCIP_VGRAPH);
}
extern "C" {
    pub fn SCIPcomprComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPcomprCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of tree compression"]
    pub fn SCIPcomprGetData(compr: *mut SCIP_COMPR) -> *mut SCIP_COMPRDATA;
}
extern "C" {
    #[doc = " sets user data of tree compression; user has to free old data in advance!"]
    pub fn SCIPcomprSetData(compr: *mut SCIP_COMPR, comprdata: *mut SCIP_COMPRDATA);
}
extern "C" {
    #[doc = " gets name of tree compression"]
    pub fn SCIPcomprGetName(heur: *mut SCIP_COMPR) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of tree compression"]
    pub fn SCIPcomprGetDesc(compr: *mut SCIP_COMPR) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of tree compression"]
    pub fn SCIPcomprGetPriority(compr: *mut SCIP_COMPR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets minimal number of nodes for calling tree compression (returns -1, if no node threshold exists)"]
    pub fn SCIPcomprGetMinNodes(compr: *mut SCIP_COMPR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of times, the compression was called and tried to find a compression"]
    pub fn SCIPcomprGetNCalls(compr: *mut SCIP_COMPR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the number of tree compressions found by this compression"]
    pub fn SCIPcomprGetNFound(compr: *mut SCIP_COMPR) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " is tree compression initialized?"]
    pub fn SCIPcomprIsInitialized(compr: *mut SCIP_COMPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets time in seconds used in this compression for setting up for next stages"]
    pub fn SCIPcomprGetSetupTime(compr: *mut SCIP_COMPR) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this compression"]
    pub fn SCIPcomprGetTime(compr: *mut SCIP_COMPR) -> f64;
}
extern "C" {
    #[doc = " gets the conflict score of the history entry"]
    pub fn SCIPhistoryGetVSIDS(history: *mut SCIP_HISTORY, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " get number of cutoffs counter"]
    pub fn SCIPhistoryGetCutoffSum(history: *mut SCIP_HISTORY, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " return the number of (domain) values for which a history exists"]
    pub fn SCIPvaluehistoryGetNValues(
        valuehistory: *mut SCIP_VALUEHISTORY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " return the array containing the histories for the individual (domain) values"]
    pub fn SCIPvaluehistoryGetHistories(
        valuehistory: *mut SCIP_VALUEHISTORY,
    ) -> *mut *mut SCIP_HISTORY;
}
extern "C" {
    #[doc = " return the array containing the (domain) values for which a history exists"]
    pub fn SCIPvaluehistoryGetValues(valuehistory: *mut SCIP_VALUEHISTORY) -> *mut f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_VBounds {
    _unused: [u8; 0],
}
pub type SCIP_VBOUNDS = SCIP_VBounds;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Implics {
    _unused: [u8; 0],
}
pub type SCIP_IMPLICS = SCIP_Implics;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Clique {
    _unused: [u8; 0],
}
pub type SCIP_CLIQUE = SCIP_Clique;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_CliqueTable {
    _unused: [u8; 0],
}
pub type SCIP_CLIQUETABLE = SCIP_CliqueTable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_CliqueList {
    _unused: [u8; 0],
}
pub type SCIP_CLIQUELIST = SCIP_CliqueList;
extern "C" {
    #[doc = " returns the position of the given variable/value pair in the clique; returns -1 if variable/value pair is not member"]
    #[doc = "  of the clique"]
    pub fn SCIPcliqueSearchVar(
        clique: *mut SCIP_CLIQUE,
        var: *mut SCIP_VAR,
        value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns whether the given variable/value pair is member of the given clique"]
    pub fn SCIPcliqueHasVar(
        clique: *mut SCIP_CLIQUE,
        var: *mut SCIP_VAR,
        value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets number of variables in the cliques"]
    pub fn SCIPcliqueGetNVars(clique: *mut SCIP_CLIQUE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of active problem variables in the cliques"]
    pub fn SCIPcliqueGetVars(clique: *mut SCIP_CLIQUE) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets array of values of active problem variables in the cliques, i.e. whether the variable is fixed to FALSE or"]
    #[doc = "  to TRUE in the clique"]
    pub fn SCIPcliqueGetValues(clique: *mut SCIP_CLIQUE) -> *mut ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets unique identifier of the clique"]
    pub fn SCIPcliqueGetId(clique: *mut SCIP_CLIQUE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets index of the clique in the clique table"]
    pub fn SCIPcliqueGetIndex(clique: *mut SCIP_CLIQUE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns whether the given clique is cleaned up"]
    pub fn SCIPcliqueIsCleanedUp(clique: *mut SCIP_CLIQUE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " return whether the given clique is an equation"]
    pub fn SCIPcliqueIsEquation(clique: *mut SCIP_CLIQUE) -> ::std::os::raw::c_uint;
}
#[doc = "< maximize objective function"]
pub const SCIP_ObjSen_SCIP_OBJSEN_MAXIMIZE: SCIP_ObjSen = -1;
#[doc = "< minimize objective function"]
pub const SCIP_ObjSen_SCIP_OBJSEN_MINIMIZE: SCIP_ObjSen = 1;
#[doc = " objective sense"]
pub type SCIP_ObjSen = ::std::os::raw::c_int;
pub use self::SCIP_ObjSen as SCIP_OBJSEN;
#[doc = "< solver should start from scratch at next call?"]
pub const SCIP_LPParam_SCIP_LPPAR_FROMSCRATCH: SCIP_LPParam = 0;
#[doc = "< fast mip setting of LP solver"]
pub const SCIP_LPParam_SCIP_LPPAR_FASTMIP: SCIP_LPParam = 1;
#[doc = "< should LP solver use scaling?"]
pub const SCIP_LPParam_SCIP_LPPAR_SCALING: SCIP_LPParam = 2;
#[doc = "< should LP solver use presolving?"]
pub const SCIP_LPParam_SCIP_LPPAR_PRESOLVING: SCIP_LPParam = 3;
#[doc = "< pricing strategy"]
pub const SCIP_LPParam_SCIP_LPPAR_PRICING: SCIP_LPParam = 4;
#[doc = "< should LP solver output information to the screen?"]
pub const SCIP_LPParam_SCIP_LPPAR_LPINFO: SCIP_LPParam = 5;
#[doc = "< feasibility tolerance for primal variables and slacks, strictly positive"]
pub const SCIP_LPParam_SCIP_LPPAR_FEASTOL: SCIP_LPParam = 6;
#[doc = "< feasibility tolerance for dual variables and reduced costs, strictly positive"]
pub const SCIP_LPParam_SCIP_LPPAR_DUALFEASTOL: SCIP_LPParam = 7;
#[doc = "< convergence tolerance used in barrier algorithm"]
pub const SCIP_LPParam_SCIP_LPPAR_BARRIERCONVTOL: SCIP_LPParam = 8;
#[doc = "< objective limit (stop if objective is known be larger/smaller than limit for min/max-imization)"]
pub const SCIP_LPParam_SCIP_LPPAR_OBJLIM: SCIP_LPParam = 9;
#[doc = "< LP iteration limit, greater than or equal 0"]
pub const SCIP_LPParam_SCIP_LPPAR_LPITLIM: SCIP_LPParam = 10;
#[doc = "< LP time limit, positive"]
pub const SCIP_LPParam_SCIP_LPPAR_LPTILIM: SCIP_LPParam = 11;
#[doc = "< Markowitz tolerance"]
pub const SCIP_LPParam_SCIP_LPPAR_MARKOWITZ: SCIP_LPParam = 12;
#[doc = "< simplex algorithm shall use row representation of the basis"]
#[doc = "   if number of rows divided by number of columns exceeds this value"]
#[doc = "   (0 <= value or -1 = valu ; if negative, this change never occurs)"]
pub const SCIP_LPParam_SCIP_LPPAR_ROWREPSWITCH: SCIP_LPParam = 13;
#[doc = "< number of threads used to solve the LP"]
pub const SCIP_LPParam_SCIP_LPPAR_THREADS: SCIP_LPParam = 14;
#[doc = "< maximum condition number of LP basis counted as stable"]
pub const SCIP_LPParam_SCIP_LPPAR_CONDITIONLIMIT: SCIP_LPParam = 15;
#[doc = "< type of timer (1 - cpu, 2 - wallclock, 0 - off)"]
pub const SCIP_LPParam_SCIP_LPPAR_TIMING: SCIP_LPParam = 16;
#[doc = "< inital random seed, e.g. for perturbations in the simplex (0: LP default)"]
pub const SCIP_LPParam_SCIP_LPPAR_RANDOMSEED: SCIP_LPParam = 17;
#[doc = "< set solution polishing (0 - disable, 1 - enable)"]
pub const SCIP_LPParam_SCIP_LPPAR_POLISHING: SCIP_LPParam = 18;
#[doc = "< set refactorization interval (0 - automatic)"]
pub const SCIP_LPParam_SCIP_LPPAR_REFACTOR: SCIP_LPParam = 19;
#[doc = " LP solver parameters"]
pub type SCIP_LPParam = ::std::os::raw::c_int;
pub use self::SCIP_LPParam as SCIP_LPPARAM;
#[doc = "< the SCIP/LP interface should use its preferred strategy"]
pub const SCIP_Pricing_SCIP_PRICING_LPIDEFAULT: SCIP_Pricing = 0;
#[doc = "< the LP solver should use its preferred strategy"]
pub const SCIP_Pricing_SCIP_PRICING_AUTO: SCIP_Pricing = 1;
#[doc = "< full pricing"]
pub const SCIP_Pricing_SCIP_PRICING_FULL: SCIP_Pricing = 2;
#[doc = "< partial pricing"]
pub const SCIP_Pricing_SCIP_PRICING_PARTIAL: SCIP_Pricing = 3;
#[doc = "< steepest edge pricing"]
pub const SCIP_Pricing_SCIP_PRICING_STEEP: SCIP_Pricing = 4;
#[doc = "< steepest edge pricing without initial dual norms"]
pub const SCIP_Pricing_SCIP_PRICING_STEEPQSTART: SCIP_Pricing = 5;
#[doc = "< devex pricing"]
pub const SCIP_Pricing_SCIP_PRICING_DEVEX: SCIP_Pricing = 6;
#[doc = " LP pricing strategy"]
pub type SCIP_Pricing = ::std::os::raw::c_int;
pub use self::SCIP_Pricing as SCIP_PRICING;
#[doc = "< (slack) variable is at its lower bound"]
pub const SCIP_BaseStat_SCIP_BASESTAT_LOWER: SCIP_BaseStat = 0;
#[doc = "< (slack) variable is basic"]
pub const SCIP_BaseStat_SCIP_BASESTAT_BASIC: SCIP_BaseStat = 1;
#[doc = "< (slack) variable is at its upper bound"]
pub const SCIP_BaseStat_SCIP_BASESTAT_UPPER: SCIP_BaseStat = 2;
#[doc = "< free variable is non-basic and set to zero"]
pub const SCIP_BaseStat_SCIP_BASESTAT_ZERO: SCIP_BaseStat = 3;
#[doc = " basis status for columns and rows"]
pub type SCIP_BaseStat = ::std::os::raw::c_int;
pub use self::SCIP_BaseStat as SCIP_BASESTAT;
#[doc = "< estimated condition number of (scaled) basis matrix (SCIP_Real)"]
pub const SCIP_LPSolQuality_SCIP_LPSOLQUALITY_ESTIMCONDITION: SCIP_LPSolQuality = 0;
#[doc = "< exact condition number of (scaled) basis matrix (SCIP_Real)"]
pub const SCIP_LPSolQuality_SCIP_LPSOLQUALITY_EXACTCONDITION: SCIP_LPSolQuality = 1;
#[doc = " LP solution quality quantities"]
pub type SCIP_LPSolQuality = ::std::os::raw::c_int;
pub use self::SCIP_LPSolQuality as SCIP_LPSOLQUALITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LPi {
    _unused: [u8; 0],
}
pub type SCIP_LPI = SCIP_LPi;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LPiState {
    _unused: [u8; 0],
}
pub type SCIP_LPISTATE = SCIP_LPiState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_LPiNorms {
    _unused: [u8; 0],
}
pub type SCIP_LPINORMS = SCIP_LPiNorms;
extern "C" {
    #[doc = " sorts column entries such that LP rows precede non-LP rows and inside both parts lower row indices precede higher ones"]
    pub fn SCIPcolSort(col: *mut SCIP_COL);
}
extern "C" {
    #[doc = " gets objective value of column"]
    pub fn SCIPcolGetObj(col: *mut SCIP_COL) -> f64;
}
extern "C" {
    #[doc = " gets lower bound of column"]
    pub fn SCIPcolGetLb(col: *mut SCIP_COL) -> f64;
}
extern "C" {
    #[doc = " gets upper bound of column"]
    pub fn SCIPcolGetUb(col: *mut SCIP_COL) -> f64;
}
extern "C" {
    #[doc = " gets best bound of column with respect to the objective function"]
    pub fn SCIPcolGetBestBound(col: *mut SCIP_COL) -> f64;
}
extern "C" {
    #[doc = " gets the primal LP solution of a column"]
    pub fn SCIPcolGetPrimsol(col: *mut SCIP_COL) -> f64;
}
extern "C" {
    #[doc = " gets the minimal LP solution value, this column ever assumed"]
    pub fn SCIPcolGetMinPrimsol(col: *mut SCIP_COL) -> f64;
}
extern "C" {
    #[doc = " gets the maximal LP solution value, this column ever assumed"]
    pub fn SCIPcolGetMaxPrimsol(col: *mut SCIP_COL) -> f64;
}
extern "C" {
    #[doc = " gets the basis status of a column in the LP solution; only valid for LPs with status SCIP_LPSOLSTAT_OPTIMAL"]
    #[doc = "  and with SCIPisLPSolBasic(scip) == TRUE; returns SCIP_BASESTAT_ZERO for columns not in the current SCIP_LP"]
    pub fn SCIPcolGetBasisStatus(col: *mut SCIP_COL) -> SCIP_BASESTAT;
}
extern "C" {
    #[doc = " gets variable this column represents"]
    pub fn SCIPcolGetVar(col: *mut SCIP_COL) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets unique index of col"]
    pub fn SCIPcolGetIndex(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns whether the associated variable is of integral type (binary, integer, implicit integer)"]
    pub fn SCIPcolIsIntegral(col: *mut SCIP_COL) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff column is removable from the LP (due to aging or cleanup)"]
    pub fn SCIPcolIsRemovable(col: *mut SCIP_COL) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets position of column in current LP, or -1 if it is not in LP"]
    pub fn SCIPcolGetLPPos(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets depth in the tree where the column entered the LP, or -1 if it is not in LP"]
    pub fn SCIPcolGetLPDepth(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns TRUE iff column is member of current LP"]
    pub fn SCIPcolIsInLP(col: *mut SCIP_COL) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " get number of nonzero entries in column vector"]
    pub fn SCIPcolGetNNonz(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of nonzero entries in column vector, that correspond to rows currently in the SCIP_LP;"]
    #[doc = ""]
    #[doc = "  @warning This method is only applicable on columns, that are completely linked to their rows (e.g. a column"]
    #[doc = "  that is in the current LP and the LP was solved, or a column that was in a solved LP and didn't change afterwards"]
    pub fn SCIPcolGetNLPNonz(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array with rows of nonzero entries"]
    pub fn SCIPcolGetRows(col: *mut SCIP_COL) -> *mut *mut SCIP_ROW;
}
extern "C" {
    #[doc = " gets array with coefficients of nonzero entries"]
    pub fn SCIPcolGetVals(col: *mut SCIP_COL) -> *mut f64;
}
extern "C" {
    #[doc = " gets node number of the last node in current branch and bound run, where strong branching was used on the"]
    #[doc = "  given column, or -1 if strong branching was never applied to the column in current run"]
    pub fn SCIPcolGetStrongbranchNode(col: *mut SCIP_COL) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of times, strong branching was applied in current run on the given column"]
    pub fn SCIPcolGetNStrongbranchs(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the age of a column, i.e., the total number of successive times a column was in the LP and was 0.0 in the solution"]
    pub fn SCIPcolGetAge(col: *mut SCIP_COL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets opposite bound type of given bound type"]
    pub fn SCIPboundtypeOpposite(boundtype: SCIP_BOUNDTYPE) -> SCIP_BOUNDTYPE;
}
extern "C" {
    pub fn SCIProwComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " locks an unmodifiable row, which forbids further changes; has no effect on modifiable rows"]
    pub fn SCIProwLock(row: *mut SCIP_ROW);
}
extern "C" {
    #[doc = " unlocks a lock of an unmodifiable row; a row with no sealed lock may be modified; has no effect on modifiable rows"]
    pub fn SCIProwUnlock(row: *mut SCIP_ROW);
}
extern "C" {
    #[doc = " returns the scalar product of the coefficient vectors of the two given rows"]
    pub fn SCIProwGetScalarProduct(row1: *mut SCIP_ROW, row2: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns the degree of parallelism between the hyperplanes defined by the two row vectors v, w:"]
    #[doc = "  p = |v*w|/(|v|*|w|);"]
    #[doc = "  the hyperplanes are parallel, iff p = 1, they are orthogonal, iff p = 0"]
    pub fn SCIProwGetParallelism(
        row1: *mut SCIP_ROW,
        row2: *mut SCIP_ROW,
        orthofunc: ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the degree of orthogonality between the hyperplanes defined by the two row vectors v, w:"]
    #[doc = "  o = 1 - |v*w|/(|v|*|w|);"]
    #[doc = "  the hyperplanes are orthogonal, iff p = 1, they are parallel, iff p = 0"]
    pub fn SCIProwGetOrthogonality(
        row1: *mut SCIP_ROW,
        row2: *mut SCIP_ROW,
        orthofunc: ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    #[doc = " sorts row entries such that LP columns precede non-LP columns and inside both parts lower column indices precede"]
    #[doc = "  higher ones"]
    pub fn SCIProwSort(row: *mut SCIP_ROW);
}
extern "C" {
    #[doc = " get number of nonzero entries in row vector"]
    pub fn SCIProwGetNNonz(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of nonzero entries in row vector, that correspond to columns currently in the SCIP_LP;"]
    #[doc = ""]
    #[doc = "  @warning This method is only applicable on rows, that are completely linked to their columns (e.g. a row"]
    #[doc = "  that is in the current LP and the LP was solved, or a row that was in a solved LP and didn't change afterwards"]
    pub fn SCIProwGetNLPNonz(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array with columns of nonzero entries"]
    pub fn SCIProwGetCols(row: *mut SCIP_ROW) -> *mut *mut SCIP_COL;
}
extern "C" {
    #[doc = " gets array with coefficients of nonzero entries"]
    pub fn SCIProwGetVals(row: *mut SCIP_ROW) -> *mut f64;
}
extern "C" {
    #[doc = " gets constant shift of row"]
    pub fn SCIProwGetConstant(row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " gets Euclidean norm of row vector"]
    pub fn SCIProwGetNorm(row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " gets sum norm of row vector (sum of absolute values of coefficients)"]
    pub fn SCIProwGetSumNorm(row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns the left hand side of the row"]
    pub fn SCIProwGetLhs(row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns the right hand side of the row"]
    pub fn SCIProwGetRhs(row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " gets the dual LP solution of a row"]
    pub fn SCIProwGetDualsol(row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " gets the dual Farkas coefficient of a row in an infeasible LP"]
    pub fn SCIProwGetDualfarkas(row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " gets the basis status of a row in the LP solution; only valid for LPs with status SCIP_LPSOLSTAT_OPTIMAL"]
    #[doc = "  and with SCIPisLPSolBasic(scip) == TRUE; returns SCIP_BASESTAT_BASIC for rows not in the current SCIP_LP"]
    pub fn SCIProwGetBasisStatus(row: *mut SCIP_ROW) -> SCIP_BASESTAT;
}
extern "C" {
    #[doc = " returns the name of the row"]
    pub fn SCIProwGetName(row: *mut SCIP_ROW) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets unique index of row"]
    pub fn SCIProwGetIndex(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets age of row"]
    pub fn SCIProwGetAge(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets rank of row"]
    pub fn SCIProwGetRank(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns TRUE iff the activity of the row (without the row's constant) is always integral in a feasible solution"]
    pub fn SCIProwIsIntegral(row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff row is only valid locally"]
    pub fn SCIProwIsLocal(row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff row is modifiable during node processing (subject to column generation)"]
    pub fn SCIProwIsModifiable(row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff row is removable from the LP (due to aging or cleanup)"]
    pub fn SCIProwIsRemovable(row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns type of origin that created the row"]
    pub fn SCIProwGetOrigintype(row: *mut SCIP_ROW) -> SCIP_ROWORIGINTYPE;
}
extern "C" {
    #[doc = " returns origin constraint handler that created the row (NULL if not available)"]
    pub fn SCIProwGetOriginConshdlr(row: *mut SCIP_ROW) -> *mut SCIP_CONSHDLR;
}
extern "C" {
    #[doc = " returns origin constraint that created the row (NULL if not available)"]
    pub fn SCIProwGetOriginCons(row: *mut SCIP_ROW) -> *mut SCIP_CONS;
}
extern "C" {
    #[doc = " returns origin separator that created the row (NULL if not available)"]
    pub fn SCIProwGetOriginSepa(row: *mut SCIP_ROW) -> *mut SCIP_SEPA;
}
extern "C" {
    #[doc = " returns TRUE iff row is member of the global cut pool"]
    pub fn SCIProwIsInGlobalCutpool(row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets position of row in current LP, or -1 if it is not in LP"]
    pub fn SCIProwGetLPPos(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets depth in the tree where the row entered the LP, or -1 if it is not in LP"]
    pub fn SCIProwGetLPDepth(row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns TRUE iff row is member of current LP"]
    pub fn SCIProwIsInLP(row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the number of times that this row has been sharp in an optimal LP solution"]
    pub fn SCIProwGetActiveLPCount(row: *mut SCIP_ROW) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the number of LPs since this row has been created"]
    pub fn SCIProwGetNLPsAfterCreation(row: *mut SCIP_ROW) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " changes the rank of LP row"]
    pub fn SCIProwChgRank(row: *mut SCIP_ROW, rank: ::std::os::raw::c_int);
}
#[doc = "< SCIP data structures are initialized, no problem exists"]
pub const SCIP_Stage_SCIP_STAGE_INIT: SCIP_Stage = 0;
#[doc = "< the problem is being created and modified"]
pub const SCIP_Stage_SCIP_STAGE_PROBLEM: SCIP_Stage = 1;
#[doc = "< the problem is being transformed into solving data space"]
pub const SCIP_Stage_SCIP_STAGE_TRANSFORMING: SCIP_Stage = 2;
#[doc = "< the problem was transformed into solving data space"]
pub const SCIP_Stage_SCIP_STAGE_TRANSFORMED: SCIP_Stage = 3;
#[doc = "< presolving is initialized"]
pub const SCIP_Stage_SCIP_STAGE_INITPRESOLVE: SCIP_Stage = 4;
#[doc = "< the problem is being presolved"]
pub const SCIP_Stage_SCIP_STAGE_PRESOLVING: SCIP_Stage = 5;
#[doc = "< presolving is exited"]
pub const SCIP_Stage_SCIP_STAGE_EXITPRESOLVE: SCIP_Stage = 6;
#[doc = "< the problem was presolved"]
pub const SCIP_Stage_SCIP_STAGE_PRESOLVED: SCIP_Stage = 7;
#[doc = "< the solving process data is being initialized"]
pub const SCIP_Stage_SCIP_STAGE_INITSOLVE: SCIP_Stage = 8;
#[doc = "< the problem is being solved"]
pub const SCIP_Stage_SCIP_STAGE_SOLVING: SCIP_Stage = 9;
#[doc = "< the problem was solved"]
pub const SCIP_Stage_SCIP_STAGE_SOLVED: SCIP_Stage = 10;
#[doc = "< the solving process data is being freed"]
pub const SCIP_Stage_SCIP_STAGE_EXITSOLVE: SCIP_Stage = 11;
#[doc = "< the transformed problem is being freed"]
pub const SCIP_Stage_SCIP_STAGE_FREETRANS: SCIP_Stage = 12;
#[doc = "< SCIP data structures are being freed"]
pub const SCIP_Stage_SCIP_STAGE_FREE: SCIP_Stage = 13;
#[doc = " SCIP operation stage"]
pub type SCIP_Stage = ::std::os::raw::c_int;
pub use self::SCIP_Stage as SCIP_STAGE;
#[doc = "< undefined setting"]
pub const SCIP_Setting_SCIP_UNDEFINED: SCIP_Setting = 0;
#[doc = "< feature is disabled"]
pub const SCIP_Setting_SCIP_DISABLED: SCIP_Setting = 1;
#[doc = "< feature is set to automatic mode"]
pub const SCIP_Setting_SCIP_AUTO: SCIP_Setting = 2;
#[doc = "< feature is enabled"]
pub const SCIP_Setting_SCIP_ENABLED: SCIP_Setting = 3;
#[doc = " possible settings for enabling/disabling algorithms and other features"]
pub type SCIP_Setting = ::std::os::raw::c_int;
pub use self::SCIP_Setting as SCIP_SETTING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Set {
    _unused: [u8; 0],
}
pub type SCIP_SET = SCIP_Set;
extern "C" {
    #[doc = " returns variables of expression tree"]
    pub fn SCIPexprtreeGetVars(tree: *mut SCIP_EXPRTREE) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " stores array of variables in expression tree"]
    pub fn SCIPexprtreeSetVars(
        tree: *mut SCIP_EXPRTREE,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds variables to the expression tree variables array"]
    pub fn SCIPexprtreeAddVars(
        tree: *mut SCIP_EXPRTREE,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " prints an expression tree using variable names from variables array"]
    pub fn SCIPexprtreePrintWithNames(
        tree: *mut SCIP_EXPRTREE,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " searches the variables array of an expression tree for a variable and returns its position, or -1 if not found"]
    #[doc = " Note that this is an O(n) operation!"]
    pub fn SCIPexprtreeFindVar(
        tree: *mut SCIP_EXPRTREE,
        var: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets constant"]
    pub fn SCIPnlrowGetConstant(nlrow: *mut SCIP_NLROW) -> f64;
}
extern "C" {
    #[doc = " gets number of variables of linear part"]
    pub fn SCIPnlrowGetNLinearVars(nlrow: *mut SCIP_NLROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array with variables of linear part"]
    pub fn SCIPnlrowGetLinearVars(nlrow: *mut SCIP_NLROW) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets array with coefficients in linear part"]
    pub fn SCIPnlrowGetLinearCoefs(nlrow: *mut SCIP_NLROW) -> *mut f64;
}
extern "C" {
    #[doc = " gets number of quadratic variables in quadratic part"]
    pub fn SCIPnlrowGetNQuadVars(nlrow: *mut SCIP_NLROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets quadratic variables in quadratic part"]
    pub fn SCIPnlrowGetQuadVars(nlrow: *mut SCIP_NLROW) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gives position of variable in quadvars array of row, or -1 if not found"]
    pub fn SCIPnlrowSearchQuadVar(
        nlrow: *mut SCIP_NLROW,
        var: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of quadratic elements in quadratic part"]
    pub fn SCIPnlrowGetNQuadElems(nlrow: *mut SCIP_NLROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets quadratic elements in quadratic part"]
    pub fn SCIPnlrowGetQuadElems(nlrow: *mut SCIP_NLROW) -> *mut SCIP_QUADELEM;
}
extern "C" {
    #[doc = " gets array with coefficients in linear part"]
    pub fn SCIPnlrowGetQuadData(
        nlrow: *mut SCIP_NLROW,
        nquadvars: *mut ::std::os::raw::c_int,
        quadvars: *mut *mut *mut SCIP_VAR,
        nquadelems: *mut ::std::os::raw::c_int,
        quadelems: *mut *mut SCIP_QUADELEM,
    );
}
extern "C" {
    #[doc = " gets expression tree"]
    pub fn SCIPnlrowGetExprtree(nlrow: *mut SCIP_NLROW) -> *mut SCIP_EXPRTREE;
}
extern "C" {
    #[doc = " returns the left hand side of a nonlinear row"]
    pub fn SCIPnlrowGetLhs(nlrow: *mut SCIP_NLROW) -> f64;
}
extern "C" {
    #[doc = " returns the right hand side of a nonlinear row"]
    pub fn SCIPnlrowGetRhs(nlrow: *mut SCIP_NLROW) -> f64;
}
extern "C" {
    #[doc = " returns the curvature of a nonlinear row"]
    pub fn SCIPnlrowGetCurvature(nlrow: *mut SCIP_NLROW) -> SCIP_EXPRCURV;
}
extern "C" {
    #[doc = " sets the curvature of a nonlinear row"]
    pub fn SCIPnlrowSetCurvature(nlrow: *mut SCIP_NLROW, curvature: SCIP_EXPRCURV);
}
extern "C" {
    #[doc = " returns the name of a nonlinear row"]
    pub fn SCIPnlrowGetName(nlrow: *mut SCIP_NLROW) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets position of a nonlinear row in current NLP, or -1 if not in NLP"]
    pub fn SCIPnlrowGetNLPPos(nlrow: *mut SCIP_NLROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns TRUE iff row is member of current NLP"]
    pub fn SCIPnlrowIsInNLP(nlrow: *mut SCIP_NLROW) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets the dual NLP solution of a nlrow"]
    #[doc = " for a ranged constraint, the dual value is positive if the right hand side is active and negative if the left hand side is active"]
    pub fn SCIPnlrowGetDualsol(nlrow: *mut SCIP_NLROW) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Matrix {
    _unused: [u8; 0],
}
pub type SCIP_MATRIX = SCIP_Matrix;
extern "C" {
    #[doc = " get column based start pointer of values"]
    pub fn SCIPmatrixGetColValPtr(matrix: *mut SCIP_MATRIX, col: ::std::os::raw::c_int)
        -> *mut f64;
}
extern "C" {
    #[doc = " get column based start pointer of row indices"]
    pub fn SCIPmatrixGetColIdxPtr(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the number of non-zero entries of this column"]
    pub fn SCIPmatrixGetColNNonzs(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of columns of the matrix"]
    pub fn SCIPmatrixGetNColumns(matrix: *mut SCIP_MATRIX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get upper bound of column"]
    pub fn SCIPmatrixGetColUb(matrix: *mut SCIP_MATRIX, col: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " get lower bound of column"]
    pub fn SCIPmatrixGetColLb(matrix: *mut SCIP_MATRIX, col: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " get number of uplocks of column"]
    pub fn SCIPmatrixGetColNUplocks(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of downlocks of column"]
    pub fn SCIPmatrixGetColNDownlocks(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get variable pointer of column"]
    pub fn SCIPmatrixGetVar(matrix: *mut SCIP_MATRIX, col: ::std::os::raw::c_int) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " get name of column/variable"]
    pub fn SCIPmatrixGetColName(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " get row based start pointer of values"]
    pub fn SCIPmatrixGetRowValPtr(matrix: *mut SCIP_MATRIX, row: ::std::os::raw::c_int)
        -> *mut f64;
}
extern "C" {
    #[doc = " get row based start pointer of column indices"]
    pub fn SCIPmatrixGetRowIdxPtr(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of non-zeros of this row"]
    pub fn SCIPmatrixGetRowNNonzs(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get name of row"]
    pub fn SCIPmatrixGetRowName(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " get number of rows of the matrix"]
    pub fn SCIPmatrixGetNRows(matrix: *mut SCIP_MATRIX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get left-hand-side of row"]
    pub fn SCIPmatrixGetRowLhs(matrix: *mut SCIP_MATRIX, row: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " get right-hand-side of row"]
    pub fn SCIPmatrixGetRowRhs(matrix: *mut SCIP_MATRIX, row: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " flag indicating if right-hand-side of row is infinity"]
    pub fn SCIPmatrixIsRowRhsInfinity(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " get number of non-zeros of matrix"]
    pub fn SCIPmatrixGetNNonzs(matrix: *mut SCIP_MATRIX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get minimal activity of row"]
    pub fn SCIPmatrixGetRowMinActivity(matrix: *mut SCIP_MATRIX, row: ::std::os::raw::c_int)
        -> f64;
}
extern "C" {
    #[doc = " get maximal activity of row"]
    pub fn SCIPmatrixGetRowMaxActivity(matrix: *mut SCIP_MATRIX, row: ::std::os::raw::c_int)
        -> f64;
}
extern "C" {
    #[doc = " get number of negative infinities present within minimal activity"]
    pub fn SCIPmatrixGetRowNMinActNegInf(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of positive infinities present within minimal activity"]
    pub fn SCIPmatrixGetRowNMinActPosInf(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of negative infinities present within maximal activity"]
    pub fn SCIPmatrixGetRowNMaxActNegInf(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of positive infinities present within maximal activity"]
    pub fn SCIPmatrixGetRowNMaxActPosInf(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get constraint pointer for constraint representing row"]
    pub fn SCIPmatrixGetCons(
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    ) -> *mut SCIP_CONS;
}
extern "C" {
    #[doc = " get if conflicting uplocks of variable present"]
    pub fn SCIPmatrixUplockConflict(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " get if conflicting downlocks of variable present"]
    pub fn SCIPmatrixDownlockConflict(
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " initialize matrix by copying all check constraints"]
    #[doc = ""]
    #[doc = "  @note Completeness is checked by testing whether all check constraints are from a list of linear constraint handlers"]
    #[doc = "        that can be represented."]
    pub fn SCIPmatrixCreate(
        scip: *mut SCIP,
        matrixptr: *mut *mut SCIP_MATRIX,
        onlyifcomplete: ::std::os::raw::c_uint,
        initialized: *mut ::std::os::raw::c_uint,
        complete: *mut ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        naddconss: *mut ::std::os::raw::c_int,
        ndelconss: *mut ::std::os::raw::c_int,
        nchgcoefs: *mut ::std::os::raw::c_int,
        nchgbds: *mut ::std::os::raw::c_int,
        nfixedvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees the constraint matrix"]
    pub fn SCIPmatrixFree(scip: *mut SCIP, matrix: *mut *mut SCIP_MATRIX);
}
extern "C" {
    #[doc = " print one row of the MIP matrix"]
    pub fn SCIPmatrixPrintRow(
        scip: *mut SCIP,
        matrix: *mut SCIP_MATRIX,
        row: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " detect parallel rows, rhs/lhs are ignored"]
    pub fn SCIPmatrixGetParallelRows(
        scip: *mut SCIP,
        matrix: *mut SCIP_MATRIX,
        scale: *mut f64,
        pclass: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes the bounds of a column and updates the activities accordingly"]
    pub fn SCIPmatrixRemoveColumnBounds(
        scip: *mut SCIP,
        matrix: *mut SCIP_MATRIX,
        col: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " detect parallel columns, obj ignored"]
    pub fn SCIPmatrixGetParallelCols(
        scip: *mut SCIP,
        matrix: *mut SCIP_MATRIX,
        scale: *mut f64,
        pclass: *mut ::std::os::raw::c_int,
        varineq: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " partial sort an index array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an index array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of an array of pointers in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of an array of pointers in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/pointers, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Reals, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Bools, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Bools, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/Reals/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrRealRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/Reals/ints/SCIP_Bools, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrRealRealIntBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/Reals/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrRealRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/Reals/ints/SCIP_Bools, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrRealRealIntBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/Bools, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/Bools, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/Reals, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrRealReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/Reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrRealReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/Reals, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/Reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/Bools, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/Bools, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an array of Reals in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectReal(
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an array of Reals in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedReal(
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/pointers, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Bools/Pointer, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Bools/Pointer, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Longs, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Longs, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Pointer, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Pointer, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort array of ints in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectInt(
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort array of ints in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedInt(
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/pointers, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/reals, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/Longints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/Longints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/Longints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntRealLong(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/Longints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntRealLong(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/pointers, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/reals, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/pointers/reals, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntPtrReal(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/pointers/reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntPtrReal(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/pointers, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/reals, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/pointers/ints/reals, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/pointers/ints/reals, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an array of Longints in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLong(
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an array of Longints in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLong(
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Long/pointer, sorted by the first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Long/pointer, sorted by the first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three arrays of Long/pointer/ints, sorted by the first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three arrays of Long/pointer/ints, sorted by the first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four arrays of Long/pointer/Real/Bool, sorted by the first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four arrays of Long/pointer/Real/Bool, sorted by the first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an index array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an index array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of an array of pointers in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of an array of pointers in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/pointers, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Reals, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Reals, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Bools, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of pointers/Bools, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/Bools, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/Reals/Bools, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/Reals, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of pointers/pointers/Reals, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an array of Reals in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownReal(
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an array of Reals in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownReal(
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/pointers, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Reals/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Bools/Pointer, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Bools/Pointer, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Longs, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Longs, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Pointer, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/ints/Pointer, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/Pointer/Pointer, sorted by first array in non-increasing order around the \\p k-th element"]
    pub fn SCIPselectDownRealRealPtrPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/Reals/Pointer/Pointer, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity"]
    pub fn SCIPselectWeightedDownRealRealPtrPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/pointers, sorted by first array in non-decreasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealPtrPtr(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of Reals/pointers, sorted by first array in non-decreasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealPtrPtr(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort array of ints in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownInt(
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort array of ints in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownInt(
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/pointers, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/reals, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of ints/reals, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/pointers, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/Reals, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three joint arrays of ints/ints/Reals, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/pointers, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/pointers, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/reals, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/ints/ints/reals, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/pointers/ints/Reals, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of ints/pointers/ints/Reals, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an array of Longints in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLong(
        longarray: *mut ::std::os::raw::c_longlong,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort an array of Longints in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLong(
        longarray: *mut ::std::os::raw::c_longlong,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Long/pointer, sorted by the first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of two joint arrays of Long/pointer, sorted by the first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three arrays of Long/pointer/ints, sorted by the first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of three arrays of Long/pointer/ints, sorted by the first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four arrays of Long/pointer/Real/Bool, sorted by the first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four arrays of Long/pointer/Real/Bool, sorted by the first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order around the \\p k-th element,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectDownIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        k: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " partial sort of six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order around the weighted median w.r.t. \\p weights and capacity,"]
    #[doc = "  see \\ref SelectionAlgorithms for more information."]
    pub fn SCIPselectWeightedDownIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        weights: *mut f64,
        capacity: f64,
        len: ::std::os::raw::c_int,
        medianpos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SCIPsortCompInt(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sort an indexed element set in non-decreasing order, resulting in a permutation index array"]
    pub fn SCIPsort(
        perm: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort an index array in non-decreasing order"]
    pub fn SCIPsortInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of an array of pointers in non-decreasing order"]
    pub fn SCIPsortPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of pointers/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of pointers/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointers/Reals/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrRealRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointers/Reals/Reals/ints/SCIP_Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrRealRealIntBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/Reals/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/Reals/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrRealReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointer/pointer/Reals/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort an array of Reals in non-decreasing order"]
    pub fn SCIPsortReal(realarray: *mut f64, len: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " sort of two joint arrays of Reals/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/Bools/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/ints/Longs, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/ints/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort array of ints in non-decreasing order"]
    pub fn SCIPsortInt(intarray: *mut ::std::os::raw::c_int, len: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " sort of two joint arrays of ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/Longints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/Longints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntRealLong(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of ints/pointers/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntPtrReal(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of ints/ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of ints/ints/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of ints/pointers/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort an array of Longints in non-decreasing order"]
    pub fn SCIPsortLong(longarray: *mut ::std::os::raw::c_longlong, len: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " sort of two joint arrays of Long/pointer, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three arrays of Long/pointer/ints, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four arrays of Long/pointer/Real/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of six arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order"]
    pub fn SCIPsortPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order"]
    pub fn SCIPsortIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort an indexed element set in non-increasing order, resulting in a permutation index array"]
    pub fn SCIPsortDown(
        perm: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort an index array in non-increasing order"]
    pub fn SCIPsortDownInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of an array of pointers in non-increasing order"]
    pub fn SCIPsortDownPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of pointers/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of pointers/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of pointers/Bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/Reals/Bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of pointers/pointers/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort an array of Reals in non-increasing order"]
    pub fn SCIPsortDownReal(realarray: *mut f64, len: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " sort of two joint arrays of Reals/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/Bools/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/ints/Longs, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/ints/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/Reals/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealPtrPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of Reals/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortDownRealPtrPtr(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort array of ints in non-increasing order"]
    pub fn SCIPsortDownInt(intarray: *mut ::std::os::raw::c_int, len: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " sort of two joint arrays of ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of two joint arrays of ints/reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three joint arrays of ints/ints/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of ints/ints/ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of ints/ints/ints/reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of ints/pointers/ints/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort an array of Longints in non-increasing order"]
    pub fn SCIPsortDownLong(longarray: *mut ::std::os::raw::c_longlong, len: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " sort of two joint arrays of Long/pointer, sorted by the first array in non-increasing order"]
    pub fn SCIPsortDownLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of three arrays of Long/pointer/ints, sorted by the first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four arrays of Long/pointer/Real/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of six arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " sort of six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order"]
    pub fn SCIPsortDownIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into an index array in non-decreasing order"]
    pub fn SCIPsortedvecInsertInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into an array of pointers in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/pointers sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointers/Reals/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrRealRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointers/Reals/Reals/ints/SCIP_Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrRealRealIntBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/Reals/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/pointers/Ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_longlong,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_longlong,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: f64,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: ::std::os::raw::c_uint,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of Reals/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into an arrays of Reals, sorted in non-decreasing order"]
    pub fn SCIPsortedvecInsertReal(
        realarray: *mut f64,
        keyval: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/ints/Longs, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/ints/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/Reals/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        intval: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        intval1: ::std::os::raw::c_int,
        intval2: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Long/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: ::std::os::raw::c_longlong,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        field4val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        field4val: ::std::os::raw::c_uint,
        field5val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into an array of ints in non-decreasing order"]
    pub fn SCIPsortedvecInsertInt(
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/SCIP_Real/SCIP_Longint, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntRealLong(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: ::std::os::raw::c_int,
        field1val: f64,
        field2val: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntPtrReal(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of ints/ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        field3val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of ints/ints/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        field3val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of ints/pointers/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        field3val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into an array of Longints, sorted in non-decreasing order"]
    pub fn SCIPsortedvecInsertLong(
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of Long/pointer, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Long/pointer/ints, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Long/pointer/Real/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: f64,
        field4val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into six joint arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: f64,
        field4val: ::std::os::raw::c_int,
        field5val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        field3val: ::std::os::raw::c_uint,
        field4val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_uint,
        field4val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecInsertIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_uint,
        field5val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into an index array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into an array of pointers in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of pointers/Bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/Reals/Bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/pointers/Ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of pointers/pointers/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_longlong,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_longlong,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into an array of Reals, sorted in non-increasing order"]
    pub fn SCIPsortedvecInsertDownReal(
        realarray: *mut f64,
        keyval: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: ::std::os::raw::c_uint,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of Reals/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealPtrPtr(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealInt(
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/ints/Longs, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/ints/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: ::std::os::raw::c_int,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/Reals/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Reals/Reals/Pointer/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealPtrPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: *mut ::std::os::raw::c_void,
        field3val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        intval: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        intval1: ::std::os::raw::c_int,
        intval2: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Longs/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: ::std::os::raw::c_longlong,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: f64,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        field4val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: f64,
        field1val: f64,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        field4val: ::std::os::raw::c_uint,
        field5val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into an array of ints in non-increasing order"]
    pub fn SCIPsortedvecInsertDownInt(
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of ints/reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of ints/ints/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of ints/pointers/ints/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        field3val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of ints/int/ints/reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        field3val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of ints/pointers/ints/reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        field3val: f64,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into an array of Longints, sorted in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLong(
        longarray: *mut ::std::os::raw::c_longlong,
        keyval: ::std::os::raw::c_longlong,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into two joint arrays of Long/pointer, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into three joint arrays of Long/pointer/ints, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Long/pointer/Real/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: f64,
        field4val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into six joint arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: f64,
        field3val: f64,
        field4val: ::std::os::raw::c_int,
        field5val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        field3val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        keyval: ::std::os::raw::c_longlong,
        field1val: *mut ::std::os::raw::c_void,
        field2val: *mut ::std::os::raw::c_void,
        field3val: ::std::os::raw::c_uint,
        field4val: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecInsertDownPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        keyval: *mut ::std::os::raw::c_void,
        field1val: ::std::os::raw::c_int,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_uint,
        field4val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " insert a new element into six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-increased order"]
    pub fn SCIPsortedvecInsertDownIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        keyval: ::std::os::raw::c_int,
        field1val: *mut ::std::os::raw::c_void,
        field2val: ::std::os::raw::c_int,
        field3val: ::std::os::raw::c_int,
        field4val: ::std::os::raw::c_uint,
        field5val: ::std::os::raw::c_uint,
        len: *mut ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from an index array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from an array of pointers in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of pointers/RealsReals//ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrRealRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of pointers/RealsReals/ints/SCIP_Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrRealRealIntBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/Reals/Bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/pointers/Ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " deletes the element at the given position from four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " deletes the element at the given position from four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " deletes the element at the given position from four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " deletes the element at the given position from five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Reals/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from an arrays of Reals, sorted in non-decreasing order"]
    pub fn SCIPsortedvecDelPosReal(
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/ints/Longs, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/ints/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Reals/Pointer, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Long/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from an array of ints in non-decreasing order"]
    pub fn SCIPsortedvecDelPosInt(
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/SCIP_Real/SCIP_Longint, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntRealLong(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/pointers/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntPtrReal(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of ints/ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of ints/ints/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of ints/pointers/ints/Reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from an array of Longints, sorted by in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLong(
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Long/pointer, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Long/pointer/int, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Long/pointer/Real/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from six joint arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from an index array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from an array of pointers in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtr(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrReal(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of pointers/Bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrRealInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/Reals/Bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrRealBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/pointers/Ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of pointers/pointers/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrReal(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of pointers/pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of pointers/Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrRealIntInt(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " deletes the element at the given position from four joint arrays of pointer/pointer/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrRealInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " deletes the element at the given position from four joint arrays of pointer/pointer/Reals/bools, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrRealBool(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " deletes the element at the given position from four joint arrays of pointer/pointer/Longs/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrLongInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " deletes the element at the given position from five joint arrays of pointer/pointer/Longs/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrPtrLongIntInt(
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        longarray: *mut ::std::os::raw::c_longlong,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from an array of Reals, sorted in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownReal(
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealBoolPtr(
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Reals/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealPtr(
        realarray: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealInt(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealIntInt(
        realarray: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/ints/Longs, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealIntLong(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/ints/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealIntPtr(
        realarray: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Reals/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Reals/Pointer/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealPtrPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Reals/Reals/Pointer, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealPtrPtr(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/pointers/pointers/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealPtrPtrInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Reals/pointers/pointers/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealPtrPtrIntInt(
        realarray: *mut f64,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Long/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealLongRealInt(
        realarray1: *mut f64,
        longarray: *mut ::std::os::raw::c_longlong,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Reals/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealIntInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Reals/Reals/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealRealInt(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Reals/Reals/Reals/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealRealPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Reals/Reals/Reals/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealRealBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from six joint arrays of Reals/Reals/Reals/Bools/Bools/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownRealRealRealBoolBoolPtr(
        realarray1: *mut f64,
        realarray2: *mut f64,
        realarray3: *mut f64,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from an array of ints in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownInt(
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of ints/reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntReal(
        intarray: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntIntInt(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/SCIP_Longint, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntIntLong(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of ints/ints/Reals, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two joint arrays of ints/pointers, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntPtr(
        intarray: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of ints/ints/ints/pointers, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosDownIntIntIntPtr(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of ints/ints/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosDownIntIntIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of ints/pointers/ints/reals, sorted by first array in non-decreasing order"]
    pub fn SCIPsortedvecDelPosDownIntPtrIntReal(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        realarray: *mut f64,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from an array of Longints, sorted in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLong(
        longarray: *mut ::std::os::raw::c_longlong,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from two arrays of Long/pointer, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtr(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Long/pointer/int, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from three joint arrays of Long/pointer/Real/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Long/pointer/Real/Real/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrRealRealBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        boolarray: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from six joint arrays of Long/pointer/Real/Real/int/Bool, sorted by the first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrRealRealIntBool(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        realarray: *mut f64,
        realarray2: *mut f64,
        intarray: *mut ::std::os::raw::c_int,
        boolarray: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from four joint arrays of Long/pointer/pointer/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrPtrInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Long/pointer/pointer/ints/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrPtrIntInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of Long/pointer/pointer/Bool/ints, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownLongPtrPtrBoolInt(
        longarray: *mut ::std::os::raw::c_longlong,
        ptrarray1: *mut *mut ::std::os::raw::c_void,
        ptrarray2: *mut *mut ::std::os::raw::c_void,
        boolarray: *mut ::std::os::raw::c_uint,
        intarray: *mut ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from five joint arrays of pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownPtrIntIntBoolBool(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray1: *mut ::std::os::raw::c_int,
        intarray2: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " delete the element at the given position from six joint arrays of ints/pointer/ints/ints/Bool/Bool, sorted by first array in non-increasing order"]
    pub fn SCIPsortedvecDelPosDownIntPtrIntIntBoolBool(
        intarray1: *mut ::std::os::raw::c_int,
        ptrarray: *mut *mut ::std::os::raw::c_void,
        intarray2: *mut ::std::os::raw::c_int,
        intarray3: *mut ::std::os::raw::c_int,
        boolarray1: *mut ::std::os::raw::c_uint,
        boolarray2: *mut ::std::os::raw::c_uint,
        pos: ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search."]
    #[doc = "  If the element exists, the method returns TRUE and stores the position of the element in '*pos'."]
    #[doc = "  If the element does not exist, the method returns FALSE and stores the position of the element that follows"]
    #[doc = "  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted."]
    #[doc = "  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        val: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search."]
    #[doc = "  If the element exists, the method returns TRUE and stores the position of the element in '*pos'."]
    #[doc = "  If the element does not exist, the method returns FALSE and stores the position of the element that follows"]
    #[doc = "  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted."]
    #[doc = "  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        val: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search."]
    #[doc = "  If the element exists, the method returns TRUE and stores the position of the element in '*pos'."]
    #[doc = "  If the element does not exist, the method returns FALSE and stores the position of the element that follows"]
    #[doc = "  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted."]
    #[doc = "  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindReal(
        realarray: *mut f64,
        val: f64,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search."]
    #[doc = "  If the element exists, the method returns TRUE and stores the position of the element in '*pos'."]
    #[doc = "  If the element does not exist, the method returns FALSE and stores the position of the element that follows"]
    #[doc = "  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted."]
    #[doc = "  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindInt(
        intarray: *mut ::std::os::raw::c_int,
        val: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search."]
    #[doc = "  If the element exists, the method returns TRUE and stores the position of the element in '*pos'."]
    #[doc = "  If the element does not exist, the method returns FALSE and stores the position of the element that follows"]
    #[doc = "  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted."]
    #[doc = "  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindLong(
        longarray: *mut ::std::os::raw::c_longlong,
        val: ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search."]
    #[doc = "  If the element exists, the method returns TRUE and stores the position of the element in '*pos'."]
    #[doc = "  If the element does not exist, the method returns FALSE and stores the position of the element that follows"]
    #[doc = "  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted."]
    #[doc = "  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindDownInd(
        indarray: *mut ::std::os::raw::c_int,
        indcomp: ::std::option::Option<
            unsafe extern "C" fn(
                dataptr: *mut ::std::os::raw::c_void,
                ind1: ::std::os::raw::c_int,
                ind2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        dataptr: *mut ::std::os::raw::c_void,
        val: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search."]
    #[doc = "  If the element exists, the method returns TRUE and stores the position of the element in '*pos'."]
    #[doc = "  If the element does not exist, the method returns FALSE and stores the position of the element that follows"]
    #[doc = "  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted."]
    #[doc = "  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindDownPtr(
        ptrarray: *mut *mut ::std::os::raw::c_void,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        val: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search."]
    #[doc = "  If the element exists, the method returns TRUE and stores the position of the element in '*pos'."]
    #[doc = "  If the element does not exist, the method returns FALSE and stores the position of the element that follows"]
    #[doc = "  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted."]
    #[doc = "  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindDownReal(
        realarray: *mut f64,
        val: f64,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search."]
    #[doc = "  If the element exists, the method returns TRUE and stores the position of the element in '*pos'."]
    #[doc = "  If the element does not exist, the method returns FALSE and stores the position of the element that follows"]
    #[doc = "  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted."]
    #[doc = "  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindDownInt(
        intarray: *mut ::std::os::raw::c_int,
        val: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Finds the position at which 'val' is located in the sorted vector by binary search."]
    #[doc = "  If the element exists, the method returns TRUE and stores the position of the element in '*pos'."]
    #[doc = "  If the element does not exist, the method returns FALSE and stores the position of the element that follows"]
    #[doc = "  'val' in the ordering in '*pos', i.e., '*pos' is the position at which 'val' would be inserted."]
    #[doc = "  Note that if the element is not found, '*pos' may be equal to len if all existing elements are smaller than 'val'."]
    pub fn SCIPsortedvecFindDownLong(
        longarray: *mut ::std::os::raw::c_longlong,
        val: ::std::os::raw::c_longlong,
        len: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the right-hand side of an arbitrary SCIP constraint that can be represented as a single linear constraint"]
    #[doc = ""]
    #[doc = "  @note The success pointer indicates if the individual contraint handler was able to return the involved values"]
    pub fn SCIPconsGetRhs(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        success: *mut ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the left-hand side of an arbitrary SCIP constraint that can be represented as a single linear constraint"]
    #[doc = ""]
    #[doc = "  @note The success pointer indicates if the individual contraint handler was able to return the involved values"]
    pub fn SCIPconsGetLhs(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        success: *mut ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the value array of an arbitrary SCIP constraint that can be represented as a single linear constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @note The success pointer indicates if the individual contraint handler was able to return the involved values"]
    pub fn SCIPgetConsVals(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        vals: *mut f64,
        varssize: ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the dual farkas solution of an arbitrary SCIP constraint that can be represented as a single linear constraint"]
    #[doc = ""]
    #[doc = "  @note The success pointer indicates if the individual contraint handler was able to return the dual farkas solution"]
    pub fn SCIPconsGetDualfarkas(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        dualfarkas: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns the dual solution of an arbitrary SCIP constraint that can be represented as a single linear constraint"]
    #[doc = ""]
    #[doc = "  @note The success pointer indicates if the individual contraint handler was able to return the dual solution"]
    pub fn SCIPconsGetDualsol(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        dualsol: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns the row of an arbitrary SCIP constraint that can be represented as a single linear constraint"]
    #[doc = "  or NULL of no row is awailable"]
    pub fn SCIPconsGetRow(scip: *mut SCIP, cons: *mut SCIP_CONS) -> *mut SCIP_ROW;
}
extern "C" {
    #[doc = " adds the given variable to the input constraint."]
    #[doc = "  If the constraint is setppc or logicor the value is ignored. If the constraint is knapsack, then the value is"]
    #[doc = "  converted to an int. A warning is passed if the SCIP_Real is not an integer."]
    #[doc = "  TODO: Allow val to be a pointer."]
    pub fn SCIPconsAddCoef(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get critical value of a Student-T distribution for a given number of degrees of freedom at a confidence level"]
    pub fn SCIPstudentTGetCriticalValue(
        clevel: SCIP_CONFIDENCELEVEL,
        df: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " compute a t-value for the hypothesis that x and y are from the same population; Assuming that"]
    #[doc = "  x and y represent normally distributed random samples with equal variance, the returned value"]
    #[doc = "  comes from a Student-T distribution with countx + county - 2 degrees of freedom; this"]
    #[doc = "  value can be compared with a critical value (see also SCIPstudentTGetCriticalValue()) at"]
    #[doc = "  a predefined confidence level for checking if x and y significantly differ in location"]
    pub fn SCIPcomputeTwoSampleTTestValue(
        meanx: f64,
        meany: f64,
        variancex: f64,
        variancey: f64,
        countx: f64,
        county: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the value of the Gauss error function evaluated at a given point"]
    pub fn SCIPerf(x: f64) -> f64;
}
extern "C" {
    #[doc = " get critical value of a standard normal distribution  at a given confidence level"]
    pub fn SCIPnormalGetCriticalValue(clevel: SCIP_CONFIDENCELEVEL) -> f64;
}
extern "C" {
    #[doc = " calculates the cumulative distribution P(-infinity <= x <= value) that a normally distributed"]
    #[doc = "  random variable x takes a value between -infinity and parameter \\p value."]
    #[doc = ""]
    #[doc = "  The distribution is given by the respective mean and deviation. This implementation"]
    #[doc = "  uses the error function erf()."]
    pub fn SCIPnormalCDF(mean: f64, variance: f64, value: f64) -> f64;
}
extern "C" {
    #[doc = " returns the number of observations of this regression"]
    pub fn SCIPregressionGetNObservations(
        regression: *mut SCIP_REGRESSION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " return the current slope of the regression"]
    pub fn SCIPregressionGetSlope(regression: *mut SCIP_REGRESSION) -> f64;
}
extern "C" {
    #[doc = " get the current y-intercept of the regression"]
    pub fn SCIPregressionGetIntercept(regression: *mut SCIP_REGRESSION) -> f64;
}
extern "C" {
    #[doc = " removes an observation (x,y) from the regression"]
    pub fn SCIPregressionRemoveObservation(regression: *mut SCIP_REGRESSION, x: f64, y: f64);
}
extern "C" {
    #[doc = " update regression by a new observation (x,y)"]
    pub fn SCIPregressionAddObservation(regression: *mut SCIP_REGRESSION, x: f64, y: f64);
}
extern "C" {
    #[doc = " reset regression data structure"]
    pub fn SCIPregressionReset(regression: *mut SCIP_REGRESSION);
}
extern "C" {
    #[doc = " creates and resets a regression"]
    pub fn SCIPregressionCreate(regression: *mut *mut SCIP_REGRESSION) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a regression"]
    pub fn SCIPregressionFree(regression: *mut *mut SCIP_REGRESSION);
}
extern "C" {
    #[doc = " writes a node section to the given graph file"]
    pub fn SCIPgmlWriteNode(
        file: *mut FILE,
        id: ::std::os::raw::c_uint,
        label: *const ::std::os::raw::c_char,
        nodetype: *const ::std::os::raw::c_char,
        fillcolor: *const ::std::os::raw::c_char,
        bordercolor: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " writes a node section including weight to the given graph file"]
    pub fn SCIPgmlWriteNodeWeight(
        file: *mut FILE,
        id: ::std::os::raw::c_uint,
        label: *const ::std::os::raw::c_char,
        nodetype: *const ::std::os::raw::c_char,
        fillcolor: *const ::std::os::raw::c_char,
        bordercolor: *const ::std::os::raw::c_char,
        weight: f64,
    );
}
extern "C" {
    #[doc = " writes an edge section to the given graph file"]
    pub fn SCIPgmlWriteEdge(
        file: *mut FILE,
        source: ::std::os::raw::c_uint,
        target: ::std::os::raw::c_uint,
        label: *const ::std::os::raw::c_char,
        color: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " writes an arc section to the given graph file"]
    pub fn SCIPgmlWriteArc(
        file: *mut FILE,
        source: ::std::os::raw::c_uint,
        target: ::std::os::raw::c_uint,
        label: *const ::std::os::raw::c_char,
        color: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " writes the starting line to a GML graph file, does not open a file"]
    pub fn SCIPgmlWriteOpening(file: *mut FILE, directed: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " writes the ending lines to a GML graph file, does not close a file"]
    pub fn SCIPgmlWriteClosing(file: *mut FILE);
}
extern "C" {
    #[doc = " creates a sparse solution"]
    pub fn SCIPsparseSolCreate(
        sparsesol: *mut *mut SCIP_SPARSESOL,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        cleared: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees sparse solution"]
    pub fn SCIPsparseSolFree(sparsesol: *mut *mut SCIP_SPARSESOL);
}
extern "C" {
    #[doc = " returns the variables in the given sparse solution"]
    pub fn SCIPsparseSolGetVars(sparsesol: *mut SCIP_SPARSESOL) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " returns the number of variables in the given sparse solution"]
    pub fn SCIPsparseSolGetNVars(sparsesol: *mut SCIP_SPARSESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the the lower bound array for all variables for a given sparse solution"]
    pub fn SCIPsparseSolGetLbs(sparsesol: *mut SCIP_SPARSESOL) -> *mut ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the the upper bound array for all variables for a given sparse solution"]
    pub fn SCIPsparseSolGetUbs(sparsesol: *mut SCIP_SPARSESOL) -> *mut ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " constructs the first solution of sparse solution (all variables are set to their lower bound value"]
    pub fn SCIPsparseSolGetFirstSol(
        sparsesol: *mut SCIP_SPARSESOL,
        sol: *mut ::std::os::raw::c_longlong,
        nvars: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " constructs the next solution of the sparse solution and return whether there was one more or not"]
    pub fn SCIPsparseSolGetNextSol(
        sparsesol: *mut SCIP_SPARSESOL,
        sol: *mut ::std::os::raw::c_longlong,
        nvars: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " creates a (circular) queue, best used if the size will be fixed or will not be increased that much"]
    pub fn SCIPqueueCreate(
        queue: *mut *mut SCIP_QUEUE,
        initsize: ::std::os::raw::c_int,
        sizefac: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees queue, but not the data elements themselves"]
    pub fn SCIPqueueFree(queue: *mut *mut SCIP_QUEUE);
}
extern "C" {
    #[doc = " clears the queue, but doesn't free the data elements themselves"]
    pub fn SCIPqueueClear(queue: *mut SCIP_QUEUE);
}
extern "C" {
    #[doc = " inserts pointer element at the end of the queue"]
    pub fn SCIPqueueInsert(
        queue: *mut SCIP_QUEUE,
        elem: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " inserts unsigned integer element at the end of the queue"]
    pub fn SCIPqueueInsertUInt(
        queue: *mut SCIP_QUEUE,
        elem: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes and returns the first element of the queue, or NULL if no element exists"]
    pub fn SCIPqueueRemove(queue: *mut SCIP_QUEUE) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " removes and returns the first unsigned integer element of the queue, or UNIT_MAX if no element exists"]
    pub fn SCIPqueueRemoveUInt(queue: *mut SCIP_QUEUE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the first element of the queue without removing it, or NULL if no element exists"]
    pub fn SCIPqueueFirst(queue: *mut SCIP_QUEUE) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " returns the first unsigned integer element of the queue without removing it, or UINT_MAX if no element exists"]
    pub fn SCIPqueueFirstUInt(queue: *mut SCIP_QUEUE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the queue is empty"]
    pub fn SCIPqueueIsEmpty(queue: *mut SCIP_QUEUE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the number of elements in the queue"]
    pub fn SCIPqueueNElems(queue: *mut SCIP_QUEUE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates priority queue"]
    pub fn SCIPpqueueCreate(
        pqueue: *mut *mut SCIP_PQUEUE,
        initsize: ::std::os::raw::c_int,
        sizefac: f64,
        ptrcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        elemchgpos: ::std::option::Option<
            unsafe extern "C" fn(
                elem: *mut ::std::os::raw::c_void,
                oldpos: ::std::os::raw::c_int,
                newpos: ::std::os::raw::c_int,
            ),
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees priority queue, but not the data elements themselves"]
    pub fn SCIPpqueueFree(pqueue: *mut *mut SCIP_PQUEUE);
}
extern "C" {
    #[doc = " clears the priority queue, but doesn't free the data elements themselves"]
    pub fn SCIPpqueueClear(pqueue: *mut SCIP_PQUEUE);
}
extern "C" {
    #[doc = " inserts element into priority queue"]
    pub fn SCIPpqueueInsert(
        pqueue: *mut SCIP_PQUEUE,
        elem: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " delete element at specified position, maintaining the heap property"]
    pub fn SCIPpqueueDelPos(pqueue: *mut SCIP_PQUEUE, pos: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " removes and returns best element from the priority queue"]
    pub fn SCIPpqueueRemove(pqueue: *mut SCIP_PQUEUE) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " returns the best element of the queue without removing it"]
    pub fn SCIPpqueueFirst(pqueue: *mut SCIP_PQUEUE) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " returns the number of elements in the queue"]
    pub fn SCIPpqueueNElems(pqueue: *mut SCIP_PQUEUE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the elements of the queue; changing the returned array may destroy the queue's ordering!"]
    pub fn SCIPpqueueElems(pqueue: *mut SCIP_PQUEUE) -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " return the position of @p elem in the priority queue, or -1 if element is not found"]
    pub fn SCIPpqueueFind(
        pqueue: *mut SCIP_PQUEUE,
        elem: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates a hash table"]
    pub fn SCIPhashtableCreate(
        hashtable: *mut *mut SCIP_HASHTABLE,
        blkmem: *mut BMS_BLKMEM,
        tablesize: ::std::os::raw::c_int,
        hashgetkey: ::std::option::Option<
            unsafe extern "C" fn(
                userptr: *mut ::std::os::raw::c_void,
                elem: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        hashkeyeq: ::std::option::Option<
            unsafe extern "C" fn(
                userptr: *mut ::std::os::raw::c_void,
                key1: *mut ::std::os::raw::c_void,
                key2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_uint,
        >,
        hashkeyval: ::std::option::Option<
            unsafe extern "C" fn(
                userptr: *mut ::std::os::raw::c_void,
                key: *mut ::std::os::raw::c_void,
            ) -> u64,
        >,
        userptr: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees the hash table"]
    pub fn SCIPhashtableFree(hashtable: *mut *mut SCIP_HASHTABLE);
}
extern "C" {
    #[doc = " removes all elements of the hash table"]
    #[doc = ""]
    #[doc = "  @note From a performance point of view you should not fill and clear a hash table too often since the clearing can"]
    #[doc = "        be expensive. Clearing is done by looping over all buckets and removing the hash table lists one-by-one."]
    #[doc = ""]
    #[doc = "  @deprecated Please use SCIPhashtableRemoveAll()"]
    pub fn SCIPhashtableClear(hashtable: *mut SCIP_HASHTABLE);
}
extern "C" {
    #[doc = " inserts element in hash table (multiple inserts of same element override the previous entry)"]
    pub fn SCIPhashtableInsert(
        hashtable: *mut SCIP_HASHTABLE,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " inserts element in hash table (multiple insertion of same element is checked and results in an error)"]
    pub fn SCIPhashtableSafeInsert(
        hashtable: *mut SCIP_HASHTABLE,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " retrieve element with key from hash table, returns NULL if not existing"]
    pub fn SCIPhashtableRetrieve(
        hashtable: *mut SCIP_HASHTABLE,
        key: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " returns whether the given element exists in the table"]
    pub fn SCIPhashtableExists(
        hashtable: *mut SCIP_HASHTABLE,
        element: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " removes element from the hash table, if it exists"]
    pub fn SCIPhashtableRemove(
        hashtable: *mut SCIP_HASHTABLE,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes all elements of the hash table"]
    pub fn SCIPhashtableRemoveAll(hashtable: *mut SCIP_HASHTABLE);
}
extern "C" {
    #[doc = " returns number of hash table elements"]
    pub fn SCIPhashtableGetNElements(hashtable: *mut SCIP_HASHTABLE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gives the number of entries in the internal arrays of a hash table"]
    pub fn SCIPhashtableGetNEntries(hashtable: *mut SCIP_HASHTABLE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives the element at the given index or NULL if entry at that index has no element"]
    pub fn SCIPhashtableGetEntry(
        hashtable: *mut SCIP_HASHTABLE,
        entryidx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " returns the load of the given hash table in percentage"]
    pub fn SCIPhashtableGetLoad(hashtable: *mut SCIP_HASHTABLE) -> f64;
}
extern "C" {
    #[doc = " prints statistics about hash table usage"]
    pub fn SCIPhashtablePrintStatistics(
        hashtable: *mut SCIP_HASHTABLE,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
    );
}
extern "C" {
    #[doc = " returns a reasonable hash table size (a prime number) that is at least as large as the specified value"]
    pub fn SCIPcalcMultihashSize(minsize: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates a multihash table"]
    pub fn SCIPmultihashCreate(
        multihash: *mut *mut SCIP_MULTIHASH,
        blkmem: *mut BMS_BLKMEM,
        tablesize: ::std::os::raw::c_int,
        hashgetkey: ::std::option::Option<
            unsafe extern "C" fn(
                userptr: *mut ::std::os::raw::c_void,
                elem: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void,
        >,
        hashkeyeq: ::std::option::Option<
            unsafe extern "C" fn(
                userptr: *mut ::std::os::raw::c_void,
                key1: *mut ::std::os::raw::c_void,
                key2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_uint,
        >,
        hashkeyval: ::std::option::Option<
            unsafe extern "C" fn(
                userptr: *mut ::std::os::raw::c_void,
                key: *mut ::std::os::raw::c_void,
            ) -> u64,
        >,
        userptr: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees the multihash table"]
    pub fn SCIPmultihashFree(multihash: *mut *mut SCIP_MULTIHASH);
}
extern "C" {
    #[doc = " inserts element in multihash table (multiple inserts of same element possible)"]
    #[doc = ""]
    #[doc = "  @note A pointer to a multihashlist returned by SCIPmultihashRetrieveNext() might get invalid when adding an element"]
    #[doc = "        to the hash table, due to dynamic resizing."]
    pub fn SCIPmultihashInsert(
        multihash: *mut SCIP_MULTIHASH,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " inserts element in multihash table (multiple insertion of same element is checked and results in an error)"]
    #[doc = ""]
    #[doc = "  @note A pointer to a multihashlist returned by SCIPmultihashRetrieveNext() might get invalid when adding a new"]
    #[doc = "        element to the multihash table, due to dynamic resizing."]
    pub fn SCIPmultihashSafeInsert(
        multihash: *mut SCIP_MULTIHASH,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " retrieve element with key from multihash table, returns NULL if not existing"]
    pub fn SCIPmultihashRetrieve(
        multihash: *mut SCIP_MULTIHASH,
        key: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " retrieve element with key from multihash table, returns NULL if not existing"]
    #[doc = "  can be used to retrieve all entries with the same key (one-by-one)"]
    #[doc = ""]
    #[doc = "  @note The returned multimultihashlist pointer might get invalid when adding a new element to the multihash table."]
    pub fn SCIPmultihashRetrieveNext(
        multihash: *mut SCIP_MULTIHASH,
        multihashlist: *mut *mut SCIP_MULTIHASHLIST,
        key: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " returns whether the given element exists in the multihash table"]
    pub fn SCIPmultihashExists(
        multihash: *mut SCIP_MULTIHASH,
        element: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " removes element from the multihash table, if it exists"]
    pub fn SCIPmultihashRemove(
        multihash: *mut SCIP_MULTIHASH,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes all elements of the multihash table"]
    #[doc = ""]
    #[doc = "  @note From a performance point of view you should not fill and clear a hash table too often since the clearing can"]
    #[doc = "        be expensive. Clearing is done by looping over all buckets and removing the hash table lists one-by-one."]
    pub fn SCIPmultihashRemoveAll(multihash: *mut SCIP_MULTIHASH);
}
extern "C" {
    #[doc = " returns number of multihash table elements"]
    pub fn SCIPmultihashGetNElements(multihash: *mut SCIP_MULTIHASH) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the load of the given multihash table in percentage"]
    pub fn SCIPmultihashGetLoad(multihash: *mut SCIP_MULTIHASH) -> f64;
}
extern "C" {
    #[doc = " prints statistics about multihash table usage"]
    pub fn SCIPmultihashPrintStatistics(
        multihash: *mut SCIP_MULTIHASH,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
    );
}
extern "C" {
    pub fn SCIPhashKeyEqString(
        userptr: *mut ::std::os::raw::c_void,
        key1: *mut ::std::os::raw::c_void,
        key2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPhashKeyValString(
        userptr: *mut ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_void,
    ) -> u64;
}
extern "C" {
    pub fn SCIPhashGetKeyStandard(
        userptr: *mut ::std::os::raw::c_void,
        elem: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SCIPhashKeyEqPtr(
        userptr: *mut ::std::os::raw::c_void,
        key1: *mut ::std::os::raw::c_void,
        key2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPhashKeyValPtr(
        userptr: *mut ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_void,
    ) -> u64;
}
extern "C" {
    #[doc = " creates a hash map mapping pointers to pointers"]
    pub fn SCIPhashmapCreate(
        hashmap: *mut *mut SCIP_HASHMAP,
        blkmem: *mut BMS_BLKMEM,
        mapsize: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees the hash map"]
    pub fn SCIPhashmapFree(hashmap: *mut *mut SCIP_HASHMAP);
}
extern "C" {
    #[doc = " inserts new origin->image pair in hash map (must not be called for already existing origins!)"]
    pub fn SCIPhashmapInsert(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
        image: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " inserts new origin->image pair in hash map (must not be called for already existing origins!)"]
    pub fn SCIPhashmapInsertInt(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
        image: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " inserts new origin->image pair in hash map (must not be called for already existing origins!)"]
    pub fn SCIPhashmapInsertReal(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
        image: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " retrieves image of given origin from the hash map, or NULL if no image exists"]
    pub fn SCIPhashmapGetImage(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " retrieves image of given origin from the hash map, or INT_MAX if no image exists"]
    pub fn SCIPhashmapGetImageInt(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " retrieves image of given origin from the hash map, or SCIP_INVALID if no image exists"]
    pub fn SCIPhashmapGetImageReal(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
    ) -> f64;
}
extern "C" {
    #[doc = " sets image for given origin in the hash map, either by modifying existing origin->image pair or by appending a"]
    #[doc = "  new origin->image pair"]
    pub fn SCIPhashmapSetImage(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
        image: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets image for given origin in the hash map, either by modifying existing origin->image pair or by appending a"]
    #[doc = "  new origin->image pair"]
    pub fn SCIPhashmapSetImageInt(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
        image: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets image for given origin in the hash map, either by modifying existing origin->image pair or by appending a"]
    #[doc = "  new origin->image pair"]
    pub fn SCIPhashmapSetImageReal(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
        image: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether an image to the given origin exists in the hash map"]
    pub fn SCIPhashmapExists(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " removes origin->image pair from the hash map, if it exists"]
    pub fn SCIPhashmapRemove(
        hashmap: *mut SCIP_HASHMAP,
        origin: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " prints statistics about hash map usage"]
    pub fn SCIPhashmapPrintStatistics(
        hashmap: *mut SCIP_HASHMAP,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
    );
}
extern "C" {
    #[doc = " indicates whether a hash map has no entries"]
    pub fn SCIPhashmapIsEmpty(hashmap: *mut SCIP_HASHMAP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gives the number of elements in a hash map"]
    pub fn SCIPhashmapGetNElements(hashmap: *mut SCIP_HASHMAP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives the number of entries in the internal arrays of a hash map"]
    pub fn SCIPhashmapGetNEntries(hashmap: *mut SCIP_HASHMAP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives the hashmap entry at the given index or NULL if entry has no element"]
    pub fn SCIPhashmapGetEntry(
        hashmap: *mut SCIP_HASHMAP,
        entryidx: ::std::os::raw::c_int,
    ) -> *mut SCIP_HASHMAPENTRY;
}
extern "C" {
    #[doc = " gives the origin of the hashmap entry"]
    pub fn SCIPhashmapEntryGetOrigin(entry: *mut SCIP_HASHMAPENTRY) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " gives the image of the hashmap entry"]
    pub fn SCIPhashmapEntryGetImage(entry: *mut SCIP_HASHMAPENTRY) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " gives the image of the hashmap entry"]
    pub fn SCIPhashmapEntryGetImageInt(entry: *mut SCIP_HASHMAPENTRY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives the image of the hashmap entry"]
    pub fn SCIPhashmapEntryGetImageReal(entry: *mut SCIP_HASHMAPENTRY) -> f64;
}
extern "C" {
    #[doc = " sets pointer image of a hashmap entry"]
    pub fn SCIPhashmapEntrySetImage(
        entry: *mut SCIP_HASHMAPENTRY,
        image: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " sets integer image of a hashmap entry"]
    pub fn SCIPhashmapEntrySetImageInt(entry: *mut SCIP_HASHMAPENTRY, image: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " sets real image of a hashmap entry"]
    pub fn SCIPhashmapEntrySetImageReal(entry: *mut SCIP_HASHMAPENTRY, image: f64);
}
extern "C" {
    #[doc = " removes all entries in a hash map."]
    pub fn SCIPhashmapRemoveAll(hashmap: *mut SCIP_HASHMAP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a hash set of pointers"]
    pub fn SCIPhashsetCreate(
        hashset: *mut *mut SCIP_HASHSET,
        blkmem: *mut BMS_BLKMEM,
        size: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees the hash set"]
    pub fn SCIPhashsetFree(hashset: *mut *mut SCIP_HASHSET, blkmem: *mut BMS_BLKMEM);
}
extern "C" {
    #[doc = " inserts new element into the hash set"]
    pub fn SCIPhashsetInsert(
        hashset: *mut SCIP_HASHSET,
        blkmem: *mut BMS_BLKMEM,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether an element exists in the hash set"]
    pub fn SCIPhashsetExists(
        hashset: *mut SCIP_HASHSET,
        element: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " removes an element from the hash set, if it exists"]
    pub fn SCIPhashsetRemove(
        hashset: *mut SCIP_HASHSET,
        element: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " prints statistics about hash set usage"]
    pub fn SCIPhashsetPrintStatistics(
        hashset: *mut SCIP_HASHSET,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
    );
}
extern "C" {
    #[doc = " indicates whether a hash set has no entries"]
    pub fn SCIPhashsetIsEmpty(hashset: *mut SCIP_HASHSET) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gives the number of elements in a hash set"]
    pub fn SCIPhashsetGetNElements(hashset: *mut SCIP_HASHSET) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives the number of slots of a hash set"]
    pub fn SCIPhashsetGetNSlots(hashset: *mut SCIP_HASHSET) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives the array of hash set slots; contains all elements in indetermined order and may contain NULL values"]
    pub fn SCIPhashsetGetSlots(hashset: *mut SCIP_HASHSET) -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " removes all entries in a hash set."]
    pub fn SCIPhashsetRemoveAll(hashset: *mut SCIP_HASHSET);
}
extern "C" {
    #[doc = " create a resource activity"]
    pub fn SCIPactivityCreate(
        activity: *mut *mut SCIP_RESOURCEACTIVITY,
        var: *mut SCIP_VAR,
        duration: ::std::os::raw::c_int,
        demand: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a resource activity"]
    pub fn SCIPactivityFree(activity: *mut *mut SCIP_RESOURCEACTIVITY);
}
extern "C" {
    #[doc = " returns the start time variable of the resource activity"]
    pub fn SCIPactivityGetVar(activity: *mut SCIP_RESOURCEACTIVITY) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " returns the duration of the resource activity"]
    pub fn SCIPactivityGetDuration(activity: *mut SCIP_RESOURCEACTIVITY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the demand of the resource activity"]
    pub fn SCIPactivityGetDemand(activity: *mut SCIP_RESOURCEACTIVITY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the energy of the resource activity"]
    pub fn SCIPactivityGetEnergy(activity: *mut SCIP_RESOURCEACTIVITY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates resource profile"]
    pub fn SCIPprofileCreate(
        profile: *mut *mut SCIP_PROFILE,
        capacity: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees given resource profile"]
    pub fn SCIPprofileFree(profile: *mut *mut SCIP_PROFILE);
}
extern "C" {
    #[doc = " output of the given resource profile"]
    pub fn SCIPprofilePrint(
        profile: *mut SCIP_PROFILE,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
    );
}
extern "C" {
    #[doc = " returns the capacity of the resource profile"]
    pub fn SCIPprofileGetCapacity(profile: *mut SCIP_PROFILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number time points of the resource profile"]
    pub fn SCIPprofileGetNTimepoints(profile: *mut SCIP_PROFILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the time points of the resource profile"]
    pub fn SCIPprofileGetTimepoints(profile: *mut SCIP_PROFILE) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the loads of the resource profile"]
    pub fn SCIPprofileGetLoads(profile: *mut SCIP_PROFILE) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the time point for given position of the resource profile"]
    pub fn SCIPprofileGetTime(
        profile: *mut SCIP_PROFILE,
        pos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the loads of the resource profile at the given position"]
    pub fn SCIPprofileGetLoad(
        profile: *mut SCIP_PROFILE,
        pos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns if the given time point exists in the resource profile and stores the position of the given time point if it"]
    #[doc = "  exists; otherwise the position of the next smaller existing time point is stored"]
    pub fn SCIPprofileFindLeft(
        profile: *mut SCIP_PROFILE,
        timepoint: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " insert a core into resource profile; if the core is non-empty the resource profile will be updated otherwise nothing"]
    #[doc = "  happens"]
    pub fn SCIPprofileInsertCore(
        profile: *mut SCIP_PROFILE,
        left: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " subtracts the height from the resource profile during core time"]
    pub fn SCIPprofileDeleteCore(
        profile: *mut SCIP_PROFILE,
        left: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " return the earliest possible starting point within the time interval [lb,ub] for a given core (given by its height"]
    #[doc = "  and duration)"]
    pub fn SCIPprofileGetEarliestFeasibleStart(
        profile: *mut SCIP_PROFILE,
        est: ::std::os::raw::c_int,
        lst: ::std::os::raw::c_int,
        duration: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " return the latest possible starting point within the time interval [lb,ub] for a given core (given by its height and"]
    #[doc = "  duration)"]
    pub fn SCIPprofileGetLatestFeasibleStart(
        profile: *mut SCIP_PROFILE,
        lb: ::std::os::raw::c_int,
        ub: ::std::os::raw::c_int,
        duration: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " resize directed graph structure"]
    pub fn SCIPdigraphResize(
        digraph: *mut SCIP_DIGRAPH,
        nnodes: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the sizes of the successor lists for the nodes in a directed graph and allocates memory for the lists"]
    pub fn SCIPdigraphSetSizes(
        digraph: *mut SCIP_DIGRAPH,
        sizes: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees given directed graph structure"]
    pub fn SCIPdigraphFree(digraph: *mut *mut SCIP_DIGRAPH);
}
extern "C" {
    #[doc = " add (directed) arc and a related data to the directed graph structure"]
    #[doc = ""]
    #[doc = "  @note if the arc is already contained, it is added a second time"]
    pub fn SCIPdigraphAddArc(
        digraph: *mut SCIP_DIGRAPH,
        startnode: ::std::os::raw::c_int,
        endnode: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " add (directed) arc to the directed graph structure, if it is not contained, yet"]
    #[doc = ""]
    #[doc = " @note if there already exists an arc from startnode to endnode, the new arc is not added,"]
    #[doc = "       even if its data is different"]
    pub fn SCIPdigraphAddArcSafe(
        digraph: *mut SCIP_DIGRAPH,
        startnode: ::std::os::raw::c_int,
        endnode: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the number of successors to a given value"]
    pub fn SCIPdigraphSetNSuccessors(
        digraph: *mut SCIP_DIGRAPH,
        node: ::std::os::raw::c_int,
        nsuccessors: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the number of nodes of the given digraph"]
    pub fn SCIPdigraphGetNNodes(digraph: *mut SCIP_DIGRAPH) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the node data, or NULL if no data exist"]
    pub fn SCIPdigraphGetNodeData(
        digraph: *mut SCIP_DIGRAPH,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " sets the node data"]
    pub fn SCIPdigraphSetNodeData(
        digraph: *mut SCIP_DIGRAPH,
        dataptr: *mut ::std::os::raw::c_void,
        node: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " returns the total number of arcs in the given digraph"]
    pub fn SCIPdigraphGetNArcs(digraph: *mut SCIP_DIGRAPH) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of successor nodes of the given node"]
    pub fn SCIPdigraphGetNSuccessors(
        digraph: *mut SCIP_DIGRAPH,
        node: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the array of indices of the successor nodes; this array must not be changed from outside"]
    pub fn SCIPdigraphGetSuccessors(
        digraph: *mut SCIP_DIGRAPH,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the array of data corresponding to the arcs originating at the given node, or NULL if no data exist; this"]
    #[doc = "  array must not be changed from outside"]
    pub fn SCIPdigraphGetSuccessorsData(
        digraph: *mut SCIP_DIGRAPH,
        node: ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " identifies the articulation points in a given directed graph"]
    #[doc = "  uses the helper recursive function findArticulationPointsUtil"]
    pub fn SCIPdigraphGetArticulationPoints(
        digraph: *mut SCIP_DIGRAPH,
        articulations: *mut *mut ::std::os::raw::c_int,
        narticulations: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Compute undirected connected components on the given graph."]
    #[doc = ""]
    #[doc = "  @note For each arc, its reverse is added, so the graph does not need to be the directed representation of an"]
    #[doc = "        undirected graph."]
    pub fn SCIPdigraphComputeUndirectedComponents(
        digraph: *mut SCIP_DIGRAPH,
        minsize: ::std::os::raw::c_int,
        components: *mut ::std::os::raw::c_int,
        ncomponents: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Computes all strongly connected components of an undirected connected component with Tarjan's Algorithm."]
    #[doc = "  The resulting strongly connected components are sorted topologically (starting from the end of the"]
    #[doc = "  strongcomponents array)."]
    #[doc = ""]
    #[doc = "  @note In general a topological sort of the strongly connected components is not unique."]
    pub fn SCIPdigraphComputeDirectedComponents(
        digraph: *mut SCIP_DIGRAPH,
        compidx: ::std::os::raw::c_int,
        strongcomponents: *mut ::std::os::raw::c_int,
        strongcompstartidx: *mut ::std::os::raw::c_int,
        nstrongcomponents: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Performes an (almost) topological sort on the undirected components of the given directed graph. The undirected"]
    #[doc = "  components should be computed before using SCIPdigraphComputeUndirectedComponents()."]
    #[doc = ""]
    #[doc = "  @note In general a topological sort is not unique.  Note, that there might be directed cycles, that are randomly"]
    #[doc = "        broken, which is the reason for having only almost topologically sorted arrays."]
    pub fn SCIPdigraphTopoSortComponents(digraph: *mut SCIP_DIGRAPH) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the number of previously computed undirected components for the given directed graph"]
    pub fn SCIPdigraphGetNComponents(digraph: *mut SCIP_DIGRAPH) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the previously computed undirected component of the given number for the given directed graph."]
    #[doc = "  If the components were sorted using SCIPdigraphTopoSortComponents(), the component is (almost) topologically sorted."]
    pub fn SCIPdigraphGetComponent(
        digraph: *mut SCIP_DIGRAPH,
        compidx: ::std::os::raw::c_int,
        nodes: *mut *mut ::std::os::raw::c_int,
        nnodes: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " frees the component information for the given directed graph"]
    pub fn SCIPdigraphFreeComponents(digraph: *mut SCIP_DIGRAPH);
}
extern "C" {
    #[doc = " output of the given directed graph via the given message handler"]
    pub fn SCIPdigraphPrint(
        digraph: *mut SCIP_DIGRAPH,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
    );
}
extern "C" {
    #[doc = " prints the given directed graph structure in GML format into the given file"]
    pub fn SCIPdigraphPrintGml(digraph: *mut SCIP_DIGRAPH, file: *mut FILE);
}
extern "C" {
    #[doc = " output of the given directed graph via the given message handler"]
    pub fn SCIPdigraphPrintComponents(
        digraph: *mut SCIP_DIGRAPH,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
    );
}
extern "C" {
    #[doc = " creates a binary tree node with sorting value and user data"]
    pub fn SCIPbtnodeCreate(
        tree: *mut SCIP_BT,
        node: *mut *mut SCIP_BTNODE,
        dataptr: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees the binary node including the rooted subtree"]
    #[doc = ""]
    #[doc = "  @note The user pointer (object) is not freed. If needed, it has to be done by the user."]
    pub fn SCIPbtnodeFree(tree: *mut SCIP_BT, node: *mut *mut SCIP_BTNODE);
}
extern "C" {
    #[doc = " returns the user data pointer stored in that node"]
    pub fn SCIPbtnodeGetData(node: *mut SCIP_BTNODE) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " returns the parent which can be NULL if the given node is the root"]
    pub fn SCIPbtnodeGetParent(node: *mut SCIP_BTNODE) -> *mut SCIP_BTNODE;
}
extern "C" {
    #[doc = " returns left child which can be NULL if the given node is a leaf"]
    pub fn SCIPbtnodeGetLeftchild(node: *mut SCIP_BTNODE) -> *mut SCIP_BTNODE;
}
extern "C" {
    #[doc = " returns right child which can be NULL if the given node is a leaf"]
    pub fn SCIPbtnodeGetRightchild(node: *mut SCIP_BTNODE) -> *mut SCIP_BTNODE;
}
extern "C" {
    #[doc = " returns the sibling of the node or NULL if does not exist"]
    pub fn SCIPbtnodeGetSibling(node: *mut SCIP_BTNODE) -> *mut SCIP_BTNODE;
}
extern "C" {
    #[doc = " returns whether the node is a root node"]
    pub fn SCIPbtnodeIsRoot(node: *mut SCIP_BTNODE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the node is a leaf"]
    pub fn SCIPbtnodeIsLeaf(node: *mut SCIP_BTNODE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE if the given node is left child"]
    pub fn SCIPbtnodeIsLeftchild(node: *mut SCIP_BTNODE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE if the given node is right child"]
    pub fn SCIPbtnodeIsRightchild(node: *mut SCIP_BTNODE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets the give node data"]
    #[doc = ""]
    #[doc = "  @note The old user pointer is not freed."]
    pub fn SCIPbtnodeSetData(node: *mut SCIP_BTNODE, dataptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " sets parent node"]
    #[doc = ""]
    #[doc = "  @note The old parent including the rooted subtree is not delete."]
    pub fn SCIPbtnodeSetParent(node: *mut SCIP_BTNODE, parent: *mut SCIP_BTNODE);
}
extern "C" {
    #[doc = " sets left child"]
    #[doc = ""]
    #[doc = "  @note The old left child including the rooted subtree is not delete."]
    pub fn SCIPbtnodeSetLeftchild(node: *mut SCIP_BTNODE, left: *mut SCIP_BTNODE);
}
extern "C" {
    #[doc = " sets right child"]
    #[doc = ""]
    #[doc = "  @note The old right child including the rooted subtree is not delete."]
    pub fn SCIPbtnodeSetRightchild(node: *mut SCIP_BTNODE, right: *mut SCIP_BTNODE);
}
extern "C" {
    #[doc = " creates an binary tree"]
    pub fn SCIPbtCreate(tree: *mut *mut SCIP_BT, blkmem: *mut BMS_BLKMEM) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees binary tree"]
    #[doc = ""]
    #[doc = "  @note The user pointers (object) of the search nodes are not freed. If needed, it has to be done by the user."]
    pub fn SCIPbtFree(tree: *mut *mut SCIP_BT);
}
extern "C" {
    #[doc = " prints the binary tree in GML format into the given file"]
    pub fn SCIPbtPrintGml(tree: *mut SCIP_BT, file: *mut FILE);
}
extern "C" {
    #[doc = " returns whether the binary tree is empty (has no nodes)"]
    pub fn SCIPbtIsEmpty(tree: *mut SCIP_BT) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the root node of the binary tree or NULL if the binary tree is empty"]
    pub fn SCIPbtGetRoot(tree: *mut SCIP_BT) -> *mut SCIP_BTNODE;
}
extern "C" {
    #[doc = " sets root node"]
    #[doc = ""]
    #[doc = "  @note The old root including the rooted subtree is not delete."]
    pub fn SCIPbtSetRoot(tree: *mut SCIP_BT, root: *mut SCIP_BTNODE);
}
extern "C" {
    #[doc = " clears the disjoint set (union find) structure \\p djset"]
    pub fn SCIPdisjointsetClear(djset: *mut SCIP_DISJOINTSET);
}
extern "C" {
    #[doc = " finds and returns the component identifier of this \\p element"]
    pub fn SCIPdisjointsetFind(
        djset: *mut SCIP_DISJOINTSET,
        element: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " merges the components containing the elements \\p p and \\p q"]
    pub fn SCIPdisjointsetUnion(
        djset: *mut SCIP_DISJOINTSET,
        p: ::std::os::raw::c_int,
        q: ::std::os::raw::c_int,
        forcerepofp: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns the number of independent components in this disjoint set (union find) data structure"]
    pub fn SCIPdisjointsetGetComponentCount(djset: *mut SCIP_DISJOINTSET) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the size (number of nodes) of this disjoint set (union find) data structure"]
    pub fn SCIPdisjointsetGetSize(djset: *mut SCIP_DISJOINTSET) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the machine epsilon: the smallest number eps > 0, for which 1.0 + eps > 1.0"]
    pub fn SCIPcalcMachineEpsilon() -> f64;
}
extern "C" {
    #[doc = " returns the next representable value of from in the direction of to"]
    pub fn SCIPnextafter(from: f64, to: f64) -> f64;
}
extern "C" {
    #[doc = " calculates the greatest common divisor of the two given values"]
    pub fn SCIPcalcGreComDiv(
        val1: ::std::os::raw::c_longlong,
        val2: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " calculates the smallest common multiple of the two given values"]
    pub fn SCIPcalcSmaComMul(
        val1: ::std::os::raw::c_longlong,
        val2: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " calculates a binomial coefficient n over m, choose m elements out of n, maximal value will be 33 over 16 (because"]
    #[doc = "  the n=33 is the last line in the Pascal's triangle where each entry fits in a 4 byte value), an error occurs due to"]
    #[doc = "  big numbers or an negative value m (and m < n) and -1 will be returned"]
    pub fn SCIPcalcBinomCoef(
        n: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " converts a real number into a (approximate) rational representation, and returns TRUE iff the conversion was"]
    #[doc = "  successful"]
    pub fn SCIPrealToRational(
        val: f64,
        mindelta: f64,
        maxdelta: f64,
        maxdnom: ::std::os::raw::c_longlong,
        nominator: *mut ::std::os::raw::c_longlong,
        denominator: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " tries to find a value, such that all given values, if scaled with this value become integral in relative allowed"]
    #[doc = "  difference in between mindelta and maxdelta"]
    pub fn SCIPcalcIntegralScalar(
        vals: *mut f64,
        nvals: ::std::os::raw::c_int,
        mindelta: f64,
        maxdelta: f64,
        maxdnom: ::std::os::raw::c_longlong,
        maxscale: f64,
        intscalar: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " given a (usually very small) interval, tries to find a rational number with simple denominator (i.e. a small"]
    #[doc = "  number, probably multiplied with powers of 10) out of this interval; returns TRUE iff a valid rational"]
    #[doc = "  number inside the interval was found"]
    pub fn SCIPfindSimpleRational(
        lb: f64,
        ub: f64,
        maxdnom: ::std::os::raw::c_longlong,
        nominator: *mut ::std::os::raw::c_longlong,
        denominator: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " given a (usually very small) interval, selects a value inside this interval; it is tried to select a rational number"]
    #[doc = "  with simple denominator (i.e. a small number, probably multiplied with powers of 10);"]
    #[doc = "  if no valid rational number inside the interval was found, selects the central value of the interval"]
    pub fn SCIPselectSimpleValue(lb: f64, ub: f64, maxdnom: ::std::os::raw::c_longlong) -> f64;
}
extern "C" {
    #[doc = " returns the relative difference: (val1-val2)/max(|val1|,|val2|,1.0)"]
    pub fn SCIPrelDiff(val1: f64, val2: f64) -> f64;
}
extern "C" {
    #[doc = " computes the gap from the primal and the dual bound"]
    pub fn SCIPcomputeGap(eps: f64, inf: f64, primalbound: f64, dualbound: f64) -> f64;
}
extern "C" {
    #[doc = " returns a random integer between minrandval and maxrandval"]
    #[doc = ""]
    #[doc = "  @deprecated Please use SCIPrandomGetInt() to request a random integer."]
    pub fn SCIPgetRandomInt(
        minrandval: ::std::os::raw::c_int,
        maxrandval: ::std::os::raw::c_int,
        seedp: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns a random integer between minrandval and maxrandval"]
    pub fn SCIPrandomGetInt(
        randgen: *mut SCIP_RANDNUMGEN,
        minrandval: ::std::os::raw::c_int,
        maxrandval: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " draws a random subset of disjoint elements from a given set of disjoint elements;"]
    #[doc = "  this implementation is suited for the case that nsubelems is considerably smaller then nelems"]
    pub fn SCIPrandomGetSubset(
        randgen: *mut SCIP_RANDNUMGEN,
        set: *mut *mut ::std::os::raw::c_void,
        nelems: ::std::os::raw::c_int,
        subset: *mut *mut ::std::os::raw::c_void,
        nsubelems: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns a random real between minrandval and maxrandval"]
    pub fn SCIPrandomGetReal(
        randgen: *mut SCIP_RANDNUMGEN,
        minrandval: f64,
        maxrandval: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " returns a random real between minrandval and maxrandval"]
    #[doc = ""]
    #[doc = "  @deprecated Please use SCIPrandomGetReal() to request a random real."]
    pub fn SCIPgetRandomReal(
        minrandval: f64,
        maxrandval: f64,
        seedp: *mut ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " draws a random subset of disjoint elements from a given set of disjoint elements;"]
    #[doc = "  this implementation is suited for the case that nsubelems is considerably smaller then nelems"]
    #[doc = ""]
    #[doc = "  @deprecated Please use SCIPrandomGetSubset()"]
    pub fn SCIPgetRandomSubset(
        set: *mut *mut ::std::os::raw::c_void,
        nelems: ::std::os::raw::c_int,
        subset: *mut *mut ::std::os::raw::c_void,
        nsubelems: ::std::os::raw::c_int,
        randseed: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " swaps two ints"]
    pub fn SCIPswapInts(value1: *mut ::std::os::raw::c_int, value2: *mut ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " swaps two real values"]
    pub fn SCIPswapReals(value1: *mut f64, value2: *mut f64);
}
extern "C" {
    #[doc = " swaps the addresses of two pointers"]
    pub fn SCIPswapPointers(
        pointer1: *mut *mut ::std::os::raw::c_void,
        pointer2: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " randomly shuffles parts of an integer array using the Fisher-Yates algorithm"]
    #[doc = ""]
    #[doc = "  @deprecated Please use SCIPrandomPermuteIntArray()"]
    pub fn SCIPpermuteIntArray(
        array: *mut ::std::os::raw::c_int,
        begin: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
        randseed: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " randomly shuffles parts of an integer array using the Fisher-Yates algorithm"]
    pub fn SCIPrandomPermuteIntArray(
        randgen: *mut SCIP_RANDNUMGEN,
        array: *mut ::std::os::raw::c_int,
        begin: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " randomly shuffles parts of an array using the Fisher-Yates algorithm"]
    pub fn SCIPrandomPermuteArray(
        randgen: *mut SCIP_RANDNUMGEN,
        array: *mut *mut ::std::os::raw::c_void,
        begin: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " randomly shuffles parts of an array using the Fisher-Yates algorithm"]
    #[doc = ""]
    #[doc = "  @deprecated Please use SCIPrandomPermuteArray()"]
    pub fn SCIPpermuteArray(
        array: *mut *mut ::std::os::raw::c_void,
        begin: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
        randseed: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " computes set intersection (duplicates removed) of two arrays that are ordered ascendingly"]
    pub fn SCIPcomputeArraysIntersection(
        array1: *mut ::std::os::raw::c_int,
        narray1: ::std::os::raw::c_int,
        array2: *mut ::std::os::raw::c_int,
        narray2: ::std::os::raw::c_int,
        intersectarray: *mut ::std::os::raw::c_int,
        nintersectarray: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " computes set difference (duplicates removed) of two arrays that are ordered ascendingly"]
    pub fn SCIPcomputeArraysSetminus(
        array1: *mut ::std::os::raw::c_int,
        narray1: ::std::os::raw::c_int,
        array2: *mut ::std::os::raw::c_int,
        narray2: ::std::os::raw::c_int,
        setminusarray: *mut ::std::os::raw::c_int,
        nsetminusarray: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies characters from 'src' to 'dest', copying is stopped when either the 'stop' character is reached or after"]
    #[doc = "  'cnt' characters have been copied, whichever comes first."]
    #[doc = ""]
    #[doc = "  @note undefined behaviuor on overlapping arrays"]
    pub fn SCIPmemccpy(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        stop: ::std::os::raw::c_char,
        cnt: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " prints an error message containing of the given string followed by a string describing the current system error;"]
    #[doc = "  prefers to use the strerror_r method, which is threadsafe; on systems where this method does not exist,"]
    #[doc = "  NO_STRERROR_R should be defined (see INSTALL), in this case, srerror is used which is not guaranteed to be"]
    #[doc = "  threadsafe (on SUN-systems, it actually is)"]
    pub fn SCIPprintSysError(message: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " extracts tokens from strings - wrapper method for strtok_r()"]
    pub fn SCIPstrtok(
        s: *mut ::std::os::raw::c_char,
        delim: *const ::std::os::raw::c_char,
        ptrptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " translates the given string into a string where symbols \", ', and spaces are escaped with a \\ prefix"]
    pub fn SCIPescapeString(
        t: *mut ::std::os::raw::c_char,
        bufsize: ::std::os::raw::c_int,
        s: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " safe version of snprintf"]
    pub fn SCIPsnprintf(
        t: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        s: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " safe version of strncpy"]
    #[doc = ""]
    #[doc = "  Copies string in s to t using at most @a size-1 nonzero characters (strncpy copies size characters). It always adds"]
    #[doc = "  a terminating zero char. Does not pad the remaining string with zero characters (unlike strncpy). Returns the number"]
    #[doc = "  of copied nonzero characters, if the length of s is at most size - 1, and returns size otherwise. Thus, the original"]
    #[doc = "  string was truncated if the return value is size."]
    pub fn SCIPstrncpy(
        t: *mut ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " extract the next token as a integer value if it is one; in case no value is parsed the endptr is set to @p str"]
    #[doc = ""]
    #[doc = "  @return Returns TRUE if a value could be extracted, otherwise FALSE"]
    pub fn SCIPstrToIntValue(
        str_: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " extract the next token as a double value if it is one; in case a value is parsed the endptr is set to @p str"]
    #[doc = ""]
    #[doc = "  @return Returns TRUE if a value could be extracted, otherwise FALSE"]
    pub fn SCIPstrToRealValue(
        str_: *const ::std::os::raw::c_char,
        value: *mut f64,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " copies the first size characters between a start and end character of str into token, if no error occured endptr"]
    #[doc = "  will point to the position after the read part, otherwise it will point to @p str"]
    pub fn SCIPstrCopySection(
        str_: *const ::std::os::raw::c_char,
        startchar: ::std::os::raw::c_char,
        endchar: ::std::os::raw::c_char,
        token: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        endptr: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " returns, whether the given file exists"]
    pub fn SCIPfileExists(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " splits filename into path, name, and extension"]
    pub fn SCIPsplitFilename(
        filename: *mut ::std::os::raw::c_char,
        path: *mut *mut ::std::os::raw::c_char,
        name: *mut *mut ::std::os::raw::c_char,
        extension: *mut *mut ::std::os::raw::c_char,
        compression: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " gets name of node selector"]
    pub fn SCIPnodeselGetName(nodesel: *mut SCIP_NODESEL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of node selector"]
    pub fn SCIPnodeselGetDesc(nodesel: *mut SCIP_NODESEL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of node selector in standard mode"]
    pub fn SCIPnodeselGetStdPriority(nodesel: *mut SCIP_NODESEL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets priority of node selector in memory saving mode"]
    pub fn SCIPnodeselGetMemsavePriority(nodesel: *mut SCIP_NODESEL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of node selector"]
    pub fn SCIPnodeselGetData(nodesel: *mut SCIP_NODESEL) -> *mut SCIP_NODESELDATA;
}
extern "C" {
    #[doc = " sets user data of node selector; user has to free old data in advance!"]
    pub fn SCIPnodeselSetData(nodesel: *mut SCIP_NODESEL, nodeseldata: *mut SCIP_NODESELDATA);
}
extern "C" {
    #[doc = " is node selector initialized?"]
    pub fn SCIPnodeselIsInitialized(nodesel: *mut SCIP_NODESEL) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets time in seconds used in this node selector for setting up for next stages"]
    pub fn SCIPnodeselGetSetupTime(nodesel: *mut SCIP_NODESEL) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this node selector"]
    pub fn SCIPnodeselGetTime(nodesel: *mut SCIP_NODESEL) -> f64;
}
extern "C" {
    #[doc = " returns type of parameter"]
    pub fn SCIPparamGetType(param: *mut SCIP_PARAM) -> SCIP_PARAMTYPE;
}
extern "C" {
    #[doc = " returns name of parameter"]
    pub fn SCIPparamGetName(param: *mut SCIP_PARAM) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns description of parameter"]
    pub fn SCIPparamGetDesc(param: *mut SCIP_PARAM) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns locally defined parameter specific data"]
    pub fn SCIPparamGetData(param: *mut SCIP_PARAM) -> *mut SCIP_PARAMDATA;
}
extern "C" {
    #[doc = " returns whether parameter is advanced"]
    pub fn SCIPparamIsAdvanced(param: *mut SCIP_PARAM) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether parameter is fixed"]
    pub fn SCIPparamIsFixed(param: *mut SCIP_PARAM) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets fixing status of given parameter"]
    pub fn SCIPparamSetFixed(param: *mut SCIP_PARAM, fixed: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " returns value of SCIP_Bool parameter"]
    pub fn SCIPparamGetBool(param: *mut SCIP_PARAM) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns default value of SCIP_Bool parameter"]
    pub fn SCIPparamGetBoolDefault(param: *mut SCIP_PARAM) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns value of int parameter"]
    pub fn SCIPparamGetInt(param: *mut SCIP_PARAM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns minimal value of int parameter"]
    pub fn SCIPparamGetIntMin(param: *mut SCIP_PARAM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns maximal value of int parameter"]
    pub fn SCIPparamGetIntMax(param: *mut SCIP_PARAM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns default value of int parameter"]
    pub fn SCIPparamGetIntDefault(param: *mut SCIP_PARAM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns value of SCIP_Longint parameter"]
    pub fn SCIPparamGetLongint(param: *mut SCIP_PARAM) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns minimal value of longint parameter"]
    pub fn SCIPparamGetLongintMin(param: *mut SCIP_PARAM) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns maximal value of longint parameter"]
    pub fn SCIPparamGetLongintMax(param: *mut SCIP_PARAM) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns default value of SCIP_Longint parameter"]
    pub fn SCIPparamGetLongintDefault(param: *mut SCIP_PARAM) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns value of SCIP_Real parameter"]
    pub fn SCIPparamGetReal(param: *mut SCIP_PARAM) -> f64;
}
extern "C" {
    #[doc = " returns minimal value of real parameter"]
    pub fn SCIPparamGetRealMin(param: *mut SCIP_PARAM) -> f64;
}
extern "C" {
    #[doc = " returns maximal value of real parameter"]
    pub fn SCIPparamGetRealMax(param: *mut SCIP_PARAM) -> f64;
}
extern "C" {
    #[doc = " returns default value of SCIP_Real parameter"]
    pub fn SCIPparamGetRealDefault(param: *mut SCIP_PARAM) -> f64;
}
extern "C" {
    #[doc = " returns value of char parameter"]
    pub fn SCIPparamGetChar(param: *mut SCIP_PARAM) -> ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns allowed values of char parameter, or NULL if everything is allowed"]
    pub fn SCIPparamGetCharAllowedValues(param: *mut SCIP_PARAM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns default value of char parameter"]
    pub fn SCIPparamGetCharDefault(param: *mut SCIP_PARAM) -> ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns value of string parameter"]
    pub fn SCIPparamGetString(param: *mut SCIP_PARAM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns default value of String parameter"]
    pub fn SCIPparamGetStringDefault(param: *mut SCIP_PARAM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns whether the parameter is on its default setting"]
    pub fn SCIPparamIsDefault(param: *mut SCIP_PARAM) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPpresolComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPpresolCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of presolver"]
    pub fn SCIPpresolGetData(presol: *mut SCIP_PRESOL) -> *mut SCIP_PRESOLDATA;
}
extern "C" {
    #[doc = " sets user data of presolver; user has to free old data in advance!"]
    pub fn SCIPpresolSetData(presol: *mut SCIP_PRESOL, presoldata: *mut SCIP_PRESOLDATA);
}
extern "C" {
    #[doc = " gets name of presolver"]
    pub fn SCIPpresolGetName(presol: *mut SCIP_PRESOL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of presolver"]
    pub fn SCIPpresolGetDesc(presol: *mut SCIP_PRESOL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of presolver"]
    pub fn SCIPpresolGetPriority(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets round limit of presolver"]
    pub fn SCIPpresolGetMaxrounds(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the timing mask of the presolver"]
    pub fn SCIPpresolGetTiming(presol: *mut SCIP_PRESOL) -> SCIP_PRESOLTIMING;
}
extern "C" {
    #[doc = " sets the timing mask of the presolver"]
    pub fn SCIPpresolSetTiming(presol: *mut SCIP_PRESOL, timing: SCIP_PRESOLTIMING);
}
extern "C" {
    #[doc = " is presolver initialized?"]
    pub fn SCIPpresolIsInitialized(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets time in seconds used in this presolver for setting up for next stages"]
    pub fn SCIPpresolGetSetupTime(presol: *mut SCIP_PRESOL) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this presolver"]
    pub fn SCIPpresolGetTime(presol: *mut SCIP_PRESOL) -> f64;
}
extern "C" {
    #[doc = " gets number of variables fixed in presolver"]
    pub fn SCIPpresolGetNFixedVars(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of variables aggregated in presolver"]
    pub fn SCIPpresolGetNAggrVars(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of variable types changed in presolver"]
    pub fn SCIPpresolGetNChgVarTypes(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of bounds changed in presolver"]
    pub fn SCIPpresolGetNChgBds(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of holes added to domains of variables in presolver"]
    pub fn SCIPpresolGetNAddHoles(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraints deleted in presolver"]
    pub fn SCIPpresolGetNDelConss(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraints added in presolver"]
    pub fn SCIPpresolGetNAddConss(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraints upgraded in presolver"]
    pub fn SCIPpresolGetNUpgdConss(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of coefficients changed in presolver"]
    pub fn SCIPpresolGetNChgCoefs(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraint sides changed in presolver"]
    pub fn SCIPpresolGetNChgSides(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of times the presolver was called and tried to find reductions"]
    pub fn SCIPpresolGetNCalls(presol: *mut SCIP_PRESOL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPpricerComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPpricerCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of variable pricer"]
    pub fn SCIPpricerGetData(pricer: *mut SCIP_PRICER) -> *mut SCIP_PRICERDATA;
}
extern "C" {
    #[doc = " sets user data of variable pricer; user has to free old data in advance!"]
    pub fn SCIPpricerSetData(pricer: *mut SCIP_PRICER, pricerdata: *mut SCIP_PRICERDATA);
}
extern "C" {
    #[doc = " gets name of variable pricer"]
    pub fn SCIPpricerGetName(pricer: *mut SCIP_PRICER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of variable pricer"]
    pub fn SCIPpricerGetDesc(pricer: *mut SCIP_PRICER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of variable pricer"]
    pub fn SCIPpricerGetPriority(pricer: *mut SCIP_PRICER) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of times, the pricer was called and tried to find a variable with negative reduced costs"]
    pub fn SCIPpricerGetNCalls(pricer: *mut SCIP_PRICER) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of variables with negative reduced costs found by this pricer"]
    pub fn SCIPpricerGetNVarsFound(pricer: *mut SCIP_PRICER) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets time in seconds used in this pricer for setting up for next stages"]
    pub fn SCIPpricerGetSetupTime(pricer: *mut SCIP_PRICER) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this pricer"]
    pub fn SCIPpricerGetTime(pricer: *mut SCIP_PRICER) -> f64;
}
extern "C" {
    #[doc = " returns whether the given pricer is in use in the current problem"]
    pub fn SCIPpricerIsActive(pricer: *mut SCIP_PRICER) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the pricer should be delayed until no other pricer finds a new variable"]
    pub fn SCIPpricerIsDelayed(pricer: *mut SCIP_PRICER) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " is variable pricer initialized?"]
    pub fn SCIPpricerIsInitialized(pricer: *mut SCIP_PRICER) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets user data of reader"]
    pub fn SCIPreaderGetData(reader: *mut SCIP_READER) -> *mut SCIP_READERDATA;
}
extern "C" {
    #[doc = " sets user data of reader; user has to free old data in advance!"]
    pub fn SCIPreaderSetData(reader: *mut SCIP_READER, readerdata: *mut SCIP_READERDATA);
}
extern "C" {
    #[doc = " gets name of reader"]
    pub fn SCIPreaderGetName(reader: *mut SCIP_READER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of reader"]
    pub fn SCIPreaderGetDesc(reader: *mut SCIP_READER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets file extension of reader"]
    pub fn SCIPreaderGetExtension(reader: *mut SCIP_READER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " return whether the reader can read files"]
    pub fn SCIPreaderCanRead(reader: *mut SCIP_READER) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " return whether the reader can write files"]
    pub fn SCIPreaderCanWrite(reader: *mut SCIP_READER) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPrelaxComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPrelaxCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of relaxation handler"]
    pub fn SCIPrelaxGetData(relax: *mut SCIP_RELAX) -> *mut SCIP_RELAXDATA;
}
extern "C" {
    #[doc = " sets user data of relaxation handler; user has to free old data in advance!"]
    pub fn SCIPrelaxSetData(relax: *mut SCIP_RELAX, relaxdata: *mut SCIP_RELAXDATA);
}
extern "C" {
    #[doc = " gets name of relaxation handler"]
    pub fn SCIPrelaxGetName(relax: *mut SCIP_RELAX) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of relaxation handler"]
    pub fn SCIPrelaxGetDesc(relax: *mut SCIP_RELAX) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of relaxation handler"]
    pub fn SCIPrelaxGetPriority(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets frequency of relaxation handler"]
    pub fn SCIPrelaxGetFreq(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets time in seconds used in this relaxator for setting up for next stages"]
    pub fn SCIPrelaxGetSetupTime(relax: *mut SCIP_RELAX) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this relaxation handler"]
    pub fn SCIPrelaxGetTime(relax: *mut SCIP_RELAX) -> f64;
}
extern "C" {
    #[doc = " gets the total number of times the relaxation handler was called"]
    pub fn SCIPrelaxGetNCalls(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of times the relaxation handler cut off a node"]
    pub fn SCIPrelaxGetNCutoffs(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of times the relaxation handler improved a node's lower bound"]
    pub fn SCIPrelaxGetNImprovedLowerbound(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the time in seconds spent for the execution of the relaxation handler when a node's lower bound could be improved (or a cutoff was found)"]
    pub fn SCIPrelaxGetImprovedLowerboundTime(relax: *mut SCIP_RELAX) -> f64;
}
extern "C" {
    #[doc = " gets the total number of times the relaxation handler added constraints"]
    pub fn SCIPrelaxGetNAddedConss(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of times the relaxation handler reduced variable domains"]
    pub fn SCIPrelaxGetNReducedDomains(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of times the relaxation handler separated cutting planes"]
    pub fn SCIPrelaxGetNSeparatedCuts(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " is relaxation handler initialized?"]
    pub fn SCIPrelaxIsInitialized(relax: *mut SCIP_RELAX) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " marks the current relaxation unsolved, s.t. the relaxation handler is called again in the next solving round"]
    pub fn SCIPrelaxMarkUnsolved(relax: *mut SCIP_RELAX);
}
extern "C" {
    #[doc = " returns the number of bound changes stored in the reoptnode"]
    pub fn SCIPreoptnodeGetNVars(reoptnode: *mut SCIP_REOPTNODE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of bound changes at the node stored at ID id"]
    pub fn SCIPreoptnodeGetNConss(reoptnode: *mut SCIP_REOPTNODE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of stored bound changes based on dual information in the reopttree at ID id"]
    pub fn SCIPreoptnodeGetNDualBoundChgs(reoptnode: *mut SCIP_REOPTNODE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of child nodes of @p reoptnode"]
    pub fn SCIPreoptnodeGetNChildren(reoptnode: *mut SCIP_REOPTNODE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPreoptnodeGetLowerbound(reoptnode: *mut SCIP_REOPTNODE) -> f64;
}
extern "C" {
    #[doc = " returns the type of the @p reoptnode"]
    pub fn SCIPreoptnodeGetType(reoptnode: *mut SCIP_REOPTNODE) -> SCIP_REOPTTYPE;
}
extern "C" {
    #[doc = " create the constraint which splits the node stored at ID id on the basis of the stored dual information."]
    pub fn SCIPreoptnodeGetSplitCons(
        reoptnode: *mut SCIP_REOPTNODE,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        constype: *mut REOPT_CONSTYPE,
        conssize: ::std::os::raw::c_int,
        nvars: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " returns all added constraints at ID id"]
    pub fn SCIPreoptnodeGetConss(
        reoptnode: *mut SCIP_REOPTNODE,
        vars: *mut *mut *mut SCIP_VAR,
        bounds: *mut *mut f64,
        boundtypes: *mut *mut SCIP_BOUNDTYPE,
        mem: ::std::os::raw::c_int,
        nconss: *mut ::std::os::raw::c_int,
        nvars: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " set the parent id"]
    pub fn SCIPreoptnodeSetParentID(
        reoptnode: *mut SCIP_REOPTNODE,
        parentid: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns the number of global restarts"]
    pub fn SCIPreoptGetNRestartsGlobal(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of local restarts in the current run"]
    pub fn SCIPreoptGetNRestartsLocal(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of local restarts over all runs"]
    pub fn SCIPreoptGetNTotalRestartsLocal(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of iteration with the first global restarts"]
    pub fn SCIPreoptGetFirstRestarts(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of iteration with the last global restarts"]
    pub fn SCIPreoptGetLastRestarts(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of nodes providing an improving feasible LP solution in the current run"]
    pub fn SCIPreoptGetNFeasNodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of nodes providing an improving feasible LP solution over all runs"]
    pub fn SCIPreoptGetNTotalFeasNodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of nodes that exceeded the cutoff bound in the current run"]
    pub fn SCIPreoptGetNPrunedNodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of nodes that exceeded the cutoff bound over all runs"]
    pub fn SCIPreoptGetNTotalPrunedNodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of reoptimized nodes that were cut off in the current run"]
    pub fn SCIPreoptGetNCutoffReoptnodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of reoptimized nodes that were cut off over all runs"]
    pub fn SCIPreoptGetNTotalCutoffReoptnodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of stored nodes with an infeasible LP in the current run"]
    pub fn SCIPreoptGetNInfNodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of stored nodes with an infeasible LP over all runs"]
    pub fn SCIPreoptGetNTotalInfNodes(reopt: *mut SCIP_REOPT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPsepaComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPsepaCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of separator"]
    pub fn SCIPsepaGetData(sepa: *mut SCIP_SEPA) -> *mut SCIP_SEPADATA;
}
extern "C" {
    #[doc = " sets user data of separator; user has to free old data in advance!"]
    pub fn SCIPsepaSetData(sepa: *mut SCIP_SEPA, sepadata: *mut SCIP_SEPADATA);
}
extern "C" {
    #[doc = " gets name of separator"]
    pub fn SCIPsepaGetName(sepa: *mut SCIP_SEPA) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of separator"]
    pub fn SCIPsepaGetDesc(sepa: *mut SCIP_SEPA) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of separator"]
    pub fn SCIPsepaGetPriority(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets frequency of separator"]
    pub fn SCIPsepaGetFreq(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets frequency of separator"]
    pub fn SCIPsepaSetFreq(sepa: *mut SCIP_SEPA, freq: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " get maximal bound distance at which the separator is called"]
    pub fn SCIPsepaGetMaxbounddist(sepa: *mut SCIP_SEPA) -> f64;
}
extern "C" {
    #[doc = " does the separator use a secondary SCIP instance?"]
    pub fn SCIPsepaUsesSubscip(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets time in seconds used in this separator for setting up for next stages"]
    pub fn SCIPsepaGetSetupTime(sepa: *mut SCIP_SEPA) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this separator"]
    pub fn SCIPsepaGetTime(sepa: *mut SCIP_SEPA) -> f64;
}
extern "C" {
    #[doc = " gets the total number of times, the separator was called"]
    pub fn SCIPsepaGetNCalls(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the number of times, the separator was called at the current node"]
    pub fn SCIPsepaGetNCallsAtNode(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets total number of times, the separator detected a cutoff"]
    pub fn SCIPsepaGetNCutoffs(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of cutting planes found by this separator"]
    pub fn SCIPsepaGetNCutsFound(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of cutting planes applied to lp"]
    pub fn SCIPsepaGetNCutsApplied(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the number of cutting planes found by this separator at the current node"]
    pub fn SCIPsepaGetNCutsFoundAtNode(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of additional constraints added by this separator"]
    pub fn SCIPsepaGetNConssFound(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of domain reductions found by this separator"]
    pub fn SCIPsepaGetNDomredsFound(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " should separator be delayed, if other separators found cuts?"]
    pub fn SCIPsepaIsDelayed(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " was separation of the LP solution delayed at the last call?"]
    pub fn SCIPsepaWasLPDelayed(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " was separation of the primal solution delayed at the last call?"]
    pub fn SCIPsepaWasSolDelayed(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " is separator initialized?"]
    pub fn SCIPsepaIsInitialized(sepa: *mut SCIP_SEPA) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPpropComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPpropCompPresol(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPpropCompName(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets user data of propagator"]
    pub fn SCIPpropGetData(prop: *mut SCIP_PROP) -> *mut SCIP_PROPDATA;
}
extern "C" {
    #[doc = " sets user data of propagator; user has to free old data in advance!"]
    pub fn SCIPpropSetData(prop: *mut SCIP_PROP, propdata: *mut SCIP_PROPDATA);
}
extern "C" {
    #[doc = " gets name of propagator"]
    pub fn SCIPpropGetName(prop: *mut SCIP_PROP) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of propagator"]
    pub fn SCIPpropGetDesc(prop: *mut SCIP_PROP) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets priority of propagator"]
    pub fn SCIPpropGetPriority(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets presolving priority of propagator"]
    pub fn SCIPpropGetPresolPriority(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets frequency of propagator"]
    pub fn SCIPpropGetFreq(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets time in seconds used for setting up this propagator for new stages"]
    pub fn SCIPpropGetSetupTime(prop: *mut SCIP_PROP) -> f64;
}
extern "C" {
    #[doc = " sets frequency of propagator"]
    pub fn SCIPpropSetFreq(prop: *mut SCIP_PROP, freq: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " gets time in seconds used in this propagator"]
    pub fn SCIPpropGetTime(prop: *mut SCIP_PROP) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this propagator during strong branching"]
    pub fn SCIPpropGetStrongBranchPropTime(prop: *mut SCIP_PROP) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this propagator for resolve propagation"]
    pub fn SCIPpropGetRespropTime(prop: *mut SCIP_PROP) -> f64;
}
extern "C" {
    #[doc = " gets time in seconds used in this propagator for presolving"]
    pub fn SCIPpropGetPresolTime(prop: *mut SCIP_PROP) -> f64;
}
extern "C" {
    #[doc = " gets the total number of times, the propagator was called"]
    pub fn SCIPpropGetNCalls(prop: *mut SCIP_PROP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the total number of times, the propagator was called for resolving a propagation"]
    pub fn SCIPpropGetNRespropCalls(prop: *mut SCIP_PROP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of times, this propagator detected a cutoff"]
    pub fn SCIPpropGetNCutoffs(prop: *mut SCIP_PROP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of domain reductions found by this propagator"]
    pub fn SCIPpropGetNDomredsFound(prop: *mut SCIP_PROP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " should propagator be delayed, if other propagators found reductions?"]
    pub fn SCIPpropIsDelayed(prop: *mut SCIP_PROP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " was propagator delayed at the last call?"]
    pub fn SCIPpropWasDelayed(prop: *mut SCIP_PROP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " is propagator initialized?"]
    pub fn SCIPpropIsInitialized(prop: *mut SCIP_PROP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets number of variables fixed during presolving of propagator"]
    pub fn SCIPpropGetNFixedVars(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of variables aggregated during presolving of propagator"]
    pub fn SCIPpropGetNAggrVars(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of variable types changed during presolving of propagator"]
    pub fn SCIPpropGetNChgVarTypes(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of bounds changed during presolving of propagator"]
    pub fn SCIPpropGetNChgBds(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of holes added to domains of variables during presolving of propagator"]
    pub fn SCIPpropGetNAddHoles(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraints deleted during presolving of propagator"]
    pub fn SCIPpropGetNDelConss(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraints added during presolving of propagator"]
    pub fn SCIPpropGetNAddConss(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraints upgraded during presolving of propagator"]
    pub fn SCIPpropGetNUpgdConss(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of coefficients changed during presolving of propagator"]
    pub fn SCIPpropGetNChgCoefs(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of constraint sides changed during presolving of propagator"]
    pub fn SCIPpropGetNChgSides(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of times the propagator was called in presolving and tried to find reductions"]
    pub fn SCIPpropGetNPresolCalls(prop: *mut SCIP_PROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the timing mask of the propagator"]
    pub fn SCIPpropGetTimingmask(prop: *mut SCIP_PROP) -> SCIP_PROPTIMING;
}
extern "C" {
    #[doc = " does the propagator perform presolving?"]
    pub fn SCIPpropDoesPresolve(prop: *mut SCIP_PROP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the timing mask of the presolving method of the propagator"]
    pub fn SCIPpropGetPresolTiming(prop: *mut SCIP_PROP) -> SCIP_PRESOLTIMING;
}
extern "C" {
    #[doc = " sets the timing mask of the presolving method of the propagator"]
    pub fn SCIPpropSetPresolTiming(prop: *mut SCIP_PROP, presoltiming: SCIP_PRESOLTIMING);
}
extern "C" {
    #[doc = " gets origin of solution"]
    pub fn SCIPsolGetOrigin(sol: *mut SCIP_SOL) -> SCIP_SOLORIGIN;
}
extern "C" {
    #[doc = " returns whether the given solution is defined on original variables"]
    pub fn SCIPsolIsOriginal(sol: *mut SCIP_SOL) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the given solution is partial"]
    pub fn SCIPsolIsPartial(sol: *mut SCIP_SOL) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets objective value of primal CIP solution which lives in the original problem space"]
    pub fn SCIPsolGetOrigObj(sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " gets clock time, when this solution was found"]
    pub fn SCIPsolGetTime(sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " gets branch and bound run number, where this solution was found"]
    pub fn SCIPsolGetRunnum(sol: *mut SCIP_SOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets node number of the specific branch and bound run, where this solution was found"]
    pub fn SCIPsolGetNodenum(sol: *mut SCIP_SOL) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets node's depth, where this solution was found"]
    pub fn SCIPsolGetDepth(sol: *mut SCIP_SOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets information if solution was found by the LP, a primal heuristic, or a custom relaxator"]
    pub fn SCIPsolGetType(sol: *mut SCIP_SOL) -> SCIP_SOLTYPE;
}
extern "C" {
    #[doc = " gets heuristic that found this solution, or NULL if solution has type different than SCIP_SOLTYPE_HEUR"]
    pub fn SCIPsolGetHeur(sol: *mut SCIP_SOL) -> *mut SCIP_HEUR;
}
extern "C" {
    #[doc = " gets relaxation handler that found this solution, or NULL if solution has different type than SCIP_SOLTYPE_RELAX"]
    pub fn SCIPsolGetRelax(sol: *mut SCIP_SOL) -> *mut SCIP_RELAX;
}
extern "C" {
    #[doc = " informs the solution that it now belongs to the given primal heuristic. For convenience and backwards compatibility,"]
    #[doc = "  the method accepts NULL as input for \\p heur, in which case the solution type is set to SCIP_SOLTYPE_LPRELAX."]
    #[doc = ""]
    #[doc = "  @note Relaxation handlers should use SCIPsolSetRelax() instead."]
    pub fn SCIPsolSetHeur(sol: *mut SCIP_SOL, heur: *mut SCIP_HEUR);
}
extern "C" {
    #[doc = " informs the solution that it now belongs to the given relaxation handler"]
    pub fn SCIPsolSetRelax(sol: *mut SCIP_SOL, relax: *mut SCIP_RELAX);
}
extern "C" {
    #[doc = " informs the solution that it is an LP relaxation solution"]
    pub fn SCIPsolSetLPRelaxation(sol: *mut SCIP_SOL);
}
extern "C" {
    #[doc = " informs the solution that it is a solution found during strong branching"]
    pub fn SCIPsolSetStrongbranching(sol: *mut SCIP_SOL);
}
extern "C" {
    #[doc = " informs the solution that it originates from a pseudo solution"]
    pub fn SCIPsolSetPseudo(sol: *mut SCIP_SOL);
}
extern "C" {
    #[doc = " returns unique index of given solution"]
    pub fn SCIPsolGetIndex(sol: *mut SCIP_SOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get maximum absolute bound violation of solution"]
    pub fn SCIPsolGetAbsBoundViolation(sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " get maximum relative bound violation of solution"]
    pub fn SCIPsolGetRelBoundViolation(sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " get maximum absolute integrality violation of solution"]
    pub fn SCIPsolGetAbsIntegralityViolation(sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " get maximum absolute LP row violation of solution"]
    pub fn SCIPsolGetAbsLPRowViolation(sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " get maximum relative LP row violation of solution"]
    pub fn SCIPsolGetRelLPRowViolation(sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " get maximum absolute constraint violation of solution"]
    pub fn SCIPsolGetAbsConsViolation(sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " get maximum relative constraint violation of solution"]
    pub fn SCIPsolGetRelConsViolation(sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " gets user data of statistics table"]
    pub fn SCIPtableGetData(table: *mut SCIP_TABLE) -> *mut SCIP_TABLEDATA;
}
extern "C" {
    #[doc = " sets user data of statistics table; user has to free old data in advance!"]
    pub fn SCIPtableSetData(table: *mut SCIP_TABLE, tabledata: *mut SCIP_TABLEDATA);
}
extern "C" {
    #[doc = " gets name of statistics table"]
    pub fn SCIPtableGetName(table: *mut SCIP_TABLE) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of statistics table"]
    pub fn SCIPtableGetDesc(table: *mut SCIP_TABLE) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets position of statistics table"]
    pub fn SCIPtableGetPosition(table: *mut SCIP_TABLE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets earliest stage of statistics table"]
    pub fn SCIPtableGetEarliestStage(table: *mut SCIP_TABLE) -> SCIP_STAGE;
}
extern "C" {
    #[doc = " is statistics table currently active?"]
    pub fn SCIPtableIsActive(table: *mut SCIP_TABLE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " is statistics table initialized?"]
    pub fn SCIPtableIsInitialized(table: *mut SCIP_TABLE) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPnodeCompLowerbound(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the set of variable branchings that were performed in the parent node to create this node"]
    pub fn SCIPnodeGetParentBranchings(
        node: *mut SCIP_NODE,
        branchvars: *mut *mut SCIP_VAR,
        branchbounds: *mut f64,
        boundtypes: *mut SCIP_BOUNDTYPE,
        nbranchvars: *mut ::std::os::raw::c_int,
        branchvarssize: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " returns the set of variable branchings that were performed in all ancestor nodes (nodes on the path to the root) to create this node"]
    pub fn SCIPnodeGetAncestorBranchings(
        node: *mut SCIP_NODE,
        branchvars: *mut *mut SCIP_VAR,
        branchbounds: *mut f64,
        boundtypes: *mut SCIP_BOUNDTYPE,
        nbranchvars: *mut ::std::os::raw::c_int,
        branchvarssize: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " returns the set of variable branchings that were performed between the given @p node and the given @p parent node."]
    pub fn SCIPnodeGetAncestorBranchingsPart(
        node: *mut SCIP_NODE,
        parent: *mut SCIP_NODE,
        branchvars: *mut *mut SCIP_VAR,
        branchbounds: *mut f64,
        boundtypes: *mut SCIP_BOUNDTYPE,
        nbranchvars: *mut ::std::os::raw::c_int,
        branchvarssize: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " outputs the path into given file stream in GML format"]
    pub fn SCIPnodePrintAncestorBranchings(node: *mut SCIP_NODE, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the set of variable branchings that were performed in all ancestor nodes (nodes on the path to the root) to create this node"]
    #[doc = "  sorted by the nodes, starting from the current node going up to the root"]
    pub fn SCIPnodeGetAncestorBranchingPath(
        node: *mut SCIP_NODE,
        branchvars: *mut *mut SCIP_VAR,
        branchbounds: *mut f64,
        boundtypes: *mut SCIP_BOUNDTYPE,
        nbranchvars: *mut ::std::os::raw::c_int,
        branchvarssize: ::std::os::raw::c_int,
        nodeswitches: *mut ::std::os::raw::c_int,
        nnodes: *mut ::std::os::raw::c_int,
        nodeswitchsize: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " checks for two nodes whether they share the same root path, i.e., whether one is an ancestor of the other"]
    pub fn SCIPnodesSharePath(
        node1: *mut SCIP_NODE,
        node2: *mut SCIP_NODE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " finds the common ancestor node of two given nodes"]
    pub fn SCIPnodesGetCommonAncestor(
        node1: *mut SCIP_NODE,
        node2: *mut SCIP_NODE,
    ) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets the type of the node"]
    pub fn SCIPnodeGetType(node: *mut SCIP_NODE) -> SCIP_NODETYPE;
}
extern "C" {
    #[doc = " gets successively assigned number of the node"]
    pub fn SCIPnodeGetNumber(node: *mut SCIP_NODE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the depth of the node"]
    pub fn SCIPnodeGetDepth(node: *mut SCIP_NODE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the lower bound of the node"]
    pub fn SCIPnodeGetLowerbound(node: *mut SCIP_NODE) -> f64;
}
extern "C" {
    #[doc = " gets the estimated value of the best feasible solution in subtree of the node"]
    pub fn SCIPnodeGetEstimate(node: *mut SCIP_NODE) -> f64;
}
extern "C" {
    #[doc = " gets the reoptimization type of a node"]
    pub fn SCIPnodeGetReopttype(node: *mut SCIP_NODE) -> SCIP_REOPTTYPE;
}
extern "C" {
    #[doc = " gets the unique id to identify the node during reoptimization; id is 0 if the node is the root or not part of the"]
    #[doc = " reoptimization tree"]
    pub fn SCIPnodeGetReoptID(node: *mut SCIP_NODE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets the reoptimization type of the node"]
    pub fn SCIPnodeSetReopttype(node: *mut SCIP_NODE, reopttype: SCIP_REOPTTYPE);
}
extern "C" {
    #[doc = " sets a unique id to identify the node during reoptimization"]
    pub fn SCIPnodeSetReoptID(node: *mut SCIP_NODE, id: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " counts the number of bound changes due to branching, constraint propagation, and propagation"]
    pub fn SCIPnodeGetNDomchg(
        node: *mut SCIP_NODE,
        nbranchings: *mut ::std::os::raw::c_int,
        nconsprop: *mut ::std::os::raw::c_int,
        nprop: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " gets the domain change information of the node, i.e., the information about the differences in the"]
    #[doc = "  variables domains to the parent node"]
    pub fn SCIPnodeGetDomchg(node: *mut SCIP_NODE) -> *mut SCIP_DOMCHG;
}
extern "C" {
    #[doc = " gets the parent node of a node in the branch-and-bound tree, if any"]
    pub fn SCIPnodeGetParent(node: *mut SCIP_NODE) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " returns all constraints added to a given node"]
    pub fn SCIPnodeGetAddedConss(
        node: *mut SCIP_NODE,
        addedconss: *mut *mut SCIP_CONS,
        naddedconss: *mut ::std::os::raw::c_int,
        addedconsssize: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " returns the number of added constraints to the given node"]
    pub fn SCIPnodeGetNAddedConss(node: *mut SCIP_NODE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns whether node is in the path to the current node"]
    pub fn SCIPnodeIsActive(node: *mut SCIP_NODE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the node is marked to be propagated again"]
    pub fn SCIPnodeIsPropagatedAgain(node: *mut SCIP_NODE) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPnodeGetConssetchg(node: *mut SCIP_NODE) -> *mut SCIP_CONSSETCHG;
}
extern "C" {
    #[doc = " gets number of locks for rounding down"]
    #[doc = ""]
    #[doc = "  @note This method will always return variable locks of type model"]
    #[doc = ""]
    #[doc = "  @note It is recommented to use SCIPvarGetNLocksDownType()"]
    pub fn SCIPvarGetNLocksDown(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of locks for rounding up"]
    #[doc = ""]
    #[doc = "  @note This method will always return variable locks of type model"]
    #[doc = ""]
    #[doc = "  @note It is recommented to use SCIPvarGetNLocksUpType()"]
    pub fn SCIPvarGetNLocksUp(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of locks for rounding up of a special type"]
    pub fn SCIPvarGetNLocksUpType(
        var: *mut SCIP_VAR,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of locks for rounding down of a special type"]
    pub fn SCIPvarGetNLocksDownType(
        var: *mut SCIP_VAR,
        locktype: SCIP_LOCKTYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " is it possible, to round variable down and stay feasible?"]
    #[doc = ""]
    #[doc = "  @note This method will always check w.r.t variable locks of type model"]
    pub fn SCIPvarMayRoundDown(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " is it possible, to round variable up and stay feasible?"]
    #[doc = ""]
    #[doc = "  @note This method will always check w.r.t. variable locks of type model"]
    pub fn SCIPvarMayRoundUp(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " compares the index of two variables, only active or negated variables are allowed, if a variable"]
    #[doc = "  is negated then the index of the corresponding active variable is taken, returns -1 if first is"]
    #[doc = "  smaller than, and +1 if first is greater than second variable index; returns 0 if both indices"]
    #[doc = "  are equal, which means both variables are equal"]
    pub fn SCIPvarCompareActiveAndNegated(
        var1: *mut SCIP_VAR,
        var2: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPvarCompActiveAndNegated(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " compares the index of two variables, returns -1 if first is smaller than, and +1 if first is greater than second"]
    #[doc = "  variable index; returns 0 if both indices are equal, which means both variables are equal"]
    pub fn SCIPvarCompare(var1: *mut SCIP_VAR, var2: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPvarComp(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPvarCompObj(
        elem1: *mut ::std::os::raw::c_void,
        elem2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCIPvarGetHashkey(
        userptr: *mut ::std::os::raw::c_void,
        elem: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SCIPvarIsHashkeyEq(
        userptr: *mut ::std::os::raw::c_void,
        key1: *mut ::std::os::raw::c_void,
        key2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn SCIPvarGetHashkeyVal(
        userptr: *mut ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_void,
    ) -> u64;
}
extern "C" {
    #[doc = " gets corresponding active, fixed, or multi-aggregated problem variables of given variables,"]
    #[doc = "  @note the content of the given array will/might change"]
    pub fn SCIPvarsGetProbvar(vars: *mut *mut SCIP_VAR, nvars: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " gets corresponding active, fixed, or multi-aggregated problem variable of a variable"]
    pub fn SCIPvarGetProbvar(var: *mut SCIP_VAR) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets corresponding active, fixed, or multi-aggregated problem variables of binary variables and"]
    #[doc = "  updates the given negation status of each variable"]
    pub fn SCIPvarsGetProbvarBinary(
        vars: *mut *mut *mut SCIP_VAR,
        negatedarr: *mut *mut ::std::os::raw::c_uint,
        nvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets corresponding active, fixed, or multi-aggregated problem variable of a binary variable and"]
    #[doc = "  updates the given negation status"]
    pub fn SCIPvarGetProbvarBinary(
        var: *mut *mut SCIP_VAR,
        negated: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " transforms given variable, boundtype and bound to the corresponding active, fixed, or multi-aggregated variable"]
    #[doc = "  values"]
    pub fn SCIPvarGetProbvarBound(
        var: *mut *mut SCIP_VAR,
        bound: *mut f64,
        boundtype: *mut SCIP_BOUNDTYPE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " transforms given variable and domain hole to the corresponding active, fixed, or multi-aggregated variable"]
    #[doc = "  values"]
    pub fn SCIPvarGetProbvarHole(
        var: *mut *mut SCIP_VAR,
        left: *mut f64,
        right: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " retransforms given variable, scalar and constant to the corresponding original variable, scalar"]
    #[doc = "  and constant, if possible; if the retransformation is impossible, NULL is returned as variable"]
    pub fn SCIPvarGetOrigvarSum(
        var: *mut *mut SCIP_VAR,
        scalar: *mut f64,
        constant: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether the given variable is the direct counterpart of an original problem variable"]
    pub fn SCIPvarIsTransformedOrigvar(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the number of times, a bound of the variable was changed in given direction due to branching"]
    pub fn SCIPvarGetNBranchings(
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the number of times, a bound of the variable was changed in given direction due to branching"]
    #[doc = "  in the current run"]
    pub fn SCIPvarGetNBranchingsCurrentRun(
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the number of inferences branching on this variable in given direction triggered"]
    pub fn SCIPvarGetInferenceSum(var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " returns the number of inferences branching on this variable in given direction triggered"]
    #[doc = "  in the current run"]
    pub fn SCIPvarGetInferenceSumCurrentRun(var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " returns the number of cutoffs branching on this variable in given direction produced"]
    pub fn SCIPvarGetCutoffSum(var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " returns the number of cutoffs branching on this variable in given direction produced in the current run"]
    pub fn SCIPvarGetCutoffSumCurrentRun(var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " returns the average depth of bound changes in given direction due to branching on the variable"]
    pub fn SCIPvarGetAvgBranchdepth(var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " returns the average depth of bound changes in given direction due to branching on the variable"]
    #[doc = "  in the current run"]
    pub fn SCIPvarGetAvgBranchdepthCurrentRun(var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " returns whether there is an implication x == varfixing -> y <= b or y >= b in the implication graph;"]
    #[doc = "  implications that are represented as cliques in the clique table are not regarded (use SCIPvarsHaveCommonClique());"]
    #[doc = "  both variables must be active, variable x must be binary"]
    pub fn SCIPvarHasImplic(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
        implvar: *mut SCIP_VAR,
        impltype: SCIP_BOUNDTYPE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether there is an implication x == varfixing -> y == implvarfixing in the implication graph;"]
    #[doc = "  implications that are represented as cliques in the clique table are not regarded (use SCIPvarsHaveCommonClique());"]
    #[doc = "  both variables must be active binary variables"]
    pub fn SCIPvarHasBinaryImplic(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
        implvar: *mut SCIP_VAR,
        implvarfixing: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether there is a clique that contains both given variable/value pairs;"]
    #[doc = "  the variables must be active binary variables;"]
    #[doc = "  if regardimplics is FALSE, only the cliques in the clique table are looked at;"]
    #[doc = "  if regardimplics is TRUE, both the cliques and the implications of the implication graph are regarded"]
    pub fn SCIPvarsHaveCommonClique(
        var1: *mut SCIP_VAR,
        value1: ::std::os::raw::c_uint,
        var2: *mut SCIP_VAR,
        value2: ::std::os::raw::c_uint,
        regardimplics: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets corresponding objective value of active, fixed, or multi-aggregated problem variable of given variable"]
    #[doc = "  e.g. obj(x) = 1 this method returns for ~x the value -1"]
    pub fn SCIPvarGetAggregatedObj(var: *mut SCIP_VAR, aggrobj: *mut f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the initial flag of a variable; only possible for original or loose variables"]
    pub fn SCIPvarSetInitial(var: *mut SCIP_VAR, initial: ::std::os::raw::c_uint) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the removable flag of a variable; only possible for original or loose variables"]
    pub fn SCIPvarSetRemovable(
        var: *mut SCIP_VAR,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the name of the variable"]
    #[doc = ""]
    #[doc = "  @note to change the name of a variable, use SCIPchgVarName() from scip.h"]
    pub fn SCIPvarGetName(var: *mut SCIP_VAR) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets number of times, the variable is currently captured"]
    pub fn SCIPvarGetNUses(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the user data of the variable"]
    pub fn SCIPvarGetData(var: *mut SCIP_VAR) -> *mut SCIP_VARDATA;
}
extern "C" {
    #[doc = " sets the user data for the variable"]
    pub fn SCIPvarSetData(var: *mut SCIP_VAR, vardata: *mut SCIP_VARDATA);
}
extern "C" {
    #[doc = " sets method to free user data for the original variable"]
    pub fn SCIPvarSetDelorigData(
        var: *mut SCIP_VAR,
        vardelorig: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                vardata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " sets method to transform user data of the variable"]
    pub fn SCIPvarSetTransData(
        var: *mut SCIP_VAR,
        vartrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcevar: *mut SCIP_VAR,
                sourcedata: *mut SCIP_VARDATA,
                targetvar: *mut SCIP_VAR,
                targetdata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " sets method to free transformed user data for the variable"]
    pub fn SCIPvarSetDeltransData(
        var: *mut SCIP_VAR,
        vardeltrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                vardata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " sets method to copy this variable into sub-SCIPs"]
    pub fn SCIPvarSetCopyData(
        var: *mut SCIP_VAR,
        varcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcescip: *mut SCIP,
                sourcevar: *mut SCIP_VAR,
                sourcedata: *mut SCIP_VARDATA,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                targetvar: *mut SCIP_VAR,
                targetdata: *mut *mut SCIP_VARDATA,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    );
}
extern "C" {
    #[doc = " gets status of variable"]
    pub fn SCIPvarGetStatus(var: *mut SCIP_VAR) -> SCIP_VARSTATUS;
}
extern "C" {
    #[doc = " returns whether the variable belongs to the original problem"]
    pub fn SCIPvarIsOriginal(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the variable belongs to the transformed problem"]
    pub fn SCIPvarIsTransformed(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the variable was created by negation of a different variable"]
    pub fn SCIPvarIsNegated(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets type of variable"]
    pub fn SCIPvarGetType(var: *mut SCIP_VAR) -> SCIP_VARTYPE;
}
extern "C" {
    #[doc = " returns TRUE if the variable is of binary type; this is the case if:"]
    #[doc = "  (1) variable type is binary"]
    #[doc = "  (2) variable type is integer or implicit integer and"]
    #[doc = "      (i)  the lazy lower bound or the global lower bound is greater than or equal to zero"]
    #[doc = "      (ii) the lazy upper bound or the global upper bound is less than or equal to one"]
    pub fn SCIPvarIsBinary(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether variable is of integral type (binary, integer, or implicit integer)"]
    pub fn SCIPvarIsIntegral(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether variable's column should be present in the initial root LP"]
    pub fn SCIPvarIsInitial(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether variable's column is removable from the LP (due to aging or cleanup)"]
    pub fn SCIPvarIsRemovable(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the variable was deleted from the problem"]
    pub fn SCIPvarIsDeleted(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " marks the variable to be deletable, i.e., it may be deleted completely from the problem;"]
    #[doc = "  method can only be called before the variable is added to the problem by SCIPaddVar() or SCIPaddPricedVar()"]
    pub fn SCIPvarMarkDeletable(var: *mut SCIP_VAR);
}
extern "C" {
    #[doc = " marks the variable to be not deletable from the problem"]
    pub fn SCIPvarMarkNotDeletable(var: *mut SCIP_VAR);
}
extern "C" {
    #[doc = " returns whether variable is allowed to be deleted completely from the problem"]
    pub fn SCIPvarIsDeletable(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " marks variable to be deleted from global structures (cliques etc.) when cleaning up"]
    #[doc = ""]
    #[doc = "  @note: this is not equivalent to marking the variable itself for deletion, this is done by using SCIPvarMarkDeletable()"]
    pub fn SCIPvarMarkDeleteGlobalStructures(var: *mut SCIP_VAR);
}
extern "C" {
    #[doc = " returns whether variable is an active (neither fixed nor aggregated) variable"]
    pub fn SCIPvarIsActive(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets unique index of variable"]
    pub fn SCIPvarGetIndex(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets position of variable in problem, or -1 if variable is not active"]
    pub fn SCIPvarGetProbindex(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets transformed variable of ORIGINAL variable"]
    pub fn SCIPvarGetTransVar(var: *mut SCIP_VAR) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets column of COLUMN variable"]
    pub fn SCIPvarGetCol(var: *mut SCIP_VAR) -> *mut SCIP_COL;
}
extern "C" {
    #[doc = " returns whether the variable is a COLUMN variable that is member of the current LP"]
    pub fn SCIPvarIsInLP(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets aggregation variable y of an aggregated variable x = a*y + c"]
    pub fn SCIPvarGetAggrVar(var: *mut SCIP_VAR) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets aggregation scalar a of an aggregated variable x = a*y + c"]
    pub fn SCIPvarGetAggrScalar(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets aggregation constant c of an aggregated variable x = a*y + c"]
    pub fn SCIPvarGetAggrConstant(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets number n of aggregation variables of a multi aggregated variable x = a0*y0 + ... + a(n-1)*y(n-1) + c"]
    pub fn SCIPvarGetMultaggrNVars(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets vector of aggregation variables y of a multi aggregated variable x = a0*y0 + ... + a(n-1)*y(n-1) + c"]
    pub fn SCIPvarGetMultaggrVars(var: *mut SCIP_VAR) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets vector of aggregation scalars a of a multi aggregated variable x = a0*y0 + ... + a(n-1)*y(n-1) + c"]
    pub fn SCIPvarGetMultaggrScalars(var: *mut SCIP_VAR) -> *mut f64;
}
extern "C" {
    #[doc = " gets aggregation constant c of a multi aggregated variable x = a0*y0 + ... + a(n-1)*y(n-1) + c"]
    pub fn SCIPvarGetMultaggrConstant(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets the negation of the given variable; may return NULL, if no negation is existing yet"]
    pub fn SCIPvarGetNegatedVar(var: *mut SCIP_VAR) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets the negation variable x of a negated variable x' = offset - x"]
    pub fn SCIPvarGetNegationVar(var: *mut SCIP_VAR) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets the negation offset of a negated variable x' = offset - x"]
    pub fn SCIPvarGetNegationConstant(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets objective function value of variable"]
    pub fn SCIPvarGetObj(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets the unchanged objective function value of variable (ignoring temproray changes performed in probing mode)"]
    pub fn SCIPvarGetUnchangedObj(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets original lower bound of original problem variable (i.e. the bound set in problem creation)"]
    pub fn SCIPvarGetLbOriginal(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets original upper bound of original problem variable (i.e. the bound set in problem creation)"]
    pub fn SCIPvarGetUbOriginal(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets the original hole list of an original variable"]
    pub fn SCIPvarGetHolelistOriginal(var: *mut SCIP_VAR) -> *mut SCIP_HOLELIST;
}
extern "C" {
    #[doc = " gets global lower bound of variable"]
    pub fn SCIPvarGetLbGlobal(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets global upper bound of variable"]
    pub fn SCIPvarGetUbGlobal(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets the global hole list of an active variable"]
    pub fn SCIPvarGetHolelistGlobal(var: *mut SCIP_VAR) -> *mut SCIP_HOLELIST;
}
extern "C" {
    #[doc = " gets best global bound of variable with respect to the objective function"]
    pub fn SCIPvarGetBestBoundGlobal(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets worst global bound of variable with respect to the objective function"]
    pub fn SCIPvarGetWorstBoundGlobal(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets current lower bound of variable"]
    pub fn SCIPvarGetLbLocal(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets current upper bound of variable"]
    pub fn SCIPvarGetUbLocal(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets the current hole list of an active variable"]
    pub fn SCIPvarGetHolelistLocal(var: *mut SCIP_VAR) -> *mut SCIP_HOLELIST;
}
extern "C" {
    #[doc = " gets best local bound of variable with respect to the objective function"]
    pub fn SCIPvarGetBestBoundLocal(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets worst local bound of variable with respect to the objective function"]
    pub fn SCIPvarGetWorstBoundLocal(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets type (lower or upper) of best bound of variable with respect to the objective function"]
    pub fn SCIPvarGetBestBoundType(var: *mut SCIP_VAR) -> SCIP_BOUNDTYPE;
}
extern "C" {
    #[doc = " gets type (lower or upper) of worst bound of variable with respect to the objective function"]
    pub fn SCIPvarGetWorstBoundType(var: *mut SCIP_VAR) -> SCIP_BOUNDTYPE;
}
extern "C" {
    #[doc = " gets lazy lower bound of variable"]
    pub fn SCIPvarGetLbLazy(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets lazy upper bound of variable"]
    pub fn SCIPvarGetUbLazy(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets the branch factor of the variable; this value can be used in the branching methods to scale the score"]
    #[doc = "  values of the variables; higher factor leads to a higher probability that this variable is chosen for branching"]
    pub fn SCIPvarGetBranchFactor(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets the branch priority of the variable; variables with higher priority should always be preferred to variables"]
    #[doc = "  with lower priority"]
    pub fn SCIPvarGetBranchPriority(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the preferred branch direction of the variable (downwards, upwards, or auto)"]
    pub fn SCIPvarGetBranchDirection(var: *mut SCIP_VAR) -> SCIP_BRANCHDIR;
}
extern "C" {
    #[doc = " gets number of variable lower bounds x >= b_i*z_i + d_i of given variable x"]
    pub fn SCIPvarGetNVlbs(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array with bounding variables z_i in variable lower bounds x >= b_i*z_i + d_i of given variable x;"]
    #[doc = "  the variable bounds are sorted by increasing variable index of the bounding variable z_i (see SCIPvarGetIndex())"]
    pub fn SCIPvarGetVlbVars(var: *mut SCIP_VAR) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets array with bounding coefficients b_i in variable lower bounds x >= b_i*z_i + d_i of given variable x"]
    pub fn SCIPvarGetVlbCoefs(var: *mut SCIP_VAR) -> *mut f64;
}
extern "C" {
    #[doc = " gets array with bounding constants d_i in variable lower bounds x >= b_i*z_i + d_i of given variable x"]
    pub fn SCIPvarGetVlbConstants(var: *mut SCIP_VAR) -> *mut f64;
}
extern "C" {
    #[doc = " gets number of variable upper bounds x <= b_i*z_i + d_i of given variable x"]
    pub fn SCIPvarGetNVubs(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array with bounding variables z_i in variable upper bounds x <= b_i*z_i + d_i of given variable x;"]
    #[doc = "  the variable bounds are sorted by increasing variable index of the bounding variable z_i (see SCIPvarGetIndex())"]
    pub fn SCIPvarGetVubVars(var: *mut SCIP_VAR) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets array with bounding coefficients b_i in variable upper bounds x <= b_i*z_i + d_i of given variable x"]
    pub fn SCIPvarGetVubCoefs(var: *mut SCIP_VAR) -> *mut f64;
}
extern "C" {
    #[doc = " gets array with bounding constants d_i in variable upper bounds x <= b_i*z_i + d_i of given variable x"]
    pub fn SCIPvarGetVubConstants(var: *mut SCIP_VAR) -> *mut f64;
}
extern "C" {
    #[doc = " gets number of implications  y <= b or y >= b for x == 0 or x == 1 of given active problem variable x,"]
    #[doc = "  there are no implications for nonbinary variable x"]
    pub fn SCIPvarGetNImpls(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array with implication variables y of implications  y <= b or y >= b for x == 0 or x == 1 of given active"]
    #[doc = "  problem variable x, there are no implications for nonbinary variable x;"]
    #[doc = "  the implications are sorted such that implications with binary implied variables precede the ones with non-binary"]
    #[doc = "  implied variables, and as a second criteria, the implied variables are sorted by increasing variable index"]
    #[doc = "  (see SCIPvarGetIndex())"]
    pub fn SCIPvarGetImplVars(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets array with implication types of implications  y <= b or y >= b for x == 0 or x == 1 of given active problem"]
    #[doc = "  variable x (SCIP_BOUNDTYPE_UPPER if y <= b, SCIP_BOUNDTYPE_LOWER if y >= b),"]
    #[doc = "  there are no implications for nonbinary variable x"]
    pub fn SCIPvarGetImplTypes(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> *mut SCIP_BOUNDTYPE;
}
extern "C" {
    #[doc = " gets array with implication bounds b of implications  y <= b or y >= b for x == 0 or x == 1 of given active problem"]
    #[doc = "  variable x, there are no implications for nonbinary variable x"]
    pub fn SCIPvarGetImplBounds(var: *mut SCIP_VAR, varfixing: ::std::os::raw::c_uint) -> *mut f64;
}
extern "C" {
    #[doc = " Gets array with unique ids of implications  y <= b or y >= b for x == 0 or x == 1 of given active problem variable x,"]
    #[doc = "  there are no implications for nonbinary variable x."]
    #[doc = "  If an implication is a shortcut, i.e., it was added as part of the transitive closure of another implication,"]
    #[doc = "  its id is negative, otherwise it is nonnegative."]
    pub fn SCIPvarGetImplIds(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of cliques, the active variable is contained in"]
    pub fn SCIPvarGetNCliques(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of cliques, the active variable is contained in"]
    pub fn SCIPvarGetCliques(
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> *mut *mut SCIP_CLIQUE;
}
extern "C" {
    #[doc = " gets primal LP solution value of variable"]
    pub fn SCIPvarGetLPSol(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets primal NLP solution value of variable"]
    pub fn SCIPvarGetNLPSol(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " return lower bound change info at requested position"]
    pub fn SCIPvarGetBdchgInfoLb(
        var: *mut SCIP_VAR,
        pos: ::std::os::raw::c_int,
    ) -> *mut SCIP_BDCHGINFO;
}
extern "C" {
    #[doc = " gets the number of lower bound change info array"]
    pub fn SCIPvarGetNBdchgInfosLb(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " return upper bound change info at requested position"]
    pub fn SCIPvarGetBdchgInfoUb(
        var: *mut SCIP_VAR,
        pos: ::std::os::raw::c_int,
    ) -> *mut SCIP_BDCHGINFO;
}
extern "C" {
    #[doc = " gets the number upper bound change info array"]
    pub fn SCIPvarGetNBdchgInfosUb(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the value based history for the variable"]
    pub fn SCIPvarGetValuehistory(var: *mut SCIP_VAR) -> *mut SCIP_VALUEHISTORY;
}
extern "C" {
    #[doc = " returns whether a variable has been introduced to define a relaxation"]
    #[doc = ""]
    #[doc = " These variables are only valid for the current SCIP solve round,"]
    #[doc = " they are not contained in any (checked) constraints, but may be used"]
    #[doc = " in cutting planes, for example."]
    #[doc = " Relaxation-only variables are not copied by SCIPcopyVars and cuts"]
    #[doc = " that contain these variables are not added as linear constraints when"]
    #[doc = " restarting or transferring information from a copied SCIP to a SCIP."]
    #[doc = " Also conflicts with relaxation-only variables are not generated at"]
    #[doc = " the moment."]
    #[doc = " Relaxation-only variables do not appear in the objective."]
    pub fn SCIPvarIsRelaxationOnly(var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " marks that this variable has only been introduced to define a relaxation"]
    #[doc = ""]
    #[doc = " The variable must not have a coefficient in the objective."]
    #[doc = ""]
    #[doc = " @see SCIPvarIsRelaxationOnly"]
    pub fn SCIPvarMarkRelaxationOnly(var: *mut SCIP_VAR);
}
extern "C" {
    #[doc = " gets primal LP solution value of variable"]
    pub fn SCIPvarGetLPSol_rec(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets primal NLP solution value of variable"]
    pub fn SCIPvarGetNLPSol_rec(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets pseudo solution value of variable at current node"]
    pub fn SCIPvarGetPseudoSol(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets current LP or pseudo solution value of variable"]
    pub fn SCIPvarGetSol(var: *mut SCIP_VAR, getlpval: ::std::os::raw::c_uint) -> f64;
}
extern "C" {
    #[doc = " returns the solution of the variable in the last root node's relaxation, if the root relaxation is not yet"]
    #[doc = "  completely solved, zero is returned"]
    pub fn SCIPvarGetRootSol(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the best solution (w.r.t. root reduced cost propagation) of the variable in the root node's relaxation, if"]
    #[doc = "  the root relaxation is not yet completely solved, zero is returned"]
    pub fn SCIPvarGetBestRootSol(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the best reduced costs (w.r.t. root reduced cost propagation) of the variable in the root node's relaxation,"]
    #[doc = "  if the root relaxation is not yet completely solved, or the variable was no column of the root LP, SCIP_INVALID is"]
    #[doc = "  returned"]
    pub fn SCIPvarGetBestRootRedcost(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the best objective value (w.r.t. root reduced cost propagation) of the root LP which belongs the root"]
    #[doc = "  reduced cost which is accessible via SCIPvarGetRootRedcost() or the variable was no column of the root LP,"]
    #[doc = "  SCIP_INVALID is returned"]
    pub fn SCIPvarGetBestRootLPObjval(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " set the given solution as the best root solution w.r.t. root reduced cost propagation in the variables"]
    pub fn SCIPvarSetBestRootSol(
        var: *mut SCIP_VAR,
        rootsol: f64,
        rootredcost: f64,
        rootlpobjval: f64,
    );
}
extern "C" {
    #[doc = " returns a weighted average solution value of the variable in all feasible primal solutions found so far"]
    pub fn SCIPvarGetAvgSol(var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the bound change information for the last lower bound change on given active problem variable before or"]
    #[doc = "  after the bound change with the given index was applied;"]
    #[doc = "  returns NULL, if no change to the lower bound was applied up to this point of time"]
    pub fn SCIPvarGetLbchgInfo(
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> *mut SCIP_BDCHGINFO;
}
extern "C" {
    #[doc = " returns the bound change information for the last upper bound change on given active problem variable before or"]
    #[doc = "  after the bound change with the given index was applied;"]
    #[doc = "  returns NULL, if no change to the upper bound was applied up to this point of time"]
    pub fn SCIPvarGetUbchgInfo(
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> *mut SCIP_BDCHGINFO;
}
extern "C" {
    #[doc = " returns the bound change information for the last lower or upper bound change on given active problem variable"]
    #[doc = "  before or after the bound change with the given index was applied;"]
    #[doc = "  returns NULL, if no change to the lower/upper bound was applied up to this point of time"]
    pub fn SCIPvarGetBdchgInfo(
        var: *mut SCIP_VAR,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> *mut SCIP_BDCHGINFO;
}
extern "C" {
    #[doc = " returns lower bound of variable directly before or after the bound change given by the bound change index"]
    #[doc = "  was applied"]
    #[doc = ""]
    #[doc = "  @deprecated Please use SCIPgetVarLbAtIndex()"]
    pub fn SCIPvarGetLbAtIndex(
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " returns upper bound of variable directly before or after the bound change given by the bound change index"]
    #[doc = "  was applied"]
    #[doc = ""]
    #[doc = "  @deprecated Please use SCIPgetVarUbAtIndex()"]
    pub fn SCIPvarGetUbAtIndex(
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " returns lower or upper bound of variable directly before or after the bound change given by the bound change index"]
    #[doc = "  was applied"]
    #[doc = ""]
    #[doc = "  @deprecated Please use SCIPgetVarBdAtIndex()"]
    pub fn SCIPvarGetBdAtIndex(
        var: *mut SCIP_VAR,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " returns whether the binary variable was fixed at the time given by the bound change index"]
    #[doc = ""]
    #[doc = "  @deprecated Please use SCIPgetVarWasFixedAtIndex()"]
    pub fn SCIPvarWasFixedAtIndex(
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the last bound change index, at which the bounds of the given variable were tightened"]
    pub fn SCIPvarGetLastBdchgIndex(var: *mut SCIP_VAR) -> *mut SCIP_BDCHGIDX;
}
extern "C" {
    #[doc = " returns the last depth level, at which the bounds of the given variable were tightened;"]
    #[doc = "  returns -2, if the variable's bounds are still the global bounds"]
    #[doc = "  returns -1, if the variable was fixed in presolving"]
    pub fn SCIPvarGetLastBdchgDepth(var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns whether the first binary variable was fixed earlier than the second one;"]
    #[doc = "  returns FALSE, if the first variable is not fixed, and returns TRUE, if the first variable is fixed, but the"]
    #[doc = "  second one is not fixed"]
    pub fn SCIPvarWasFixedEarlier(
        var1: *mut SCIP_VAR,
        var2: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether first bound change index belongs to an earlier applied bound change than second one;"]
    #[doc = "  if a bound change index is NULL, the bound change index represents the current time, i.e. the time after the"]
    #[doc = "  last bound change was applied to the current node"]
    pub fn SCIPbdchgidxIsEarlier(
        bdchgidx1: *mut SCIP_BDCHGIDX,
        bdchgidx2: *mut SCIP_BDCHGIDX,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether first bound change index belongs to an earlier applied bound change than second one"]
    pub fn SCIPbdchgidxIsEarlierNonNull(
        bdchgidx1: *mut SCIP_BDCHGIDX,
        bdchgidx2: *mut SCIP_BDCHGIDX,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns old bound that was overwritten for given bound change information"]
    pub fn SCIPbdchginfoGetOldbound(bdchginfo: *mut SCIP_BDCHGINFO) -> f64;
}
extern "C" {
    #[doc = " returns new bound installed for given bound change information"]
    pub fn SCIPbdchginfoGetNewbound(bdchginfo: *mut SCIP_BDCHGINFO) -> f64;
}
extern "C" {
    #[doc = " returns variable that belongs to the given bound change information"]
    pub fn SCIPbdchginfoGetVar(bdchginfo: *mut SCIP_BDCHGINFO) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " returns whether the bound change information belongs to a branching decision or a deduction"]
    pub fn SCIPbdchginfoGetChgtype(bdchginfo: *mut SCIP_BDCHGINFO) -> SCIP_BOUNDCHGTYPE;
}
extern "C" {
    #[doc = " returns whether the bound change information belongs to a lower or upper bound change"]
    pub fn SCIPbdchginfoGetBoundtype(bdchginfo: *mut SCIP_BDCHGINFO) -> SCIP_BOUNDTYPE;
}
extern "C" {
    #[doc = " returns depth level of given bound change information"]
    pub fn SCIPbdchginfoGetDepth(bdchginfo: *mut SCIP_BDCHGINFO) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns bound change position in its depth level of given bound change information"]
    pub fn SCIPbdchginfoGetPos(bdchginfo: *mut SCIP_BDCHGINFO) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns bound change index of given bound change information"]
    pub fn SCIPbdchginfoGetIdx(bdchginfo: *mut SCIP_BDCHGINFO) -> *mut SCIP_BDCHGIDX;
}
extern "C" {
    #[doc = " returns inference variable of given bound change information"]
    pub fn SCIPbdchginfoGetInferVar(bdchginfo: *mut SCIP_BDCHGINFO) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " returns inference constraint of given bound change information"]
    pub fn SCIPbdchginfoGetInferCons(bdchginfo: *mut SCIP_BDCHGINFO) -> *mut SCIP_CONS;
}
extern "C" {
    #[doc = " returns inference propagator of given bound change information, or NULL if no propagator was responsible"]
    pub fn SCIPbdchginfoGetInferProp(bdchginfo: *mut SCIP_BDCHGINFO) -> *mut SCIP_PROP;
}
extern "C" {
    #[doc = " returns inference user information of given bound change information"]
    pub fn SCIPbdchginfoGetInferInfo(bdchginfo: *mut SCIP_BDCHGINFO) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns inference bound of inference variable of given bound change information"]
    pub fn SCIPbdchginfoGetInferBoundtype(bdchginfo: *mut SCIP_BDCHGINFO) -> SCIP_BOUNDTYPE;
}
extern "C" {
    #[doc = " returns whether the bound change information belongs to a redundant bound change"]
    pub fn SCIPbdchginfoIsRedundant(bdchginfo: *mut SCIP_BDCHGINFO) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the bound change has an inference reason (constraint or propagator), that can be resolved"]
    pub fn SCIPbdchginfoHasInferenceReason(
        bdchginfo: *mut SCIP_BDCHGINFO,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " for two bound change informations belonging to the same variable and bound, returns whether the first bound change"]
    #[doc = "  has a tighter new bound as the second bound change"]
    pub fn SCIPbdchginfoIsTighter(
        bdchginfo1: *mut SCIP_BDCHGINFO,
        bdchginfo2: *mut SCIP_BDCHGINFO,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the new value of the bound in the bound change data"]
    pub fn SCIPboundchgGetNewbound(boundchg: *mut SCIP_BOUNDCHG) -> f64;
}
extern "C" {
    #[doc = " returns the variable of the bound change in the bound change data"]
    pub fn SCIPboundchgGetVar(boundchg: *mut SCIP_BOUNDCHG) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " returns the bound change type of the bound change in the bound change data"]
    pub fn SCIPboundchgGetBoundchgtype(boundchg: *mut SCIP_BOUNDCHG) -> SCIP_BOUNDCHGTYPE;
}
extern "C" {
    #[doc = " returns the bound type of the bound change in the bound change data"]
    pub fn SCIPboundchgGetBoundtype(boundchg: *mut SCIP_BOUNDCHG) -> SCIP_BOUNDTYPE;
}
extern "C" {
    #[doc = " returns whether the bound change is redundant due to a more global bound that is at least as strong"]
    pub fn SCIPboundchgIsRedundant(boundchg: *mut SCIP_BOUNDCHG) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the number of bound changes in the domain change data"]
    pub fn SCIPdomchgGetNBoundchgs(domchg: *mut SCIP_DOMCHG) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns a particular bound change in the domain change data"]
    pub fn SCIPdomchgGetBoundchg(
        domchg: *mut SCIP_DOMCHG,
        pos: ::std::os::raw::c_int,
    ) -> *mut SCIP_BOUNDCHG;
}
extern "C" {
    #[doc = " returns left bound of open interval in hole"]
    pub fn SCIPholelistGetLeft(holelist: *mut SCIP_HOLELIST) -> f64;
}
extern "C" {
    #[doc = " returns right bound of open interval in hole"]
    pub fn SCIPholelistGetRight(holelist: *mut SCIP_HOLELIST) -> f64;
}
extern "C" {
    #[doc = " returns next hole in list or NULL"]
    pub fn SCIPholelistGetNext(holelist: *mut SCIP_HOLELIST) -> *mut SCIP_HOLELIST;
}
extern "C" {
    #[doc = " gets name and version of LP solver"]
    pub fn SCIPlpiGetSolverName() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets description of LP solver (developer, webpage, ...)"]
    pub fn SCIPlpiGetSolverDesc() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gets pointer for LP solver - use only with great care"]
    #[doc = ""]
    #[doc = "  The behavior of this function depends on the solver and its use is"]
    #[doc = "  therefore only recommended if you really know what you are"]
    #[doc = "  doing. In general, it returns a pointer to the LP solver object."]
    pub fn SCIPlpiGetSolverPointer(lpi: *mut SCIP_LPI) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " pass integrality information about variables to the solver"]
    pub fn SCIPlpiSetIntegralityInformation(
        lpi: *mut SCIP_LPI,
        ncols: ::std::os::raw::c_int,
        intInfo: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " informs about availability of a primal simplex solving method"]
    pub fn SCIPlpiHasPrimalSolve() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " informs about availability of a dual simplex solving method"]
    pub fn SCIPlpiHasDualSolve() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " informs about availability of a barrier solving method"]
    pub fn SCIPlpiHasBarrierSolve() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " creates an LP problem object"]
    pub fn SCIPlpiCreate(
        lpi: *mut *mut SCIP_LPI,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        name: *const ::std::os::raw::c_char,
        objsen: SCIP_OBJSEN,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " deletes an LP problem object"]
    pub fn SCIPlpiFree(lpi: *mut *mut SCIP_LPI) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies LP data with column matrix into LP solver"]
    pub fn SCIPlpiLoadColLP(
        lpi: *mut SCIP_LPI,
        objsen: SCIP_OBJSEN,
        ncols: ::std::os::raw::c_int,
        obj: *const f64,
        lb: *const f64,
        ub: *const f64,
        colnames: *mut *mut ::std::os::raw::c_char,
        nrows: ::std::os::raw::c_int,
        lhs: *const f64,
        rhs: *const f64,
        rownames: *mut *mut ::std::os::raw::c_char,
        nnonz: ::std::os::raw::c_int,
        beg: *const ::std::os::raw::c_int,
        ind: *const ::std::os::raw::c_int,
        val: *const f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds columns to the LP"]
    #[doc = ""]
    #[doc = "  @note ind array is not checked for duplicates, problems may appear if indices are added more than once"]
    pub fn SCIPlpiAddCols(
        lpi: *mut SCIP_LPI,
        ncols: ::std::os::raw::c_int,
        obj: *const f64,
        lb: *const f64,
        ub: *const f64,
        colnames: *mut *mut ::std::os::raw::c_char,
        nnonz: ::std::os::raw::c_int,
        beg: *const ::std::os::raw::c_int,
        ind: *const ::std::os::raw::c_int,
        val: *const f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " deletes all columns in the given range from LP"]
    pub fn SCIPlpiDelCols(
        lpi: *mut SCIP_LPI,
        firstcol: ::std::os::raw::c_int,
        lastcol: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " deletes columns from SCIP_LPI; the new position of a column must not be greater that its old position"]
    pub fn SCIPlpiDelColset(lpi: *mut SCIP_LPI, dstat: *mut ::std::os::raw::c_int) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds rows to the LP"]
    #[doc = ""]
    #[doc = "  @note ind array is not checked for duplicates, problems may appear if indices are added more than once"]
    pub fn SCIPlpiAddRows(
        lpi: *mut SCIP_LPI,
        nrows: ::std::os::raw::c_int,
        lhs: *const f64,
        rhs: *const f64,
        rownames: *mut *mut ::std::os::raw::c_char,
        nnonz: ::std::os::raw::c_int,
        beg: *const ::std::os::raw::c_int,
        ind: *const ::std::os::raw::c_int,
        val: *const f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " deletes all rows in the given range from LP"]
    pub fn SCIPlpiDelRows(
        lpi: *mut SCIP_LPI,
        firstrow: ::std::os::raw::c_int,
        lastrow: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " deletes rows from SCIP_LPI; the new position of a row must not be greater that its old position"]
    pub fn SCIPlpiDelRowset(lpi: *mut SCIP_LPI, dstat: *mut ::std::os::raw::c_int) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " clears the whole LP"]
    pub fn SCIPlpiClear(lpi: *mut SCIP_LPI) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes lower and upper bounds of columns"]
    pub fn SCIPlpiChgBounds(
        lpi: *mut SCIP_LPI,
        ncols: ::std::os::raw::c_int,
        ind: *const ::std::os::raw::c_int,
        lb: *const f64,
        ub: *const f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes left and right hand sides of rows"]
    pub fn SCIPlpiChgSides(
        lpi: *mut SCIP_LPI,
        nrows: ::std::os::raw::c_int,
        ind: *const ::std::os::raw::c_int,
        lhs: *const f64,
        rhs: *const f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes a single coefficient"]
    pub fn SCIPlpiChgCoef(
        lpi: *mut SCIP_LPI,
        row: ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        newval: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the objective sense"]
    pub fn SCIPlpiChgObjsen(lpi: *mut SCIP_LPI, objsen: SCIP_OBJSEN) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes objective values of columns in the LP"]
    pub fn SCIPlpiChgObj(
        lpi: *mut SCIP_LPI,
        ncols: ::std::os::raw::c_int,
        ind: *const ::std::os::raw::c_int,
        obj: *const f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " multiplies a row with a non-zero scalar; for negative scalars, the row's sense is switched accordingly"]
    pub fn SCIPlpiScaleRow(
        lpi: *mut SCIP_LPI,
        row: ::std::os::raw::c_int,
        scaleval: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " multiplies a column with a non-zero scalar; the objective value is multiplied with the scalar, and the bounds"]
    #[doc = "  are divided by the scalar; for negative scalars, the column's bounds are switched"]
    pub fn SCIPlpiScaleCol(
        lpi: *mut SCIP_LPI,
        col: ::std::os::raw::c_int,
        scaleval: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the number of rows in the LP"]
    pub fn SCIPlpiGetNRows(lpi: *mut SCIP_LPI, nrows: *mut ::std::os::raw::c_int) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the number of columns in the LP"]
    pub fn SCIPlpiGetNCols(lpi: *mut SCIP_LPI, ncols: *mut ::std::os::raw::c_int) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the objective sense of the LP"]
    pub fn SCIPlpiGetObjsen(lpi: *mut SCIP_LPI, objsen: *mut SCIP_OBJSEN) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the number of nonzero elements in the LP constraint matrix"]
    pub fn SCIPlpiGetNNonz(lpi: *mut SCIP_LPI, nnonz: *mut ::std::os::raw::c_int) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets columns from LP problem object; the arrays have to be large enough to store all values;"]
    #[doc = "  Either both, lb and ub, have to be NULL, or both have to be non-NULL,"]
    #[doc = "  either nnonz, beg, ind, and val have to be NULL, or all of them have to be non-NULL."]
    pub fn SCIPlpiGetCols(
        lpi: *mut SCIP_LPI,
        firstcol: ::std::os::raw::c_int,
        lastcol: ::std::os::raw::c_int,
        lb: *mut f64,
        ub: *mut f64,
        nnonz: *mut ::std::os::raw::c_int,
        beg: *mut ::std::os::raw::c_int,
        ind: *mut ::std::os::raw::c_int,
        val: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets rows from LP problem object; the arrays have to be large enough to store all values."]
    #[doc = "  Either both, lhs and rhs, have to be NULL, or both have to be non-NULL,"]
    #[doc = "  either nnonz, beg, ind, and val have to be NULL, or all of them have to be non-NULL."]
    pub fn SCIPlpiGetRows(
        lpi: *mut SCIP_LPI,
        firstrow: ::std::os::raw::c_int,
        lastrow: ::std::os::raw::c_int,
        lhs: *mut f64,
        rhs: *mut f64,
        nnonz: *mut ::std::os::raw::c_int,
        beg: *mut ::std::os::raw::c_int,
        ind: *mut ::std::os::raw::c_int,
        val: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets column names"]
    pub fn SCIPlpiGetColNames(
        lpi: *mut SCIP_LPI,
        firstcol: ::std::os::raw::c_int,
        lastcol: ::std::os::raw::c_int,
        colnames: *mut *mut ::std::os::raw::c_char,
        namestorage: *mut ::std::os::raw::c_char,
        namestoragesize: ::std::os::raw::c_int,
        storageleft: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets row names"]
    pub fn SCIPlpiGetRowNames(
        lpi: *mut SCIP_LPI,
        firstrow: ::std::os::raw::c_int,
        lastrow: ::std::os::raw::c_int,
        rownames: *mut *mut ::std::os::raw::c_char,
        namestorage: *mut ::std::os::raw::c_char,
        namestoragesize: ::std::os::raw::c_int,
        storageleft: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets objective coefficients from LP problem object"]
    pub fn SCIPlpiGetObj(
        lpi: *mut SCIP_LPI,
        firstcol: ::std::os::raw::c_int,
        lastcol: ::std::os::raw::c_int,
        vals: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets current bounds from LP problem object"]
    pub fn SCIPlpiGetBounds(
        lpi: *mut SCIP_LPI,
        firstcol: ::std::os::raw::c_int,
        lastcol: ::std::os::raw::c_int,
        lbs: *mut f64,
        ubs: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets current row sides from LP problem object"]
    pub fn SCIPlpiGetSides(
        lpi: *mut SCIP_LPI,
        firstrow: ::std::os::raw::c_int,
        lastrow: ::std::os::raw::c_int,
        lhss: *mut f64,
        rhss: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets a single coefficient"]
    pub fn SCIPlpiGetCoef(
        lpi: *mut SCIP_LPI,
        row: ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        val: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls primal simplex to solve the LP"]
    pub fn SCIPlpiSolvePrimal(lpi: *mut SCIP_LPI) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls dual simplex to solve the LP"]
    pub fn SCIPlpiSolveDual(lpi: *mut SCIP_LPI) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls barrier or interior point algorithm to solve the LP with crossover to simplex basis"]
    pub fn SCIPlpiSolveBarrier(
        lpi: *mut SCIP_LPI,
        crossover: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " start strong branching - call before any strong branching"]
    pub fn SCIPlpiStartStrongbranch(lpi: *mut SCIP_LPI) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " end strong branching - call after any strong branching"]
    pub fn SCIPlpiEndStrongbranch(lpi: *mut SCIP_LPI) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " performs strong branching iterations on one @b fractional candidate"]
    pub fn SCIPlpiStrongbranchFrac(
        lpi: *mut SCIP_LPI,
        col: ::std::os::raw::c_int,
        psol: f64,
        itlim: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        iter: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " performs strong branching iterations on given @b fractional candidates"]
    pub fn SCIPlpiStrongbranchesFrac(
        lpi: *mut SCIP_LPI,
        cols: *mut ::std::os::raw::c_int,
        ncols: ::std::os::raw::c_int,
        psols: *mut f64,
        itlim: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        iter: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " performs strong branching iterations on one candidate with @b integral value"]
    pub fn SCIPlpiStrongbranchInt(
        lpi: *mut SCIP_LPI,
        col: ::std::os::raw::c_int,
        psol: f64,
        itlim: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        iter: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " performs strong branching iterations on given candidates with @b integral values"]
    pub fn SCIPlpiStrongbranchesInt(
        lpi: *mut SCIP_LPI,
        cols: *mut ::std::os::raw::c_int,
        ncols: ::std::os::raw::c_int,
        psols: *mut f64,
        itlim: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        iter: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether a solve method was called after the last modification of the LP"]
    pub fn SCIPlpiWasSolved(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets information about primal and dual feasibility of the current LP solution"]
    #[doc = ""]
    #[doc = "  The feasibility information is with respect to the last solving call and it is only relevant if SCIPlpiWasSolved()"]
    #[doc = "  returns true. If the LP is changed, this information might be invalidated."]
    #[doc = ""]
    #[doc = "  Note that @p primalfeasible and @p dualfeasible should only return true if the solver has proved the respective LP to"]
    #[doc = "  be feasible. Thus, the return values should be equal to the values of SCIPlpiIsPrimalFeasible() and"]
    #[doc = "  SCIPlpiIsDualFeasible(), respectively. Note that if feasibility cannot be proved, they should return false (even if"]
    #[doc = "  the problem might actually be feasible)."]
    pub fn SCIPlpiGetSolFeasibility(
        lpi: *mut SCIP_LPI,
        primalfeasible: *mut ::std::os::raw::c_uint,
        dualfeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns TRUE iff LP is proven to have a primal unbounded ray (but not necessary a primal feasible point);"]
    #[doc = "  this does not necessarily mean, that the solver knows and can return the primal ray"]
    pub fn SCIPlpiExistsPrimalRay(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff LP is proven to have a primal unbounded ray (but not necessary a primal feasible point),"]
    #[doc = "  and the solver knows and can return the primal ray"]
    pub fn SCIPlpiHasPrimalRay(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff LP is proven to be primal unbounded"]
    pub fn SCIPlpiIsPrimalUnbounded(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff LP is proven to be primal infeasible"]
    pub fn SCIPlpiIsPrimalInfeasible(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff LP is proven to be primal feasible"]
    pub fn SCIPlpiIsPrimalFeasible(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff LP is proven to have a dual unbounded ray (but not necessary a dual feasible point);"]
    #[doc = "  this does not necessarily mean, that the solver knows and can return the dual ray"]
    pub fn SCIPlpiExistsDualRay(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff LP is proven to have a dual unbounded ray (but not necessary a dual feasible point),"]
    #[doc = "  and the solver knows and can return the dual ray"]
    pub fn SCIPlpiHasDualRay(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff LP is proven to be dual unbounded"]
    pub fn SCIPlpiIsDualUnbounded(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff LP is proven to be dual infeasible"]
    pub fn SCIPlpiIsDualInfeasible(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff LP is proven to be dual feasible"]
    pub fn SCIPlpiIsDualFeasible(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff LP was solved to optimality"]
    pub fn SCIPlpiIsOptimal(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff current LP solution is stable"]
    #[doc = ""]
    #[doc = "  This function should return true if the solution is reliable, i.e., feasible and optimal (or proven"]
    #[doc = "  infeasible/unbounded) with respect to the original problem. The optimality status might be with respect to a scaled"]
    #[doc = "  version of the problem, but the solution might not be feasible to the unscaled original problem; in this case,"]
    #[doc = "  SCIPlpiIsStable() should return false."]
    pub fn SCIPlpiIsStable(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff the objective limit was reached"]
    pub fn SCIPlpiIsObjlimExc(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff the iteration limit was reached"]
    pub fn SCIPlpiIsIterlimExc(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns TRUE iff the time limit was reached"]
    pub fn SCIPlpiIsTimelimExc(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the internal solution status of the solver"]
    pub fn SCIPlpiGetInternalStatus(lpi: *mut SCIP_LPI) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " tries to reset the internal status of the LP solver in order to ignore an instability of the last solving call"]
    pub fn SCIPlpiIgnoreInstability(
        lpi: *mut SCIP_LPI,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets objective value of solution"]
    pub fn SCIPlpiGetObjval(lpi: *mut SCIP_LPI, objval: *mut f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets primal and dual solution vectors for feasible LPs"]
    #[doc = ""]
    #[doc = "  Before calling this function, the caller must ensure that the LP has been solved to optimality, i.e., that"]
    #[doc = "  SCIPlpiIsOptimal() returns true."]
    pub fn SCIPlpiGetSol(
        lpi: *mut SCIP_LPI,
        objval: *mut f64,
        primsol: *mut f64,
        dualsol: *mut f64,
        activity: *mut f64,
        redcost: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets primal ray for unbounded LPs"]
    pub fn SCIPlpiGetPrimalRay(lpi: *mut SCIP_LPI, ray: *mut f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets dual Farkas proof for infeasibility"]
    pub fn SCIPlpiGetDualfarkas(lpi: *mut SCIP_LPI, dualfarkas: *mut f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the number of LP iterations of the last solve call"]
    pub fn SCIPlpiGetIterations(
        lpi: *mut SCIP_LPI,
        iterations: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets information about the quality of an LP solution"]
    #[doc = ""]
    #[doc = "  Such information is usually only available, if also a (maybe not optimal) solution is available."]
    #[doc = "  The LPI should return SCIP_INVALID for @p quality, if the requested quantity is not available."]
    pub fn SCIPlpiGetRealSolQuality(
        lpi: *mut SCIP_LPI,
        qualityindicator: SCIP_LPSOLQUALITY,
        quality: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets current basis status for columns and rows; arrays must be large enough to store the basis status"]
    pub fn SCIPlpiGetBase(
        lpi: *mut SCIP_LPI,
        cstat: *mut ::std::os::raw::c_int,
        rstat: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets current basis status for columns and rows"]
    pub fn SCIPlpiSetBase(
        lpi: *mut SCIP_LPI,
        cstat: *const ::std::os::raw::c_int,
        rstat: *const ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the indices of the basic columns and rows; basic column n gives value n, basic row m gives value -1-m"]
    pub fn SCIPlpiGetBasisInd(lpi: *mut SCIP_LPI, bind: *mut ::std::os::raw::c_int)
        -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get row of inverse basis matrix B^-1"]
    #[doc = ""]
    #[doc = "  @note The LP interface defines slack variables to have coefficient +1. This means that if, internally, the LP solver"]
    #[doc = "        uses a -1 coefficient, then rows associated with slacks variables whose coefficient is -1, should be negated;"]
    #[doc = "        see also the explanation in lpi.h."]
    pub fn SCIPlpiGetBInvRow(
        lpi: *mut SCIP_LPI,
        r: ::std::os::raw::c_int,
        coef: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get column of inverse basis matrix B^-1"]
    #[doc = ""]
    #[doc = "  @note The LP interface defines slack variables to have coefficient +1. This means that if, internally, the LP solver"]
    #[doc = "        uses a -1 coefficient, then rows associated with slacks variables whose coefficient is -1, should be negated;"]
    #[doc = "        see also the explanation in lpi.h."]
    pub fn SCIPlpiGetBInvCol(
        lpi: *mut SCIP_LPI,
        c: ::std::os::raw::c_int,
        coef: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get row of inverse basis matrix times constraint matrix B^-1 * A"]
    #[doc = ""]
    #[doc = "  @note The LP interface defines slack variables to have coefficient +1. This means that if, internally, the LP solver"]
    #[doc = "        uses a -1 coefficient, then rows associated with slacks variables whose coefficient is -1, should be negated;"]
    #[doc = "        see also the explanation in lpi.h."]
    pub fn SCIPlpiGetBInvARow(
        lpi: *mut SCIP_LPI,
        r: ::std::os::raw::c_int,
        binvrow: *const f64,
        coef: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get column of inverse basis matrix times constraint matrix B^-1 * A"]
    #[doc = ""]
    #[doc = "  @note The LP interface defines slack variables to have coefficient +1. This means that if, internally, the LP solver"]
    #[doc = "        uses a -1 coefficient, then rows associated with slacks variables whose coefficient is -1, should be negated;"]
    #[doc = "        see also the explanation in lpi.h."]
    pub fn SCIPlpiGetBInvACol(
        lpi: *mut SCIP_LPI,
        c: ::std::os::raw::c_int,
        coef: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " stores LPi state (like basis information) into lpistate object"]
    pub fn SCIPlpiGetState(
        lpi: *mut SCIP_LPI,
        blkmem: *mut BMS_BLKMEM,
        lpistate: *mut *mut SCIP_LPISTATE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " loads LPi state (like basis information) into solver; note that the LP might have been extended with additional"]
    #[doc = "  columns and rows since the state was stored with SCIPlpiGetState()"]
    pub fn SCIPlpiSetState(
        lpi: *mut SCIP_LPI,
        blkmem: *mut BMS_BLKMEM,
        lpistate: *const SCIP_LPISTATE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " clears current LPi state (like basis information) of the solver"]
    pub fn SCIPlpiClearState(lpi: *mut SCIP_LPI) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees LPi state information"]
    pub fn SCIPlpiFreeState(
        lpi: *mut SCIP_LPI,
        blkmem: *mut BMS_BLKMEM,
        lpistate: *mut *mut SCIP_LPISTATE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks, whether the given LPi state contains simplex basis information"]
    pub fn SCIPlpiHasStateBasis(
        lpi: *mut SCIP_LPI,
        lpistate: *mut SCIP_LPISTATE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " reads LPi state (like basis information from a file"]
    pub fn SCIPlpiReadState(
        lpi: *mut SCIP_LPI,
        fname: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes LPi state (i.e. basis information) to a file"]
    pub fn SCIPlpiWriteState(
        lpi: *mut SCIP_LPI,
        fname: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " stores LPi pricing norms into lpinorms object"]
    pub fn SCIPlpiGetNorms(
        lpi: *mut SCIP_LPI,
        blkmem: *mut BMS_BLKMEM,
        lpinorms: *mut *mut SCIP_LPINORMS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " loads LPi pricing norms into solver; note that the LP might have been extended with additional"]
    #[doc = "  columns and rows since the norms were stored with SCIPlpiGetNorms()"]
    pub fn SCIPlpiSetNorms(
        lpi: *mut SCIP_LPI,
        blkmem: *mut BMS_BLKMEM,
        lpinorms: *const SCIP_LPINORMS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees LPi pricing norms information"]
    pub fn SCIPlpiFreeNorms(
        lpi: *mut SCIP_LPI,
        blkmem: *mut BMS_BLKMEM,
        lpinorms: *mut *mut SCIP_LPINORMS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets integer parameter of LP"]
    pub fn SCIPlpiGetIntpar(
        lpi: *mut SCIP_LPI,
        type_: SCIP_LPPARAM,
        ival: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets integer parameter of LP"]
    pub fn SCIPlpiSetIntpar(
        lpi: *mut SCIP_LPI,
        type_: SCIP_LPPARAM,
        ival: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets floating point parameter of LP"]
    pub fn SCIPlpiGetRealpar(
        lpi: *mut SCIP_LPI,
        type_: SCIP_LPPARAM,
        dval: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets floating point parameter of LP"]
    pub fn SCIPlpiSetRealpar(lpi: *mut SCIP_LPI, type_: SCIP_LPPARAM, dval: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns value treated as infinity in the LP solver"]
    pub fn SCIPlpiInfinity(lpi: *mut SCIP_LPI) -> f64;
}
extern "C" {
    #[doc = " checks if given value is treated as infinity in the LP solver"]
    pub fn SCIPlpiIsInfinity(lpi: *mut SCIP_LPI, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " reads LP from a file"]
    pub fn SCIPlpiReadLP(lpi: *mut SCIP_LPI, fname: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes LP to a file"]
    pub fn SCIPlpiWriteLP(lpi: *mut SCIP_LPI, fname: *const ::std::os::raw::c_char)
        -> SCIP_RETCODE;
}
#[doc = " interval given by infimum and supremum"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_Interval {
    #[doc = "< infimum (lower bound) of interval"]
    pub inf: f64,
    #[doc = "< supremum (upper bound) of interval"]
    pub sup: f64,
}
#[test]
fn bindgen_test_layout_SCIP_Interval() {
    assert_eq!(
        ::std::mem::size_of::<SCIP_Interval>(),
        16usize,
        concat!("Size of: ", stringify!(SCIP_Interval))
    );
    assert_eq!(
        ::std::mem::align_of::<SCIP_Interval>(),
        8usize,
        concat!("Alignment of ", stringify!(SCIP_Interval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCIP_Interval>())).inf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_Interval),
            "::",
            stringify!(inf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCIP_Interval>())).sup as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_Interval),
            "::",
            stringify!(sup)
        )
    );
}
pub type SCIP_INTERVAL = SCIP_Interval;
#[doc = " rounding mode of floating point operations (upwards, downwards, nearest, ...)"]
#[doc = " exact values depend on machine and compiler, so we define a corresponding enum in the header file"]
pub type SCIP_ROUNDMODE = ::std::os::raw::c_int;
extern "C" {
    #[doc = " returns whether rounding mode control is available"]
    pub fn SCIPintervalHasRoundingControl() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets rounding mode of floating point operations"]
    pub fn SCIPintervalSetRoundingMode(roundmode: SCIP_ROUNDMODE);
}
extern "C" {
    #[doc = " gets current rounding mode of floating point operations"]
    pub fn SCIPintervalGetRoundingMode() -> SCIP_ROUNDMODE;
}
extern "C" {
    #[doc = " sets rounding mode of floating point operations to downwards rounding"]
    pub fn SCIPintervalSetRoundingModeDownwards();
}
extern "C" {
    #[doc = " sets rounding mode of floating point operations to upwards rounding"]
    pub fn SCIPintervalSetRoundingModeUpwards();
}
extern "C" {
    #[doc = " sets rounding mode of floating point operations to nearest rounding"]
    pub fn SCIPintervalSetRoundingModeToNearest();
}
extern "C" {
    #[doc = " sets rounding mode of floating point operations to towards zero rounding"]
    pub fn SCIPintervalSetRoundingModeTowardsZero();
}
extern "C" {
    #[doc = " negates a number in a way that the compiler does not optimize it away"]
    pub fn SCIPintervalNegateReal(x: f64) -> f64;
}
extern "C" {
    #[doc = " returns infimum of interval"]
    pub fn SCIPintervalGetInf(interval: SCIP_INTERVAL) -> f64;
}
extern "C" {
    #[doc = " returns supremum of interval"]
    pub fn SCIPintervalGetSup(interval: SCIP_INTERVAL) -> f64;
}
extern "C" {
    #[doc = " stores given value as interval"]
    pub fn SCIPintervalSet(resultant: *mut SCIP_INTERVAL, value: f64);
}
extern "C" {
    #[doc = " stores given infimum and supremum as interval"]
    pub fn SCIPintervalSetBounds(resultant: *mut SCIP_INTERVAL, inf: f64, sup: f64);
}
extern "C" {
    #[doc = " sets interval to empty interval, which will be [1.0, -1.0]"]
    pub fn SCIPintervalSetEmpty(resultant: *mut SCIP_INTERVAL);
}
extern "C" {
    #[doc = " indicates whether interval is empty, i.e., whether inf > sup"]
    pub fn SCIPintervalIsEmpty(infinity: f64, operand: SCIP_INTERVAL) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets interval to entire [-infinity, +infinity]"]
    pub fn SCIPintervalSetEntire(infinity: f64, resultant: *mut SCIP_INTERVAL);
}
extern "C" {
    #[doc = " indicates whether interval is entire, i.e., whether inf <= -infinity and sup >= infinity"]
    pub fn SCIPintervalIsEntire(infinity: f64, operand: SCIP_INTERVAL) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " indicates whether interval is positive infinity, i.e., [infinity, infinity]"]
    pub fn SCIPintervalIsPositiveInfinity(
        infinity: f64,
        operand: SCIP_INTERVAL,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " indicates whether interval is negative infinity, i.e., [-infinity, -infinity]"]
    pub fn SCIPintervalIsNegativeInfinity(
        infinity: f64,
        operand: SCIP_INTERVAL,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " indicates whether operand1 is contained in operand2"]
    pub fn SCIPintervalIsSubsetEQ(
        infinity: f64,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " indicates whether operand1 and operand2 are disjoint"]
    pub fn SCIPintervalAreDisjoint(
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " intersection of two intervals"]
    pub fn SCIPintervalIntersect(
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " interval enclosure of the union of two intervals"]
    pub fn SCIPintervalUnify(
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " adds operand1 and operand2 and stores infimum of result in infimum of resultant"]
    pub fn SCIPintervalAddInf(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " adds operand1 and operand2 and stores supremum of result in supremum of resultant"]
    pub fn SCIPintervalAddSup(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " adds operand1 and operand2 and stores result in resultant"]
    pub fn SCIPintervalAdd(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " adds operand1 and scalar operand2 and stores result in resultant"]
    pub fn SCIPintervalAddScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
extern "C" {
    #[doc = " adds vector operand1 and vector operand2 and stores result in vector resultant"]
    pub fn SCIPintervalAddVectors(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        length: ::std::os::raw::c_int,
        operand1: *mut SCIP_INTERVAL,
        operand2: *mut SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " subtracts operand2 from operand1 and stores result in resultant"]
    pub fn SCIPintervalSub(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " subtracts scalar operand2 from operand1 and stores result in resultant"]
    pub fn SCIPintervalSubScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
extern "C" {
    #[doc = " multiplies operand1 with operand2 and stores infimum of result in infimum of resultant"]
    pub fn SCIPintervalMulInf(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " multiplies operand1 with operand2 and stores supremum of result in supremum of resultant"]
    pub fn SCIPintervalMulSup(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " multiplies operand1 with operand2 and stores result in resultant"]
    pub fn SCIPintervalMul(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " multiplies operand1 with scalar operand2 and stores infimum of result in infimum of resultant"]
    pub fn SCIPintervalMulScalarInf(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
extern "C" {
    #[doc = " multiplies operand1 with scalar operand2 and stores supremum of result in supremum of resultant"]
    pub fn SCIPintervalMulScalarSup(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
extern "C" {
    #[doc = " multiplies operand1 with scalar operand2 and stores result in resultant"]
    pub fn SCIPintervalMulScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
extern "C" {
    #[doc = " divides operand1 by operand2 and stores result in resultant"]
    pub fn SCIPintervalDiv(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " divides operand1 by scalar operand2 and stores result in resultant"]
    pub fn SCIPintervalDivScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
extern "C" {
    #[doc = " computes the scalar product of two vectors of intervals and stores result in resultant"]
    pub fn SCIPintervalScalprod(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        length: ::std::os::raw::c_int,
        operand1: *mut SCIP_INTERVAL,
        operand2: *mut SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " computes the scalar product of a vector of intervals and a vector of scalars and stores infimum of result in infimum"]
    #[doc = "  of resultant"]
    pub fn SCIPintervalScalprodScalarsInf(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        length: ::std::os::raw::c_int,
        operand1: *mut SCIP_INTERVAL,
        operand2: *mut f64,
    );
}
extern "C" {
    #[doc = " computes the scalar product of a vector of intervals and a vector of scalars and stores supremum of result in supremum"]
    #[doc = "  of resultant"]
    pub fn SCIPintervalScalprodScalarsSup(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        length: ::std::os::raw::c_int,
        operand1: *mut SCIP_INTERVAL,
        operand2: *mut f64,
    );
}
extern "C" {
    #[doc = " computes the scalar product of a vector of intervals and a vector of scalars and stores result in resultant"]
    pub fn SCIPintervalScalprodScalars(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        length: ::std::os::raw::c_int,
        operand1: *mut SCIP_INTERVAL,
        operand2: *mut f64,
    );
}
extern "C" {
    #[doc = " squares operand and stores result in resultant"]
    pub fn SCIPintervalSquare(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
extern "C" {
    #[doc = " stores (positive part of) square root of operand in resultant"]
    #[doc = " @attention we assume a correctly rounded sqrt(double) function when rounding is to nearest"]
    pub fn SCIPintervalSquareRoot(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " stores operand1 to the power of operand2 in resultant"]
    #[doc = ""]
    #[doc = " uses SCIPintervalPowerScalar if operand2 is a scalar, otherwise computes exp(op2*log(op1))"]
    pub fn SCIPintervalPower(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " stores operand1 to the power of the scalar operand2 in resultant"]
    pub fn SCIPintervalPowerScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
extern "C" {
    #[doc = " stores bounds on the power of a scalar operand1 to a scalar operand2 in resultant"]
    #[doc = " both operands need to be finite numbers"]
    #[doc = " need to have operand1 >= 0 or operand2 integer and need to have operand2 >= 0 if operand1 == 0"]
    #[doc = " @attention we assume a correctly rounded pow(double) function when rounding is to nearest"]
    pub fn SCIPintervalPowerScalarScalar(
        resultant: *mut SCIP_INTERVAL,
        operand1: f64,
        operand2: f64,
    );
}
extern "C" {
    #[doc = " computes lower bound on power of a scalar operand1 to an integer operand2"]
    #[doc = " both operands need to be finite numbers"]
    #[doc = " need to have operand1 >= 0 and need to have operand2 >= 0 if operand1 == 0"]
    pub fn SCIPintervalPowerScalarIntegerInf(operand1: f64, operand2: ::std::os::raw::c_int)
        -> f64;
}
extern "C" {
    #[doc = " computes upper bound on power of a scalar operand1 to an integer operand2"]
    #[doc = " both operands need to be finite numbers"]
    #[doc = " need to have operand1 >= 0 and need to have operand2 >= 0 if operand1 == 0"]
    pub fn SCIPintervalPowerScalarIntegerSup(operand1: f64, operand2: ::std::os::raw::c_int)
        -> f64;
}
extern "C" {
    #[doc = " computes bounds on power of a scalar operand1 to an integer operand2"]
    #[doc = " both operands need to be finite numbers"]
    #[doc = " need to have operand1 >= 0 and need to have operand2 >= 0 if operand1 == 0"]
    pub fn SCIPintervalPowerScalarInteger(
        resultant: *mut SCIP_INTERVAL,
        operand1: f64,
        operand2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " given an interval for the image of a power operation, computes an interval for the origin"]
    #[doc = " that is, for y = x^p with p = exponent a given scalar and y = image a given interval,"]
    #[doc = " computes a subinterval x of basedomain such that y in x^p and such that for all z in basedomain less x, z^p not in y"]
    pub fn SCIPintervalPowerScalarInverse(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        basedomain: SCIP_INTERVAL,
        exponent: f64,
        image: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " stores operand1 to the signed power of the scalar positive operand2 in resultant"]
    #[doc = ""]
    #[doc = " the signed power of x w.r.t. an exponent n >= 0 is given as sign(x) * abs(x)^n"]
    #[doc = ""]
    #[doc = " @attention we assume correctly rounded sqrt(double) and pow(double) functions when rounding is to nearest"]
    pub fn SCIPintervalSignPowerScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: f64,
    );
}
extern "C" {
    #[doc = " computes the reciprocal of an interval"]
    pub fn SCIPintervalReciprocal(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " stores exponential of operand in resultant"]
    #[doc = " @attention we assume a correctly rounded exp(double) function when rounding is to nearest"]
    pub fn SCIPintervalExp(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
extern "C" {
    #[doc = " stores natural logarithm of operand in resultant"]
    #[doc = " @attention we assume a correctly rounded log(double) function when rounding is to nearest"]
    pub fn SCIPintervalLog(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
extern "C" {
    #[doc = " stores minimum of operands in resultant"]
    pub fn SCIPintervalMin(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " stores maximum of operands in resultant"]
    pub fn SCIPintervalMax(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        operand1: SCIP_INTERVAL,
        operand2: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " stores absolute value of operand in resultant"]
    pub fn SCIPintervalAbs(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
extern "C" {
    #[doc = " stores sine value of operand in resultant"]
    #[doc = " NOTE: the operations are not applied rounding-safe here"]
    pub fn SCIPintervalSin(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
extern "C" {
    #[doc = " stores cosine value of operand in resultant"]
    #[doc = " NOTE: the operations are not applied rounding-safe here"]
    pub fn SCIPintervalCos(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
extern "C" {
    #[doc = " stores sign of operand in resultant"]
    pub fn SCIPintervalSign(infinity: f64, resultant: *mut SCIP_INTERVAL, operand: SCIP_INTERVAL);
}
extern "C" {
    #[doc = " computes exact upper bound on \\f$ a x^2 + b x \\f$ for x in [xlb, xub], b an interval, and a scalar"]
    #[doc = ""]
    #[doc = " Uses Algorithm 2.2 from Domes and Neumaier: Constraint propagation on quadratic constraints (2008)"]
    pub fn SCIPintervalQuadUpperBound(
        infinity: f64,
        a: f64,
        b_: SCIP_INTERVAL,
        x: SCIP_INTERVAL,
    ) -> f64;
}
extern "C" {
    #[doc = " stores range of quadratic term in resultant"]
    #[doc = ""]
    #[doc = " given scalar a and intervals b and x, computes interval for \\f$ a x^2 + b x \\f$"]
    pub fn SCIPintervalQuad(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        sqrcoeff: f64,
        lincoeff: SCIP_INTERVAL,
        xrng: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " computes interval with positive solutions of a quadratic equation with interval coefficients"]
    #[doc = ""]
    #[doc = " Given intervals a, b, and c, this function computes an interval that contains all positive solutions of \\f$ a x^2 + b x \\in c\\f$ within xbnds."]
    pub fn SCIPintervalSolveUnivariateQuadExpressionPositive(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        sqrcoeff: SCIP_INTERVAL,
        lincoeff: SCIP_INTERVAL,
        rhs: SCIP_INTERVAL,
        xbnds: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " computes interval with negative solutions of a quadratic equation with interval coefficients"]
    #[doc = ""]
    #[doc = " Given intervals a, b, and c, this function computes an interval that contains all negative solutions of \\f$ a x^2 + b x \\in c\\f$ within xbnds."]
    pub fn SCIPintervalSolveUnivariateQuadExpressionNegative(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        sqrcoeff: SCIP_INTERVAL,
        lincoeff: SCIP_INTERVAL,
        rhs: SCIP_INTERVAL,
        xbnds: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " computes positive solutions of a quadratic equation with scalar coefficients"]
    #[doc = ""]
    #[doc = " Given scalar a, b, and c, this function computes an interval that contains all positive solutions of \\f$ a x^2 + b x \\geq c\\f$ within xbnds."]
    #[doc = " Implements Algorithm 3.2 from Domes and Neumaier: Constraint propagation on quadratic constraints (2008)."]
    pub fn SCIPintervalSolveUnivariateQuadExpressionPositiveAllScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        sqrcoeff: f64,
        lincoeff: f64,
        rhs: f64,
        xbnds: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " solves a quadratic equation with interval coefficients"]
    #[doc = ""]
    #[doc = " Given intervals a, b and c, this function computes an interval that contains all solutions of \\f$ a x^2 + b x \\in c\\f$ within xbnds"]
    pub fn SCIPintervalSolveUnivariateQuadExpression(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        sqrcoeff: SCIP_INTERVAL,
        lincoeff: SCIP_INTERVAL,
        rhs: SCIP_INTERVAL,
        xbnds: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " stores range of bivariate quadratic term in resultant"]
    #[doc = " given scalars ax, ay, axy, bx, and by and intervals for x and y, computes interval for \\f$ ax x^2 + ay y^2 + axy x y + bx x + by y \\f$"]
    #[doc = " NOTE: the operations are not applied rounding-safe here"]
    pub fn SCIPintervalQuadBivar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        ax: f64,
        ay: f64,
        axy: f64,
        bx: f64,
        by: f64,
        xbnds: SCIP_INTERVAL,
        ybnds: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " solves a bivariate quadratic equation for the first variable"]
    #[doc = " given scalars ax, ay, axy, bx and by, and intervals for x, y, and rhs,"]
    #[doc = " computes \\f$ \\{ x \\in \\mathbf{x} : \\exists y \\in \\mathbf{y} : a_x x^2 + a_y y^2 + a_{xy} x y + b_x x + b_y y \\in \\mathbf{\\mbox{rhs}} \\} \\f$"]
    #[doc = " NOTE: the operations are not applied rounding-safe here"]
    pub fn SCIPintervalSolveBivariateQuadExpressionAllScalar(
        infinity: f64,
        resultant: *mut SCIP_INTERVAL,
        ax: f64,
        ay: f64,
        axy: f64,
        bx: f64,
        by: f64,
        rhs: SCIP_INTERVAL,
        xbnds: SCIP_INTERVAL,
        ybnds: SCIP_INTERVAL,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ExprInt {
    _unused: [u8; 0],
}
pub type SCIP_EXPRINT = SCIP_ExprInt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_ExprIntData {
    _unused: [u8; 0],
}
pub type SCIP_EXPRINTDATA = SCIP_ExprIntData;
pub type SCIP_EXPRINTCAPABILITY = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " gives curvature for a sum of two functions with given curvature"]
    pub fn SCIPexprcurvAdd(curv1: SCIP_EXPRCURV, curv2: SCIP_EXPRCURV) -> SCIP_EXPRCURV;
}
extern "C" {
    #[doc = " gives the curvature for the negation of a function with given curvature"]
    pub fn SCIPexprcurvNegate(curvature: SCIP_EXPRCURV) -> SCIP_EXPRCURV;
}
extern "C" {
    #[doc = " gives curvature for a functions with given curvature multiplied by a constant factor"]
    pub fn SCIPexprcurvMultiply(factor: f64, curvature: SCIP_EXPRCURV) -> SCIP_EXPRCURV;
}
extern "C" {
    #[doc = " gives curvature for base^exponent for given bounds and curvature of base-function and constant exponent"]
    pub fn SCIPexprcurvPower(
        basebounds: SCIP_INTERVAL,
        basecurv: SCIP_EXPRCURV,
        exponent: f64,
    ) -> SCIP_EXPRCURV;
}
extern "C" {
    #[doc = " gives curvature for a monomial with given curvatures and bounds for each factor"]
    pub fn SCIPexprcurvMonomial(
        nfactors: ::std::os::raw::c_int,
        exponents: *mut f64,
        factoridxs: *mut ::std::os::raw::c_int,
        factorcurv: *mut SCIP_EXPRCURV,
        factorbounds: *mut SCIP_INTERVAL,
    ) -> SCIP_EXPRCURV;
}
extern "C" {
    #[doc = " gives name as string for a curvature"]
    pub fn SCIPexprcurvGetName(curv: SCIP_EXPRCURV) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gives the name of an operand"]
    pub fn SCIPexpropGetName(op: SCIP_EXPROP) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " gives the number of children of a simple operand"]
    #[doc = " @return -1 for invalid operands and -2 for complex operands (those where the number of children depends on the expression)"]
    pub fn SCIPexpropGetNChildren(op: SCIP_EXPROP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives operator of expression"]
    pub fn SCIPexprGetOperator(expr: *mut SCIP_EXPR) -> SCIP_EXPROP;
}
extern "C" {
    #[doc = " gives number of children of an expression"]
    pub fn SCIPexprGetNChildren(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives pointer to array with children of an expression"]
    pub fn SCIPexprGetChildren(expr: *mut SCIP_EXPR) -> *mut *mut SCIP_EXPR;
}
extern "C" {
    #[doc = " gives index belonging to a SCIP_EXPR_VARIDX or SCIP_EXPR_PARAM operand"]
    pub fn SCIPexprGetOpIndex(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives real belonging to a SCIP_EXPR_CONST operand"]
    pub fn SCIPexprGetOpReal(expr: *mut SCIP_EXPR) -> f64;
}
extern "C" {
    #[doc = " gives void* belonging to a complex operand"]
    pub fn SCIPexprGetOpData(expr: *mut SCIP_EXPR) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " gives exponent belonging to a SCIP_EXPR_REALPOWER expression"]
    pub fn SCIPexprGetRealPowerExponent(expr: *mut SCIP_EXPR) -> f64;
}
extern "C" {
    #[doc = " gives exponent belonging to a SCIP_EXPR_INTPOWER expression"]
    pub fn SCIPexprGetIntPowerExponent(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives exponent belonging to a SCIP_EXPR_SIGNPOWER expression"]
    pub fn SCIPexprGetSignPowerExponent(expr: *mut SCIP_EXPR) -> f64;
}
extern "C" {
    #[doc = " gives linear coefficients belonging to a SCIP_EXPR_LINEAR expression"]
    pub fn SCIPexprGetLinearCoefs(expr: *mut SCIP_EXPR) -> *mut f64;
}
extern "C" {
    #[doc = " gives constant belonging to a SCIP_EXPR_LINEAR expression"]
    pub fn SCIPexprGetLinearConstant(expr: *mut SCIP_EXPR) -> f64;
}
extern "C" {
    #[doc = " gives quadratic elements belonging to a SCIP_EXPR_QUADRATIC expression"]
    pub fn SCIPexprGetQuadElements(expr: *mut SCIP_EXPR) -> *mut SCIP_QUADELEM;
}
extern "C" {
    #[doc = " gives constant belonging to a SCIP_EXPR_QUADRATIC expression"]
    pub fn SCIPexprGetQuadConstant(expr: *mut SCIP_EXPR) -> f64;
}
extern "C" {
    #[doc = " gives linear coefficients belonging to a SCIP_EXPR_QUADRATIC expression"]
    #[doc = " can be NULL if all coefficients are 0.0"]
    pub fn SCIPexprGetQuadLinearCoefs(expr: *mut SCIP_EXPR) -> *mut f64;
}
extern "C" {
    #[doc = " gives number of quadratic elements belonging to a SCIP_EXPR_QUADRATIC expression"]
    pub fn SCIPexprGetNQuadElements(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives the monomials belonging to a SCIP_EXPR_POLYNOMIAL expression"]
    pub fn SCIPexprGetMonomials(expr: *mut SCIP_EXPR) -> *mut *mut SCIP_EXPRDATA_MONOMIAL;
}
extern "C" {
    #[doc = " gives the number of monomials belonging to a SCIP_EXPR_POLYNOMIAL expression"]
    pub fn SCIPexprGetNMonomials(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives the constant belonging to a SCIP_EXPR_POLYNOMIAL expression"]
    pub fn SCIPexprGetPolynomialConstant(expr: *mut SCIP_EXPR) -> f64;
}
extern "C" {
    #[doc = " gets coefficient of a monomial"]
    pub fn SCIPexprGetMonomialCoef(monomial: *mut SCIP_EXPRDATA_MONOMIAL) -> f64;
}
extern "C" {
    #[doc = " gets number of factors of a monomial"]
    pub fn SCIPexprGetMonomialNFactors(
        monomial: *mut SCIP_EXPRDATA_MONOMIAL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets indices of children corresponding to factors of a monomial"]
    pub fn SCIPexprGetMonomialChildIndices(
        monomial: *mut SCIP_EXPRDATA_MONOMIAL,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets exponents in factors of a monomial"]
    pub fn SCIPexprGetMonomialExponents(monomial: *mut SCIP_EXPRDATA_MONOMIAL) -> *mut f64;
}
extern "C" {
    #[doc = " gets user data of a user expression"]
    pub fn SCIPexprGetUserData(expr: *mut SCIP_EXPR) -> *mut SCIP_USEREXPRDATA;
}
extern "C" {
    #[doc = " indicates whether a user expression has the estimator callback defined"]
    pub fn SCIPexprHasUserEstimator(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gives the evaluation capability of a user expression"]
    pub fn SCIPexprGetUserEvalCapability(expr: *mut SCIP_EXPR) -> SCIP_EXPRINTCAPABILITY;
}
extern "C" {
    #[doc = " creates a simple expression"]
    pub fn SCIPexprCreate(
        blkmem: *mut BMS_BLKMEM,
        expr: *mut *mut SCIP_EXPR,
        op: SCIP_EXPROP,
        ...
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies an expression including its children"]
    pub fn SCIPexprCopyDeep(
        blkmem: *mut BMS_BLKMEM,
        targetexpr: *mut *mut SCIP_EXPR,
        sourceexpr: *mut SCIP_EXPR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees an expression including its children"]
    pub fn SCIPexprFreeDeep(blkmem: *mut BMS_BLKMEM, expr: *mut *mut SCIP_EXPR);
}
extern "C" {
    #[doc = " frees an expression but not its children"]
    pub fn SCIPexprFreeShallow(blkmem: *mut BMS_BLKMEM, expr: *mut *mut SCIP_EXPR);
}
extern "C" {
    #[doc = " creates an expression from the addition of two given expression, with coefficients, and a constant"]
    #[doc = ""]
    #[doc = " the given expressions may be modified or freed, otherwise it will be used a child expression"]
    #[doc = " favors creation and maintaining of SCIP_EXPR_LINEAR over SCIP_EXPR_PLUS or SCIP_EXPR_SUM"]
    pub fn SCIPexprAdd(
        blkmem: *mut BMS_BLKMEM,
        expr: *mut *mut SCIP_EXPR,
        coef1: f64,
        term1: *mut SCIP_EXPR,
        coef2: f64,
        term2: *mut SCIP_EXPR,
        constant: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates an expression from the multiplication of an expression with a constant"]
    #[doc = ""]
    #[doc = " the given expressions may be modified or freed, otherwise it will be used a child expression"]
    #[doc = " favors creation of SCIP_EXPR_LINEAR over SCIP_EXPR_MUP or SCIP_EXPR_PROD"]
    pub fn SCIPexprMulConstant(
        blkmem: *mut BMS_BLKMEM,
        expr: *mut *mut SCIP_EXPR,
        term: *mut SCIP_EXPR,
        factor: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a SCIP_EXPR_LINEAR expression that is (affine) linear in its children: constant + sum_i coef_i child_i"]
    pub fn SCIPexprCreateLinear(
        blkmem: *mut BMS_BLKMEM,
        expr: *mut *mut SCIP_EXPR,
        nchildren: ::std::os::raw::c_int,
        children: *mut *mut SCIP_EXPR,
        coefs: *mut f64,
        constant: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds new terms to a linear expression"]
    pub fn SCIPexprAddToLinear(
        blkmem: *mut BMS_BLKMEM,
        expr: *mut SCIP_EXPR,
        nchildren: ::std::os::raw::c_int,
        coefs: *mut f64,
        children: *mut *mut SCIP_EXPR,
        constant: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a SCIP_EXPR_QUADRATIC expression: constant + sum_i coef_i child_i + sum_i coef_i child1_i child2_i"]
    pub fn SCIPexprCreateQuadratic(
        blkmem: *mut BMS_BLKMEM,
        expr: *mut *mut SCIP_EXPR,
        nchildren: ::std::os::raw::c_int,
        children: *mut *mut SCIP_EXPR,
        constant: f64,
        lincoefs: *mut f64,
        nquadelems: ::std::os::raw::c_int,
        quadelems: *mut SCIP_QUADELEM,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " ensures that quadratic elements of a quadratic expression are sorted"]
    pub fn SCIPexprSortQuadElems(expr: *mut SCIP_EXPR);
}
extern "C" {
    #[doc = " creates a SCIP_EXPR_POLYNOMIAL expression from an array of monomials: constant + sum_i monomial_i"]
    pub fn SCIPexprCreatePolynomial(
        blkmem: *mut BMS_BLKMEM,
        expr: *mut *mut SCIP_EXPR,
        nchildren: ::std::os::raw::c_int,
        children: *mut *mut SCIP_EXPR,
        nmonomials: ::std::os::raw::c_int,
        monomials: *mut *mut SCIP_EXPRDATA_MONOMIAL,
        constant: f64,
        copymonomials: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds an array of monomials to a SCIP_EXPR_POLYNOMIAL expression"]
    pub fn SCIPexprAddMonomials(
        blkmem: *mut BMS_BLKMEM,
        expr: *mut SCIP_EXPR,
        nmonomials: ::std::os::raw::c_int,
        monomials: *mut *mut SCIP_EXPRDATA_MONOMIAL,
        copymonomials: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the constant in a SCIP_EXPR_POLYNOMIAL expression"]
    pub fn SCIPexprChgPolynomialConstant(expr: *mut SCIP_EXPR, constant: f64);
}
extern "C" {
    #[doc = " multiplies each summand of a polynomial by a given constant"]
    pub fn SCIPexprMultiplyPolynomialByConstant(
        blkmem: *mut BMS_BLKMEM,
        expr: *mut SCIP_EXPR,
        factor: f64,
    );
}
extern "C" {
    #[doc = " multiplies each summand of a polynomial by a given monomial"]
    pub fn SCIPexprMultiplyPolynomialByMonomial(
        blkmem: *mut BMS_BLKMEM,
        expr: *mut SCIP_EXPR,
        factor: *mut SCIP_EXPRDATA_MONOMIAL,
        childmap: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " multiplies this polynomial by a polynomial"]
    #[doc = " factor needs to be different from expr"]
    pub fn SCIPexprMultiplyPolynomialByPolynomial(
        blkmem: *mut BMS_BLKMEM,
        expr: *mut SCIP_EXPR,
        factor: *mut SCIP_EXPR,
        childmap: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " takes a power of the polynomial"]
    #[doc = " exponent need to be an integer"]
    #[doc = " polynomial need to be a monomial, if exponent is negative"]
    pub fn SCIPexprPolynomialPower(
        blkmem: *mut BMS_BLKMEM,
        expr: *mut SCIP_EXPR,
        exponent: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " merges monomials in a polynomial expression that differ only in coefficient into a single monomial"]
    #[doc = " eliminates monomials with coefficient between -eps and eps"]
    pub fn SCIPexprMergeMonomials(
        blkmem: *mut BMS_BLKMEM,
        expr: *mut SCIP_EXPR,
        eps: f64,
        mergefactors: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " creates a monomial"]
    pub fn SCIPexprCreateMonomial(
        blkmem: *mut BMS_BLKMEM,
        monomial: *mut *mut SCIP_EXPRDATA_MONOMIAL,
        coef: f64,
        nfactors: ::std::os::raw::c_int,
        childidxs: *mut ::std::os::raw::c_int,
        exponents: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a monomial"]
    pub fn SCIPexprFreeMonomial(
        blkmem: *mut BMS_BLKMEM,
        monomial: *mut *mut SCIP_EXPRDATA_MONOMIAL,
    );
}
extern "C" {
    #[doc = " ensures that factors in a monomial are sorted"]
    pub fn SCIPexprSortMonomialFactors(monomial: *mut SCIP_EXPRDATA_MONOMIAL);
}
extern "C" {
    #[doc = " finds a factor corresponding to a given child index in a monomial"]
    #[doc = " note that if the factors have not been merged, the position of some factor corresponding to a given child is given"]
    #[doc = " returns TRUE if a factor is found, FALSE if not"]
    pub fn SCIPexprFindMonomialFactor(
        monomial: *mut SCIP_EXPRDATA_MONOMIAL,
        childidx: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks if two monomials are equal"]
    pub fn SCIPexprAreMonomialsEqual(
        monomial1: *mut SCIP_EXPRDATA_MONOMIAL,
        monomial2: *mut SCIP_EXPRDATA_MONOMIAL,
        eps: f64,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " adds factors to a monomial"]
    pub fn SCIPexprAddMonomialFactors(
        blkmem: *mut BMS_BLKMEM,
        monomial: *mut SCIP_EXPRDATA_MONOMIAL,
        nfactors: ::std::os::raw::c_int,
        childidxs: *mut ::std::os::raw::c_int,
        exponents: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes coefficient of monomial"]
    pub fn SCIPexprChgMonomialCoef(monomial: *mut SCIP_EXPRDATA_MONOMIAL, newcoef: f64);
}
extern "C" {
    #[doc = " multiplies a monomial with a monomial"]
    pub fn SCIPexprMultiplyMonomialByMonomial(
        blkmem: *mut BMS_BLKMEM,
        monomial: *mut SCIP_EXPRDATA_MONOMIAL,
        factor: *mut SCIP_EXPRDATA_MONOMIAL,
        childmap: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " replaces the monomial by a power of the monomial"]
    #[doc = " allows only integers as exponent"]
    pub fn SCIPexprMonomialPower(
        monomial: *mut SCIP_EXPRDATA_MONOMIAL,
        exponent: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " merges factors that correspond to the same child by adding exponents"]
    #[doc = " eliminates factors with exponent between -eps and eps"]
    pub fn SCIPexprMergeMonomialFactors(monomial: *mut SCIP_EXPRDATA_MONOMIAL, eps: f64);
}
extern "C" {
    #[doc = " ensures that monomials of a polynomial are sorted"]
    pub fn SCIPexprSortMonomials(expr: *mut SCIP_EXPR);
}
extern "C" {
    #[doc = " creates a user expression"]
    pub fn SCIPexprCreateUser(
        blkmem: *mut BMS_BLKMEM,
        expr: *mut *mut SCIP_EXPR,
        nchildren: ::std::os::raw::c_int,
        children: *mut *mut SCIP_EXPR,
        data: *mut SCIP_USEREXPRDATA,
        evalcapability: SCIP_EXPRINTCAPABILITY,
        eval: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut SCIP_USEREXPRDATA,
                nargs: ::std::os::raw::c_int,
                argvals: *mut f64,
                funcvalue: *mut f64,
                gradient: *mut f64,
                hessian: *mut f64,
            ) -> SCIP_RETCODE,
        >,
        inteval: ::std::option::Option<
            unsafe extern "C" fn(
                infinity: f64,
                data: *mut SCIP_USEREXPRDATA,
                nargs: ::std::os::raw::c_int,
                argvals: *mut SCIP_INTERVAL,
                funcvalue: *mut SCIP_INTERVAL,
                gradient: *mut SCIP_INTERVAL,
                hessian: *mut SCIP_INTERVAL,
            ) -> SCIP_RETCODE,
        >,
        curv: ::std::option::Option<
            unsafe extern "C" fn(
                infinity: f64,
                data: *mut SCIP_USEREXPRDATA,
                nargs: ::std::os::raw::c_int,
                argbounds: *mut SCIP_INTERVAL,
                argcurv: *mut SCIP_EXPRCURV,
                result: *mut SCIP_EXPRCURV,
            ) -> SCIP_RETCODE,
        >,
        prop: ::std::option::Option<
            unsafe extern "C" fn(
                infinity: f64,
                data: *mut SCIP_USEREXPRDATA,
                nargs: ::std::os::raw::c_int,
                argbounds: *mut SCIP_INTERVAL,
                funcbounds: SCIP_INTERVAL,
                cutoff: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        estimate: ::std::option::Option<
            unsafe extern "C" fn(
                infinity: f64,
                data: *mut SCIP_USEREXPRDATA,
                nargs: ::std::os::raw::c_int,
                argvals: *mut f64,
                argbounds: *mut SCIP_INTERVAL,
                overestimate: ::std::os::raw::c_uint,
                coeffs: *mut f64,
                constant: *mut f64,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        copydata: ::std::option::Option<
            unsafe extern "C" fn(
                blkmem: *mut BMS_BLKMEM,
                nchildren: ::std::os::raw::c_int,
                datasource: *mut SCIP_USEREXPRDATA,
                datatarget: *mut *mut SCIP_USEREXPRDATA,
            ) -> SCIP_RETCODE,
        >,
        freedata: ::std::option::Option<
            unsafe extern "C" fn(
                blkmem: *mut BMS_BLKMEM,
                nchildren: ::std::os::raw::c_int,
                data: *mut SCIP_USEREXPRDATA,
            ),
        >,
        print: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut SCIP_USEREXPRDATA,
                messagehdlr: *mut SCIP_MESSAGEHDLR,
                file: *mut FILE,
            ),
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " indicates whether the expression contains a SCIP_EXPR_PARAM"]
    pub fn SCIPexprHasParam(expr: *mut SCIP_EXPR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets maximal degree of expression, or SCIP_EXPR_DEGREEINFINITY if not a polynomial"]
    pub fn SCIPexprGetMaxDegree(
        expr: *mut SCIP_EXPR,
        maxdegree: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " counts usage of variables in expression"]
    pub fn SCIPexprGetVarsUsage(expr: *mut SCIP_EXPR, varsusage: *mut ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " compares whether two expressions are the same"]
    #[doc = " inconclusive, i.e., may give FALSE even if expressions are equivalent (x*y != y*x)"]
    pub fn SCIPexprAreEqual(
        expr1: *mut SCIP_EXPR,
        expr2: *mut SCIP_EXPR,
        eps: f64,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " aims at simplifying an expression and splitting of a linear expression"]
    #[doc = " if linear variables are split off, expression interpreter data, if stored in the tree, is freed"]
    pub fn SCIPexprSimplify(
        blkmem: *mut BMS_BLKMEM,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        expr: *mut SCIP_EXPR,
        eps: f64,
        maxexpansionexponent: ::std::os::raw::c_int,
        nvars: ::std::os::raw::c_int,
        nlinvars: *mut ::std::os::raw::c_int,
        linidxs: *mut ::std::os::raw::c_int,
        lincoefs: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " evaluates an expression w.r.t. given values for children expressions"]
    pub fn SCIPexprEvalShallow(
        expr: *mut SCIP_EXPR,
        argvals: *mut f64,
        varvals: *mut f64,
        param: *mut f64,
        val: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " evaluates an expression w.r.t. a point"]
    pub fn SCIPexprEval(
        expr: *mut SCIP_EXPR,
        varvals: *mut f64,
        param: *mut f64,
        val: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " evaluates an expression w.r.t. given interval values for children expressions"]
    pub fn SCIPexprEvalIntShallow(
        expr: *mut SCIP_EXPR,
        infinity: f64,
        argvals: *mut SCIP_INTERVAL,
        varvals: *mut SCIP_INTERVAL,
        param: *mut f64,
        val: *mut SCIP_INTERVAL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " evaluates an expression w.r.t. an interval"]
    pub fn SCIPexprEvalInt(
        expr: *mut SCIP_EXPR,
        infinity: f64,
        varvals: *mut SCIP_INTERVAL,
        param: *mut f64,
        val: *mut SCIP_INTERVAL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " evaluates a user expression w.r.t. given values for children expressions"]
    pub fn SCIPexprEvalUser(
        expr: *mut SCIP_EXPR,
        argvals: *mut f64,
        val: *mut f64,
        gradient: *mut f64,
        hessian: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " evaluates a user expression w.r.t. an interval"]
    pub fn SCIPexprEvalIntUser(
        expr: *mut SCIP_EXPR,
        infinity: f64,
        argvals: *mut SCIP_INTERVAL,
        val: *mut SCIP_INTERVAL,
        gradient: *mut SCIP_INTERVAL,
        hessian: *mut SCIP_INTERVAL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " tries to determine the curvature type of an expression w.r.t. given variable domains"]
    pub fn SCIPexprCheckCurvature(
        expr: *mut SCIP_EXPR,
        infinity: f64,
        varbounds: *mut SCIP_INTERVAL,
        param: *mut f64,
        curv: *mut SCIP_EXPRCURV,
        bounds: *mut SCIP_INTERVAL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " under-/overestimates a user expression w.r.t. to given values and bounds for children expressions"]
    pub fn SCIPexprEstimateUser(
        expr: *mut SCIP_EXPR,
        infinity: f64,
        argvals: *mut f64,
        argbounds: *mut SCIP_INTERVAL,
        overestimate: ::std::os::raw::c_uint,
        coeffs: *mut f64,
        constant: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " substitutes variables (SCIP_EXPR_VARIDX) by expressions"]
    #[doc = " Note that only the children of the given expr are checked!"]
    #[doc = " A variable with index i is replaced by a copy of substexprs[i], if that latter is not NULL"]
    #[doc = " if substexprs[i] == NULL, then the variable expression i is not touched"]
    pub fn SCIPexprSubstituteVars(
        blkmem: *mut BMS_BLKMEM,
        expr: *mut SCIP_EXPR,
        substexprs: *mut *mut SCIP_EXPR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " updates variable indices in expression tree"]
    pub fn SCIPexprReindexVars(expr: *mut SCIP_EXPR, newindices: *mut ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " updates parameter indices in expression tree"]
    pub fn SCIPexprReindexParams(expr: *mut SCIP_EXPR, newindices: *mut ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " prints an expression"]
    pub fn SCIPexprPrint(
        expr: *mut SCIP_EXPR,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        varnames: *mut *const ::std::os::raw::c_char,
        paramnames: *mut *const ::std::os::raw::c_char,
        paramvals: *mut f64,
    );
}
extern "C" {
    #[doc = " parses an expression from a string"]
    pub fn SCIPexprParse(
        blkmem: *mut BMS_BLKMEM,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        expr: *mut *mut SCIP_EXPR,
        str_: *const ::std::os::raw::c_char,
        lastchar: *const ::std::os::raw::c_char,
        nvars: *mut ::std::os::raw::c_int,
        varnames: *mut ::std::os::raw::c_int,
        varnameslength: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns root expression of an expression tree"]
    pub fn SCIPexprtreeGetRoot(tree: *mut SCIP_EXPRTREE) -> *mut SCIP_EXPR;
}
extern "C" {
    #[doc = " returns number of variables in expression tree"]
    pub fn SCIPexprtreeGetNVars(tree: *mut SCIP_EXPRTREE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns number of parameters in expression tree"]
    pub fn SCIPexprtreeGetNParams(tree: *mut SCIP_EXPRTREE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns values of parameters or NULL if none"]
    pub fn SCIPexprtreeGetParamVals(tree: *mut SCIP_EXPRTREE) -> *mut f64;
}
extern "C" {
    #[doc = " sets value of a single parameter in expression tree"]
    pub fn SCIPexprtreeSetParamVal(
        tree: *mut SCIP_EXPRTREE,
        paramidx: ::std::os::raw::c_int,
        paramval: f64,
    );
}
extern "C" {
    #[doc = " gets data of expression tree interpreter, or NULL if not set"]
    pub fn SCIPexprtreeGetInterpreterData(tree: *mut SCIP_EXPRTREE) -> *mut SCIP_EXPRINTDATA;
}
extern "C" {
    #[doc = " sets data of expression tree interpreter"]
    pub fn SCIPexprtreeSetInterpreterData(
        tree: *mut SCIP_EXPRTREE,
        interpreterdata: *mut SCIP_EXPRINTDATA,
    );
}
extern "C" {
    #[doc = " frees data of expression tree interpreter, if any"]
    pub fn SCIPexprtreeFreeInterpreterData(tree: *mut SCIP_EXPRTREE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " indicates whether there are parameterized constants (SCIP_EXPR_PARAM) in expression tree"]
    pub fn SCIPexprtreeHasParam(tree: *mut SCIP_EXPRTREE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Gives maximal degree of expression in expression tree."]
    #[doc = " If constant expression, gives 0,"]
    #[doc = " if linear expression, gives 1,"]
    #[doc = " if polynomial expression, gives its maximal degree,"]
    #[doc = " otherwise (nonpolynomial nonconstant expressions) gives at least SCIP_EXPR_DEGREEINFINITY."]
    pub fn SCIPexprtreeGetMaxDegree(
        tree: *mut SCIP_EXPRTREE,
        maxdegree: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " evaluates an expression tree w.r.t. a point"]
    pub fn SCIPexprtreeEval(
        tree: *mut SCIP_EXPRTREE,
        varvals: *mut f64,
        val: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " evaluates an expression tree w.r.t. an interval"]
    pub fn SCIPexprtreeEvalInt(
        tree: *mut SCIP_EXPRTREE,
        infinity: f64,
        varvals: *mut SCIP_INTERVAL,
        val: *mut SCIP_INTERVAL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " prints an expression tree"]
    pub fn SCIPexprtreePrint(
        tree: *mut SCIP_EXPRTREE,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        varnames: *mut *const ::std::os::raw::c_char,
        paramnames: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " creates an expression tree"]
    pub fn SCIPexprtreeCreate(
        blkmem: *mut BMS_BLKMEM,
        tree: *mut *mut SCIP_EXPRTREE,
        root: *mut SCIP_EXPR,
        nvars: ::std::os::raw::c_int,
        nparams: ::std::os::raw::c_int,
        params: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies an expression tree"]
    pub fn SCIPexprtreeCopy(
        blkmem: *mut BMS_BLKMEM,
        targettree: *mut *mut SCIP_EXPRTREE,
        sourcetree: *mut SCIP_EXPRTREE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees an expression tree"]
    pub fn SCIPexprtreeFree(tree: *mut *mut SCIP_EXPRTREE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets number and values of all parameters in expression tree"]
    pub fn SCIPexprtreeSetParams(
        tree: *mut SCIP_EXPRTREE,
        nparams: ::std::os::raw::c_int,
        paramvals: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives the number of usages for each variable in the expression tree"]
    pub fn SCIPexprtreeGetVarsUsage(
        tree: *mut SCIP_EXPRTREE,
        varsusage: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " aims at simplifying an expression and splitting of a linear expression"]
    #[doc = " if linear variables are split off, expression interpreter data, if stored in the tree, is freed"]
    pub fn SCIPexprtreeSimplify(
        tree: *mut SCIP_EXPRTREE,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        eps: f64,
        maxexpansionexponent: ::std::os::raw::c_int,
        nlinvars: *mut ::std::os::raw::c_int,
        linidxs: *mut ::std::os::raw::c_int,
        lincoefs: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds an expression to the root expression of the tree"]
    #[doc = ""]
    #[doc = "  The root is replaced with an SCIP_EXPR_PLUS expression which has the previous root and the given expression as children"]
    #[doc = "  If no root existed yet, then the root is set to the given expression (or a copy of it)."]
    pub fn SCIPexprtreeAddExpr(
        tree: *mut SCIP_EXPRTREE,
        expr: *mut SCIP_EXPR,
        copyexpr: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " tries to determine the curvature type of an expression tree w.r.t. given variable domains"]
    pub fn SCIPexprtreeCheckCurvature(
        tree: *mut SCIP_EXPRTREE,
        infinity: f64,
        varbounds: *mut SCIP_INTERVAL,
        curv: *mut SCIP_EXPRCURV,
        bounds: *mut SCIP_INTERVAL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " substitutes variables (SCIP_EXPR_VARIDX) in an expression tree by expressions"]
    #[doc = " A variable with index i is replaced by a copy of substexprs[i], if that latter is not NULL"]
    #[doc = " if substexprs[i] == NULL, then the variable expression i is not touched"]
    pub fn SCIPexprtreeSubstituteVars(
        tree: *mut SCIP_EXPRTREE,
        substexprs: *mut *mut SCIP_EXPR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sorts an array of quadratic elements"]
    #[doc = " The elements are sorted such that the first index is increasing and"]
    #[doc = " such that among elements with the same first index, the second index is increasing."]
    #[doc = " For elements with same first and second index, the order is not defined."]
    pub fn SCIPquadelemSort(quadelems: *mut SCIP_QUADELEM, nquadelems: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Finds an index pair in a sorted array of quadratic elements."]
    #[doc = " If (idx1,idx2) is found in quadelems, then returns TRUE and stores position of quadratic element in *pos."]
    #[doc = " If (idx1,idx2) is not found in quadelems, then returns FALSE and stores position where a quadratic element with these indices would be inserted in *pos."]
    #[doc = " Assumes that idx1 <= idx2."]
    pub fn SCIPquadelemSortedFind(
        quadelems: *mut SCIP_QUADELEM,
        idx1: ::std::os::raw::c_int,
        idx2: ::std::os::raw::c_int,
        nquadelems: ::std::os::raw::c_int,
        pos: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Adds quadratic elements with same index and removes elements with coefficient 0.0."]
    #[doc = " Assumes that elements have been sorted before."]
    pub fn SCIPquadelemSqueeze(
        quadelems: *mut SCIP_QUADELEM,
        nquadelems: ::std::os::raw::c_int,
        nquadelemsnew: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " captures node, i.e., increases number of uses"]
    pub fn SCIPexprgraphCaptureNode(node: *mut SCIP_EXPRGRAPHNODE);
}
extern "C" {
    #[doc = " returns whether a node is currently enabled"]
    pub fn SCIPexprgraphIsNodeEnabled(node: *mut SCIP_EXPRGRAPHNODE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets number of children of a node in an expression graph"]
    pub fn SCIPexprgraphGetNodeNChildren(node: *mut SCIP_EXPRGRAPHNODE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets children of a node in an expression graph"]
    pub fn SCIPexprgraphGetNodeChildren(
        node: *mut SCIP_EXPRGRAPHNODE,
    ) -> *mut *mut SCIP_EXPRGRAPHNODE;
}
extern "C" {
    #[doc = " gets number of parents of a node in an expression graph"]
    pub fn SCIPexprgraphGetNodeNParents(node: *mut SCIP_EXPRGRAPHNODE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets parents of a node in an expression graph"]
    pub fn SCIPexprgraphGetNodeParents(
        node: *mut SCIP_EXPRGRAPHNODE,
    ) -> *mut *mut SCIP_EXPRGRAPHNODE;
}
extern "C" {
    #[doc = " gets depth of node in expression graph"]
    pub fn SCIPexprgraphGetNodeDepth(node: *mut SCIP_EXPRGRAPHNODE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets position of node in expression graph at its depth level"]
    pub fn SCIPexprgraphGetNodePosition(node: *mut SCIP_EXPRGRAPHNODE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets operator of a node in an expression graph"]
    pub fn SCIPexprgraphGetNodeOperator(node: *mut SCIP_EXPRGRAPHNODE) -> SCIP_EXPROP;
}
extern "C" {
    #[doc = " gives index belonging to a SCIP_EXPR_VARIDX or SCIP_EXPR_PARAM operand"]
    pub fn SCIPexprgraphGetNodeOperatorIndex(
        node: *mut SCIP_EXPRGRAPHNODE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives real belonging to a SCIP_EXPR_CONST operand"]
    pub fn SCIPexprgraphGetNodeOperatorReal(node: *mut SCIP_EXPRGRAPHNODE) -> f64;
}
extern "C" {
    #[doc = " gives variable belonging to a SCIP_EXPR_VARIDX expression"]
    pub fn SCIPexprgraphGetNodeVar(
        exprgraph: *mut SCIP_EXPRGRAPH,
        node: *mut SCIP_EXPRGRAPHNODE,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " gives exponent belonging to a SCIP_EXPR_REALPOWER expression"]
    pub fn SCIPexprgraphGetNodeRealPowerExponent(node: *mut SCIP_EXPRGRAPHNODE) -> f64;
}
extern "C" {
    #[doc = " gives exponent belonging to a SCIP_EXPR_INTPOWER expression"]
    pub fn SCIPexprgraphGetNodeIntPowerExponent(
        node: *mut SCIP_EXPRGRAPHNODE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives exponent belonging to a SCIP_EXPR_SIGNPOWER expression"]
    pub fn SCIPexprgraphGetNodeSignPowerExponent(node: *mut SCIP_EXPRGRAPHNODE) -> f64;
}
extern "C" {
    #[doc = " gives linear coefficients belonging to a SCIP_EXPR_LINEAR expression"]
    pub fn SCIPexprgraphGetNodeLinearCoefs(node: *mut SCIP_EXPRGRAPHNODE) -> *mut f64;
}
extern "C" {
    #[doc = " gives constant belonging to a SCIP_EXPR_LINEAR expression"]
    pub fn SCIPexprgraphGetNodeLinearConstant(node: *mut SCIP_EXPRGRAPHNODE) -> f64;
}
extern "C" {
    #[doc = " gives constant belonging to a SCIP_EXPR_QUADRATIC expression"]
    pub fn SCIPexprgraphGetNodeQuadraticConstant(node: *mut SCIP_EXPRGRAPHNODE) -> f64;
}
extern "C" {
    #[doc = " gives linear coefficients belonging to a SCIP_EXPR_QUADRATIC expression, or NULL if all coefficients are 0.0"]
    pub fn SCIPexprgraphGetNodeQuadraticLinearCoefs(node: *mut SCIP_EXPRGRAPHNODE) -> *mut f64;
}
extern "C" {
    #[doc = " gives quadratic elements belonging to a SCIP_EXPR_QUADRATIC expression"]
    pub fn SCIPexprgraphGetNodeQuadraticQuadElements(
        node: *mut SCIP_EXPRGRAPHNODE,
    ) -> *mut SCIP_QUADELEM;
}
extern "C" {
    #[doc = " gives number of quadratic elements belonging to a SCIP_EXPR_QUADRATIC expression"]
    pub fn SCIPexprgraphGetNodeQuadraticNQuadElements(
        node: *mut SCIP_EXPRGRAPHNODE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives the monomials belonging to a SCIP_EXPR_POLYNOMIAL expression"]
    pub fn SCIPexprgraphGetNodePolynomialMonomials(
        node: *mut SCIP_EXPRGRAPHNODE,
    ) -> *mut *mut SCIP_EXPRDATA_MONOMIAL;
}
extern "C" {
    #[doc = " gives the number of monomials belonging to a SCIP_EXPR_POLYNOMIAL expression"]
    pub fn SCIPexprgraphGetNodePolynomialNMonomials(
        node: *mut SCIP_EXPRGRAPHNODE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gives the constant belonging to a SCIP_EXPR_POLYNOMIAL expression"]
    pub fn SCIPexprgraphGetNodePolynomialConstant(node: *mut SCIP_EXPRGRAPHNODE) -> f64;
}
extern "C" {
    #[doc = " gives the curvature of a single monomial belonging to a SCIP_EXPR_POLYNOMIAL expression"]
    pub fn SCIPexprgraphGetNodePolynomialMonomialCurvature(
        node: *mut SCIP_EXPRGRAPHNODE,
        monomialidx: ::std::os::raw::c_int,
        infinity: f64,
        curv: *mut SCIP_EXPRCURV,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives the user data belonging to a SCIP_EXPR_USER expression"]
    pub fn SCIPexprgraphGetNodeUserData(node: *mut SCIP_EXPRGRAPHNODE) -> *mut SCIP_USEREXPRDATA;
}
extern "C" {
    #[doc = " indicates whether a user expression has the estimator callback defined"]
    pub fn SCIPexprgraphHasNodeUserEstimator(
        node: *mut SCIP_EXPRGRAPHNODE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets bounds of a node in an expression graph"]
    pub fn SCIPexprgraphGetNodeBounds(node: *mut SCIP_EXPRGRAPHNODE) -> SCIP_INTERVAL;
}
extern "C" {
    #[doc = " gets value of expression associated to node from last evaluation call"]
    pub fn SCIPexprgraphGetNodeVal(node: *mut SCIP_EXPRGRAPHNODE) -> f64;
}
extern "C" {
    #[doc = " gets curvature of expression associated to node from last curvature check call"]
    pub fn SCIPexprgraphGetNodeCurvature(node: *mut SCIP_EXPRGRAPHNODE) -> SCIP_EXPRCURV;
}
extern "C" {
    #[doc = " creates an expression graph node"]
    pub fn SCIPexprgraphCreateNode(
        blkmem: *mut BMS_BLKMEM,
        node: *mut *mut SCIP_EXPRGRAPHNODE,
        op: SCIP_EXPROP,
        ...
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates an expression graph node for a linear expression"]
    pub fn SCIPexprgraphCreateNodeLinear(
        blkmem: *mut BMS_BLKMEM,
        node: *mut *mut SCIP_EXPRGRAPHNODE,
        ncoefs: ::std::os::raw::c_int,
        coefs: *mut f64,
        constant: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates an expression graph node for a quadratic expression"]
    pub fn SCIPexprgraphCreateNodeQuadratic(
        blkmem: *mut BMS_BLKMEM,
        node: *mut *mut SCIP_EXPRGRAPHNODE,
        nchildren: ::std::os::raw::c_int,
        lincoefs: *mut f64,
        nquadelems: ::std::os::raw::c_int,
        quadelems: *mut SCIP_QUADELEM,
        constant: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates an expression graph node for a polynomial expression"]
    pub fn SCIPexprgraphCreateNodePolynomial(
        blkmem: *mut BMS_BLKMEM,
        node: *mut *mut SCIP_EXPRGRAPHNODE,
        nmonomials: ::std::os::raw::c_int,
        monomials: *mut *mut SCIP_EXPRDATA_MONOMIAL,
        constant: f64,
        copymonomials: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds monomials to an expression graph node that is a polynomial expression"]
    pub fn SCIPexprgraphNodePolynomialAddMonomials(
        blkmem: *mut BMS_BLKMEM,
        node: *mut SCIP_EXPRGRAPHNODE,
        nmonomials: ::std::os::raw::c_int,
        monomials: *mut *mut SCIP_EXPRDATA_MONOMIAL,
        copymonomials: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates an expression graph node for a user expression"]
    pub fn SCIPexprgraphCreateNodeUser(
        blkmem: *mut BMS_BLKMEM,
        node: *mut *mut SCIP_EXPRGRAPHNODE,
        data: *mut SCIP_USEREXPRDATA,
        evalcapability: SCIP_EXPRINTCAPABILITY,
        eval: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut SCIP_USEREXPRDATA,
                nargs: ::std::os::raw::c_int,
                argvals: *mut f64,
                funcvalue: *mut f64,
                gradient: *mut f64,
                hessian: *mut f64,
            ) -> SCIP_RETCODE,
        >,
        inteval: ::std::option::Option<
            unsafe extern "C" fn(
                infinity: f64,
                data: *mut SCIP_USEREXPRDATA,
                nargs: ::std::os::raw::c_int,
                argvals: *mut SCIP_INTERVAL,
                funcvalue: *mut SCIP_INTERVAL,
                gradient: *mut SCIP_INTERVAL,
                hessian: *mut SCIP_INTERVAL,
            ) -> SCIP_RETCODE,
        >,
        curv: ::std::option::Option<
            unsafe extern "C" fn(
                infinity: f64,
                data: *mut SCIP_USEREXPRDATA,
                nargs: ::std::os::raw::c_int,
                argbounds: *mut SCIP_INTERVAL,
                argcurv: *mut SCIP_EXPRCURV,
                result: *mut SCIP_EXPRCURV,
            ) -> SCIP_RETCODE,
        >,
        prop: ::std::option::Option<
            unsafe extern "C" fn(
                infinity: f64,
                data: *mut SCIP_USEREXPRDATA,
                nargs: ::std::os::raw::c_int,
                argbounds: *mut SCIP_INTERVAL,
                funcbounds: SCIP_INTERVAL,
                cutoff: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        estimate: ::std::option::Option<
            unsafe extern "C" fn(
                infinity: f64,
                data: *mut SCIP_USEREXPRDATA,
                nargs: ::std::os::raw::c_int,
                argvals: *mut f64,
                argbounds: *mut SCIP_INTERVAL,
                overestimate: ::std::os::raw::c_uint,
                coeffs: *mut f64,
                constant: *mut f64,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        copydata: ::std::option::Option<
            unsafe extern "C" fn(
                blkmem: *mut BMS_BLKMEM,
                nchildren: ::std::os::raw::c_int,
                datasource: *mut SCIP_USEREXPRDATA,
                datatarget: *mut *mut SCIP_USEREXPRDATA,
            ) -> SCIP_RETCODE,
        >,
        freedata: ::std::option::Option<
            unsafe extern "C" fn(
                blkmem: *mut BMS_BLKMEM,
                nchildren: ::std::os::raw::c_int,
                data: *mut SCIP_USEREXPRDATA,
            ),
        >,
        print: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut SCIP_USEREXPRDATA,
                messagehdlr: *mut SCIP_MESSAGEHDLR,
                file: *mut FILE,
            ),
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " given a node of an expression graph, splitup a linear part which variables are not used somewhere else in the same expression"]
    #[doc = " E.g., if the expression is 1 + x + y + y^2, one gets 1 + x and the node remains at y + y^2."]
    #[doc = " If the node is a linear expression, it may be freed."]
    #[doc = " If it is not linear, the node may change, i.e., the remaining nonlinear part may be stored in a new node."]
    #[doc = " It is assumed that the user had captured the node."]
    #[doc = " It is assumed that the expression graph has been simplified before."]
    pub fn SCIPexprgraphNodeSplitOffLinear(
        exprgraph: *mut SCIP_EXPRGRAPH,
        node: *mut *mut SCIP_EXPRGRAPHNODE,
        linvarssize: ::std::os::raw::c_int,
        nlinvars: *mut ::std::os::raw::c_int,
        linvars: *mut *mut ::std::os::raw::c_void,
        lincoefs: *mut f64,
        constant: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " moves parents from a one node to another node"]
    #[doc = " in other words, replaces the child srcnode by targetnode in all parents of srcnode"]
    #[doc = " srcnode may be freed, if not captured"]
    #[doc = " it is assumes that targetnode represents the same expression as srcnode"]
    pub fn SCIPexprgraphMoveNodeParents(
        exprgraph: *mut SCIP_EXPRGRAPH,
        srcnode: *mut *mut SCIP_EXPRGRAPHNODE,
        targetnode: *mut SCIP_EXPRGRAPHNODE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " releases node, i.e., decreases number of uses"]
    #[doc = " node is freed if no parents and no other uses"]
    #[doc = " children are recursively released if they have no other parents"]
    #[doc = " nodes that are removed are also freed"]
    #[doc = " if node correspond to a variable, then the variable is removed from the expression graph"]
    #[doc = " similar for constants"]
    pub fn SCIPexprgraphReleaseNode(
        exprgraph: *mut SCIP_EXPRGRAPH,
        node: *mut *mut SCIP_EXPRGRAPHNODE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a node of an expression graph"]
    pub fn SCIPexprgraphFreeNode(blkmem: *mut BMS_BLKMEM, node: *mut *mut SCIP_EXPRGRAPHNODE);
}
extern "C" {
    #[doc = " enables a node and recursively all its children in an expression graph"]
    pub fn SCIPexprgraphEnableNode(exprgraph: *mut SCIP_EXPRGRAPH, node: *mut SCIP_EXPRGRAPHNODE);
}
extern "C" {
    #[doc = " disables a node and recursively all children which have no enabled parents in an expression graph"]
    pub fn SCIPexprgraphDisableNode(exprgraph: *mut SCIP_EXPRGRAPH, node: *mut SCIP_EXPRGRAPHNODE);
}
extern "C" {
    #[doc = " returns whether the node has siblings in the expression graph"]
    pub fn SCIPexprgraphHasNodeSibling(node: *mut SCIP_EXPRGRAPHNODE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether all children of an expression graph node are variable nodes"]
    #[doc = " gives TRUE for nodes without children"]
    pub fn SCIPexprgraphAreAllNodeChildrenVars(
        node: *mut SCIP_EXPRGRAPHNODE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the node has an ancestor which has a nonlinear expression operand"]
    pub fn SCIPexprgraphHasNodeNonlinearAncestor(
        node: *mut SCIP_EXPRGRAPHNODE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " prints an expression graph node"]
    pub fn SCIPexprgraphPrintNode(
        node: *mut SCIP_EXPRGRAPHNODE,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
    );
}
extern "C" {
    #[doc = " tightens the bounds in a node of the graph"]
    #[doc = " preparation for reverse propagation"]
    #[doc = " sets bound status to SCIP_EXPRBOUNDSTATUS_TIGHTENEDBYPARENTRECENT if tightening is strong enough and not cutoff"]
    pub fn SCIPexprgraphTightenNodeBounds(
        exprgraph: *mut SCIP_EXPRGRAPH,
        node: *mut SCIP_EXPRGRAPHNODE,
        nodebounds: SCIP_INTERVAL,
        minstrength: f64,
        infinity: f64,
        cutoff: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " ensures that bounds and curvature information in a node is uptodate"]
    #[doc = " assumes that bounds and curvature in children are uptodate"]
    pub fn SCIPexprgraphUpdateNodeBoundsCurvature(
        node: *mut SCIP_EXPRGRAPHNODE,
        infinity: f64,
        minstrength: f64,
        clearreverseprop: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get current maximal depth of expression graph"]
    pub fn SCIPexprgraphGetDepth(exprgraph: *mut SCIP_EXPRGRAPH) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array with number of nodes at each depth of expression graph"]
    pub fn SCIPexprgraphGetNNodes(exprgraph: *mut SCIP_EXPRGRAPH) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets nodes of expression graph, one array per depth"]
    pub fn SCIPexprgraphGetNodes(
        exprgraph: *mut SCIP_EXPRGRAPH,
    ) -> *mut *mut *mut SCIP_EXPRGRAPHNODE;
}
extern "C" {
    #[doc = " gets number of variables in expression graph"]
    pub fn SCIPexprgraphGetNVars(exprgraph: *mut SCIP_EXPRGRAPH) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of variables in expression graph"]
    pub fn SCIPexprgraphGetVars(exprgraph: *mut SCIP_EXPRGRAPH)
        -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " gets array of expression graph nodes corresponding to variables"]
    pub fn SCIPexprgraphGetVarNodes(exprgraph: *mut SCIP_EXPRGRAPH)
        -> *mut *mut SCIP_EXPRGRAPHNODE;
}
extern "C" {
    #[doc = " sets value for a single variable given as expression graph node"]
    pub fn SCIPexprgraphSetVarNodeValue(varnode: *mut SCIP_EXPRGRAPHNODE, value: f64);
}
extern "C" {
    #[doc = " sets bounds for variables"]
    pub fn SCIPexprgraphSetVarsBounds(
        exprgraph: *mut SCIP_EXPRGRAPH,
        varbounds: *mut SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " sets bounds for a single variable"]
    pub fn SCIPexprgraphSetVarBounds(
        exprgraph: *mut SCIP_EXPRGRAPH,
        var: *mut ::std::os::raw::c_void,
        varbounds: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " sets bounds for a single variable given as expression graph node"]
    pub fn SCIPexprgraphSetVarNodeBounds(
        exprgraph: *mut SCIP_EXPRGRAPH,
        varnode: *mut SCIP_EXPRGRAPHNODE,
        varbounds: SCIP_INTERVAL,
    );
}
extern "C" {
    #[doc = " sets lower bound for a single variable given as expression graph node"]
    pub fn SCIPexprgraphSetVarNodeLb(
        exprgraph: *mut SCIP_EXPRGRAPH,
        varnode: *mut SCIP_EXPRGRAPHNODE,
        lb: f64,
    );
}
extern "C" {
    #[doc = " sets upper bound for a single variable given as expression graph node"]
    pub fn SCIPexprgraphSetVarNodeUb(
        exprgraph: *mut SCIP_EXPRGRAPH,
        varnode: *mut SCIP_EXPRGRAPHNODE,
        ub: f64,
    );
}
extern "C" {
    #[doc = " gets bounds that are stored for all variables"]
    pub fn SCIPexprgraphGetVarsBounds(exprgraph: *mut SCIP_EXPRGRAPH) -> *mut SCIP_INTERVAL;
}
extern "C" {
    #[doc = " creates an empty expression graph"]
    pub fn SCIPexprgraphCreate(
        blkmem: *mut BMS_BLKMEM,
        exprgraph: *mut *mut SCIP_EXPRGRAPH,
        varssizeinit: ::std::os::raw::c_int,
        depthinit: ::std::os::raw::c_int,
        exprgraphvaradded: ::std::option::Option<
            unsafe extern "C" fn(
                exprgraph: *mut SCIP_EXPRGRAPH,
                userdata: *mut ::std::os::raw::c_void,
                var: *mut ::std::os::raw::c_void,
                varnode: *mut SCIP_EXPRGRAPHNODE,
            ) -> SCIP_RETCODE,
        >,
        exprgraphvarremove: ::std::option::Option<
            unsafe extern "C" fn(
                exprgraph: *mut SCIP_EXPRGRAPH,
                userdata: *mut ::std::os::raw::c_void,
                var: *mut ::std::os::raw::c_void,
                varnode: *mut SCIP_EXPRGRAPHNODE,
            ) -> SCIP_RETCODE,
        >,
        exprgraphvarchgidx: ::std::option::Option<
            unsafe extern "C" fn(
                exprgraph: *mut SCIP_EXPRGRAPH,
                userdata: *mut ::std::os::raw::c_void,
                var: *mut ::std::os::raw::c_void,
                varnode: *mut SCIP_EXPRGRAPHNODE,
                oldidx: ::std::os::raw::c_int,
                newidx: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        userdata: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees an expression graph"]
    pub fn SCIPexprgraphFree(exprgraph: *mut *mut SCIP_EXPRGRAPH) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds an expression graph node to an expression graph"]
    #[doc = " expression graph assumes ownership of node"]
    #[doc = " children are notified about new parent"]
    #[doc = " depth will be chosen to be the maximum of mindepth and the depth of all children plus one"]
    pub fn SCIPexprgraphAddNode(
        exprgraph: *mut SCIP_EXPRGRAPH,
        node: *mut SCIP_EXPRGRAPHNODE,
        mindepth: ::std::os::raw::c_int,
        nchildren: ::std::os::raw::c_int,
        children: *mut *mut SCIP_EXPRGRAPHNODE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds variables to an expression graph, if not existing yet"]
    #[doc = " also already existing nodes are enabled"]
    pub fn SCIPexprgraphAddVars(
        exprgraph: *mut SCIP_EXPRGRAPH,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut ::std::os::raw::c_void,
        varnodes: *mut *mut SCIP_EXPRGRAPHNODE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a constant to an expression graph, if not existing yet"]
    #[doc = " also already existing nodes are enabled"]
    pub fn SCIPexprgraphAddConst(
        exprgraph: *mut SCIP_EXPRGRAPH,
        constant: f64,
        constnode: *mut *mut SCIP_EXPRGRAPHNODE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds sum of expression trees into expression graph"]
    #[doc = " node will also be captured"]
    pub fn SCIPexprgraphAddExprtreeSum(
        exprgraph: *mut SCIP_EXPRGRAPH,
        nexprtrees: ::std::os::raw::c_int,
        exprtrees: *mut *mut SCIP_EXPRTREE,
        coefs: *mut f64,
        rootnode: *mut *mut SCIP_EXPRGRAPHNODE,
        rootnodeisnew: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " replaces variable in expression graph by a linear sum of variables"]
    #[doc = " variables will be added if not in the graph yet"]
    pub fn SCIPexprgraphReplaceVarByLinearSum(
        exprgraph: *mut SCIP_EXPRGRAPH,
        var: *mut ::std::os::raw::c_void,
        ncoefs: ::std::os::raw::c_int,
        coefs: *mut f64,
        vars: *mut *mut ::std::os::raw::c_void,
        constant: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " finds expression graph node corresponding to a variable"]
    pub fn SCIPexprgraphFindVarNode(
        exprgraph: *mut SCIP_EXPRGRAPH,
        var: *mut ::std::os::raw::c_void,
        varnode: *mut *mut SCIP_EXPRGRAPHNODE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " finds expression graph node corresponding to a constant"]
    pub fn SCIPexprgraphFindConstNode(
        exprgraph: *mut SCIP_EXPRGRAPH,
        constant: f64,
        constnode: *mut *mut SCIP_EXPRGRAPHNODE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " prints an expression graph in dot format"]
    pub fn SCIPexprgraphPrintDot(
        exprgraph: *mut SCIP_EXPRGRAPH,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        file: *mut FILE,
        varnames: *mut *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " evaluates nodes of expression graph for given values of variables"]
    pub fn SCIPexprgraphEval(exprgraph: *mut SCIP_EXPRGRAPH, varvals: *mut f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " propagates bound changes in variables forward through the expression graph"]
    pub fn SCIPexprgraphPropagateVarBounds(
        exprgraph: *mut SCIP_EXPRGRAPH,
        infinity: f64,
        clearreverseprop: ::std::os::raw::c_uint,
        domainerror: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " propagates bound changes in nodes backward through the graph"]
    #[doc = " new bounds are not stored in varbounds, but only in nodes corresponding to variables"]
    #[doc = " NOTE: it is assumed that SCIPexprgraphPropagateVarBounds was called before if variable bounds were relaxed"]
    pub fn SCIPexprgraphPropagateNodeBounds(
        exprgraph: *mut SCIP_EXPRGRAPH,
        infinity: f64,
        minstrength: f64,
        cutoff: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " updates curvature information in expression graph nodes w.r.t. currently stored variable bounds"]
    #[doc = " implies update of bounds in expression graph"]
    pub fn SCIPexprgraphCheckCurvature(
        exprgraph: *mut SCIP_EXPRGRAPH,
        infinity: f64,
        clearreverseprop: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " aims at simplifying an expression graph"]
    #[doc = " a domain error can occur when variables were fixed to values for which a parent expression is not defined (e.g., 0^(-1) or log(-1))"]
    pub fn SCIPexprgraphSimplify(
        exprgraph: *mut SCIP_EXPRGRAPH,
        messagehdlr: *mut SCIP_MESSAGEHDLR,
        eps: f64,
        maxexpansionexponent: ::std::os::raw::c_int,
        havechange: *mut ::std::os::raw::c_uint,
        domainerror: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates an expression tree from a given node in an expression graph"]
    pub fn SCIPexprgraphGetTree(
        exprgraph: *mut SCIP_EXPRGRAPH,
        rootnode: *mut SCIP_EXPRGRAPHNODE,
        exprtree: *mut *mut SCIP_EXPRTREE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a sum of expression trees with pairwise disjoint variables from a given node in an expression graph"]
    #[doc = " Giving SCIPexprgraphGetNodeNChildren() for exprtreesize is always sufficient."]
    pub fn SCIPexprgraphGetSeparableTrees(
        exprgraph: *mut SCIP_EXPRGRAPH,
        node: *mut SCIP_EXPRGRAPHNODE,
        exprtreessize: ::std::os::raw::c_int,
        nexprtrees: *mut ::std::os::raw::c_int,
        exprtrees: *mut *mut SCIP_EXPRTREE,
        exprtreecoefs: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns how often expression graph variables are used in a subtree of the expression graph"]
    pub fn SCIPexprgraphGetSubtreeVarsUsage(
        exprgraph: *mut SCIP_EXPRGRAPH,
        node: *mut SCIP_EXPRGRAPHNODE,
        varsusage: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " gives the number of summands which the expression of an expression graph node consists of"]
    pub fn SCIPexprgraphGetSumTreesNSummands(
        node: *mut SCIP_EXPRGRAPHNODE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates a sum of expression trees, possibly sharing variables, from a given node in an expression graph"]
    pub fn SCIPexprgraphGetSumTrees(
        exprgraph: *mut SCIP_EXPRGRAPH,
        node: *mut SCIP_EXPRGRAPHNODE,
        exprtreessize: ::std::os::raw::c_int,
        nexprtrees: *mut ::std::os::raw::c_int,
        exprtrees: *mut *mut SCIP_EXPRTREE,
        exprtreecoefs: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = "@defgroup PublicSpecialPresolveMethods Special Methods"]
    #[doc = " @ingroup PublicPresolverMethods"]
    #[doc = " @brief methods commonly used for presolving"]
    #[doc = ""]
    #[doc = " @{"]
    #[doc = "  must be fulfilled"]
    #[doc = ""]
    #[doc = "  e.g. a set of logicor or bounddisjunctive constraint variables would be such a set"]
    #[doc = ""]
    #[doc = "  consider the following set:"]
    #[doc = ""]
    #[doc = "  x1 >= 1, x2 >= 3, x3 >= 1, x4 <= 0"]
    #[doc = ""]
    #[doc = "  by (global) implication data (cliques, implications, and variable bounds) we have also the following implications"]
    #[doc = "  given:"]
    #[doc = ""]
    #[doc = "  x1 >= 1 => x3 >= 1"]
    #[doc = "  x2 >= 2 => x3 >= 1"]
    #[doc = "  x4 <= 0 => x1 >= 1"]
    #[doc = ""]
    #[doc = "  Because of the last implication x4 is redundant, because x1 >= 1 would also be fulfilled in the variable set, so we"]
    #[doc = "  can reduce the set by x4."]
    #[doc = "  Also, the both other implications and x3 >= 1 (in the given variable set) all imply exactly x3 >= 1, so we tighten"]
    #[doc = "  the global lower bound of x3 to 1 and the set of variables gets redundant."]
    pub fn SCIPshrinkDisjunctiveVarSet(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        bounds: *mut f64,
        boundtypes: *mut ::std::os::raw::c_uint,
        redundants: *mut ::std::os::raw::c_uint,
        nvars: ::std::os::raw::c_int,
        nredvars: *mut ::std::os::raw::c_int,
        nglobalred: *mut ::std::os::raw::c_int,
        setredundant: *mut ::std::os::raw::c_uint,
        glbinfeas: *mut ::std::os::raw::c_uint,
        fullshortening: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCIP_AggrRow {
    #[doc = "< non-zero coefficients of the cut row"]
    pub vals: *mut f64,
    #[doc = "< problem indices of variables with a non-zero coefficient in the cut row"]
    pub inds: *mut ::std::os::raw::c_int,
    #[doc = "< lpposition of rows that have been added to the cutrow"]
    pub rowsinds: *mut ::std::os::raw::c_int,
    #[doc = "< slacksign of rows that have been added to the cutrow"]
    pub slacksign: *mut ::std::os::raw::c_int,
    #[doc = "< weights of rows that have been added to the cutrow"]
    pub rowweights: *mut f64,
    pub rhshi: f64,
    pub rhslo: f64,
    #[doc = "< number of non-zeros in the cut row"]
    pub nnz: ::std::os::raw::c_int,
    #[doc = "< number of rows that have been added to the cutrow"]
    pub nrows: ::std::os::raw::c_int,
    #[doc = "< size of the row and slacksign array"]
    pub rowssize: ::std::os::raw::c_int,
    #[doc = "< rank of the cut row"]
    pub rank: ::std::os::raw::c_int,
    #[doc = "< is the cut row only valid locally?"]
    pub local: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_SCIP_AggrRow() {
    assert_eq!(
        ::std::mem::size_of::<SCIP_AggrRow>(),
        80usize,
        concat!("Size of: ", stringify!(SCIP_AggrRow))
    );
    assert_eq!(
        ::std::mem::align_of::<SCIP_AggrRow>(),
        8usize,
        concat!("Alignment of ", stringify!(SCIP_AggrRow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCIP_AggrRow>())).vals as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(vals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCIP_AggrRow>())).inds as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(inds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCIP_AggrRow>())).rowsinds as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(rowsinds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCIP_AggrRow>())).slacksign as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(slacksign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCIP_AggrRow>())).rowweights as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(rowweights)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCIP_AggrRow>())).rhshi as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(rhshi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCIP_AggrRow>())).rhslo as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(rhslo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCIP_AggrRow>())).nnz as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(nnz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCIP_AggrRow>())).nrows as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(nrows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCIP_AggrRow>())).rowssize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(rowssize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCIP_AggrRow>())).rank as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(rank)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SCIP_AggrRow>())).local as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SCIP_AggrRow),
            "::",
            stringify!(local)
        )
    );
}
pub type SCIP_AGGRROW = SCIP_AggrRow;
extern "C" {
    #[doc = " perform activity based coefficient tigthening on the given cut; returns TRUE if the cut was detected"]
    #[doc = "  to be redundant due to acitvity bounds"]
    pub fn SCIPcutsTightenCoefficients(
        scip: *mut SCIP,
        cutislocal: ::std::os::raw::c_uint,
        cutcoefs: *mut f64,
        cutrhs: *mut f64,
        cutinds: *mut ::std::os::raw::c_int,
        cutnnz: *mut ::std::os::raw::c_int,
        nchgcoefs: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " create an empty the aggregation row"]
    pub fn SCIPaggrRowCreate(scip: *mut SCIP, aggrrow: *mut *mut SCIP_AGGRROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " free a the aggregation row"]
    pub fn SCIPaggrRowFree(scip: *mut SCIP, aggrrow: *mut *mut SCIP_AGGRROW);
}
extern "C" {
    #[doc = " output aggregation row to file stream"]
    pub fn SCIPaggrRowPrint(scip: *mut SCIP, aggrrow: *mut SCIP_AGGRROW, file: *mut FILE);
}
extern "C" {
    #[doc = " copy the aggregation row"]
    pub fn SCIPaggrRowCopy(
        scip: *mut SCIP,
        aggrrow: *mut *mut SCIP_AGGRROW,
        source: *mut SCIP_AGGRROW,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " add weighted row to the aggregation row"]
    pub fn SCIPaggrRowAddRow(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        row: *mut SCIP_ROW,
        weight: f64,
        sidetype: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Removes a given variable @p var from position @p pos the aggregation row and updates the right-hand side according"]
    #[doc = "  to sign of the coefficient, i.e., rhs -= coef * bound, where bound = lb if coef >= 0 and bound = ub, otherwise."]
    #[doc = ""]
    #[doc = "  @note: The choice of global or local bounds depend on the validity (global or local) of the aggregation row."]
    #[doc = ""]
    #[doc = "  @note: The list of non-zero indices will be updated by swapping the last non-zero index to @p pos."]
    pub fn SCIPaggrRowCancelVarWithBound(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        var: *mut SCIP_VAR,
        pos: ::std::os::raw::c_int,
        valid: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " add the objective function with right-hand side @p rhs and scaled by @p scale to the aggregation row"]
    pub fn SCIPaggrRowAddObjectiveFunction(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        rhs: f64,
        scale: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " add weighted constraint to the aggregation row"]
    pub fn SCIPaggrRowAddCustomCons(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        inds: *mut ::std::os::raw::c_int,
        vals: *mut f64,
        len: ::std::os::raw::c_int,
        rhs: f64,
        weight: f64,
        rank: ::std::os::raw::c_int,
        local: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calculates the efficacy norm of the given aggregation row, which depends on the \"separating/efficacynorm\" parameter"]
    #[doc = ""]
    #[doc = "  @return the efficacy norm of the given aggregation row, which depends on the \"separating/efficacynorm\" parameter"]
    pub fn SCIPaggrRowCalcEfficacyNorm(scip: *mut SCIP, aggrrow: *mut SCIP_AGGRROW) -> f64;
}
extern "C" {
    #[doc = " clear all entries in the aggregation row but do not free the internal memory"]
    pub fn SCIPaggrRowClear(aggrrow: *mut SCIP_AGGRROW);
}
extern "C" {
    #[doc = " aggregate rows using the given weights; the current content of the aggregation"]
    #[doc = "  row, \\p aggrrow, gets overwritten"]
    pub fn SCIPaggrRowSumRows(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        weights: *mut f64,
        rowinds: *mut ::std::os::raw::c_int,
        nrowinds: ::std::os::raw::c_int,
        sidetypebasis: ::std::os::raw::c_uint,
        allowlocal: ::std::os::raw::c_uint,
        negslack: ::std::os::raw::c_int,
        maxaggrlen: ::std::os::raw::c_int,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes all (close enough to) zero entries in the aggregation row"]
    pub fn SCIPaggrRowRemoveZeros(
        scip: *mut SCIP,
        aggrrow: *mut SCIP_AGGRROW,
        useglbbounds: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " get array with lp positions of aggregated rows"]
    pub fn SCIPaggrRowGetRowInds(aggrrow: *mut SCIP_AGGRROW) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get array with weights of aggregated rows"]
    pub fn SCIPaggrRowGetRowWeights(aggrrow: *mut SCIP_AGGRROW) -> *mut f64;
}
extern "C" {
    #[doc = " checks whether a given row has been added to the aggregation row"]
    pub fn SCIPaggrRowHasRowBeenAdded(
        aggrrow: *mut SCIP_AGGRROW,
        row: *mut SCIP_ROW,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets the min and max absolute value of the weights used to aggregate the rows;"]
    #[doc = "  must not be called for empty aggregation rows"]
    pub fn SCIPaggrRowGetAbsWeightRange(
        aggrrow: *mut SCIP_AGGRROW,
        minabsrowweight: *mut f64,
        maxabsrowweight: *mut f64,
    );
}
extern "C" {
    #[doc = " gets the array of corresponding variable problem indices for each non-zero in the aggregation row"]
    pub fn SCIPaggrRowGetInds(aggrrow: *mut SCIP_AGGRROW) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of non-zeros in the aggregation row"]
    pub fn SCIPaggrRowGetNNz(aggrrow: *mut SCIP_AGGRROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the rank of the aggregation row"]
    pub fn SCIPaggrRowGetRank(aggrrow: *mut SCIP_AGGRROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " checks if the aggregation row is only valid locally"]
    pub fn SCIPaggrRowIsLocal(aggrrow: *mut SCIP_AGGRROW) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets the right hand side of the aggregation row"]
    pub fn SCIPaggrRowGetRhs(aggrrow: *mut SCIP_AGGRROW) -> f64;
}
extern "C" {
    #[doc = " gets the number of row aggregations"]
    pub fn SCIPaggrRowGetNRows(aggrrow: *mut SCIP_AGGRROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " perform a cut selection algorithm for the given array of cuts; the array is partitioned"]
    #[doc = "  so that the selected cuts come first and the remaining ones are at the end of the array"]
    pub fn SCIPselectCuts(
        scip: *mut SCIP,
        cuts: *mut *mut SCIP_ROW,
        randnumgen: *mut SCIP_RANDNUMGEN,
        goodscorefac: f64,
        badscorefac: f64,
        goodmaxparall: f64,
        maxparall: f64,
        dircutoffdistweight: f64,
        efficacyweight: f64,
        objparalweight: f64,
        intsupportweight: f64,
        ncuts: ::std::os::raw::c_int,
        nforcedcuts: ::std::os::raw::c_int,
        maxselectedcuts: ::std::os::raw::c_int,
        nselectedcuts: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calculates an MIR cut out of the weighted sum of LP rows given by an aggregation row; the"]
    #[doc = "  aggregation row must not contain non-zero weights for modifiable rows, because these rows cannot"]
    #[doc = "  participate in an MIR cut."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcalcMIR(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        postprocess: ::std::os::raw::c_uint,
        boundswitch: f64,
        usevbds: ::std::os::raw::c_uint,
        allowlocal: ::std::os::raw::c_uint,
        fixintegralrhs: ::std::os::raw::c_uint,
        boundsfortrans: *mut ::std::os::raw::c_int,
        boundtypesfortrans: *mut SCIP_BOUNDTYPE,
        minfrac: f64,
        maxfrac: f64,
        scale: f64,
        aggrrow: *mut SCIP_AGGRROW,
        cutcoefs: *mut f64,
        cutrhs: *mut f64,
        cutinds: *mut ::std::os::raw::c_int,
        cutnnz: *mut ::std::os::raw::c_int,
        cutefficacy: *mut f64,
        cutrank: *mut ::std::os::raw::c_int,
        cutislocal: *mut ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calculates an MIR cut out of the weighted sum of LP rows given by an aggregation row; the"]
    #[doc = "  aggregation row must not contain non-zero weights for modifiable rows, because these rows cannot"]
    #[doc = "  participate in an MIR cut. The function uses a cut generation heuristic which tries different scaling"]
    #[doc = "  factors and complementations of the variables to improve the cut's efficacy."]
    #[doc = "  For further details we refer to:"]
    #[doc = ""]
    #[doc = "  Marchand, H., & Wolsey, L. A. (2001). Aggregation and mixed integer rounding to solve MIPs."]
    #[doc = "  Operations research, 49(3), 363-371."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcutGenerationHeuristicCMIR(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        postprocess: ::std::os::raw::c_uint,
        boundswitch: f64,
        usevbds: ::std::os::raw::c_uint,
        allowlocal: ::std::os::raw::c_uint,
        maxtestdelta: ::std::os::raw::c_int,
        boundsfortrans: *mut ::std::os::raw::c_int,
        boundtypesfortrans: *mut SCIP_BOUNDTYPE,
        minfrac: f64,
        maxfrac: f64,
        aggrrow: *mut SCIP_AGGRROW,
        cutcoefs: *mut f64,
        cutrhs: *mut f64,
        cutinds: *mut ::std::os::raw::c_int,
        cutnnz: *mut ::std::os::raw::c_int,
        cutefficacy: *mut f64,
        cutrank: *mut ::std::os::raw::c_int,
        cutislocal: *mut ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calculates a lifted simple generalized flow cover cut out of the weighted sum of LP rows given by an aggregation row; the"]
    #[doc = "  aggregation row must not contain non-zero weights for modifiable rows, because these rows cannot"]
    #[doc = "  participate in an MIR cut."]
    #[doc = "  For further details we refer to:"]
    #[doc = ""]
    #[doc = "  Gu, Z., Nemhauser, G. L., & Savelsbergh, M. W. (1999). Lifted flow cover inequalities for mixed 0-1 integer programs."]
    #[doc = "  Mathematical Programming, 85(3), 439-467."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcalcFlowCover(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        postprocess: ::std::os::raw::c_uint,
        boundswitch: f64,
        allowlocal: ::std::os::raw::c_uint,
        aggrrow: *mut SCIP_AGGRROW,
        cutcoefs: *mut f64,
        cutrhs: *mut f64,
        cutinds: *mut ::std::os::raw::c_int,
        cutnnz: *mut ::std::os::raw::c_int,
        cutefficacy: *mut f64,
        cutrank: *mut ::std::os::raw::c_int,
        cutislocal: *mut ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calculates a strong CG cut out of the weighted sum of LP rows given by an aggregation row; the"]
    #[doc = "  aggregation row must not contain non-zero weights for modifiable rows, because these rows cannot"]
    #[doc = "  participate in a strongcg cut"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcalcStrongCG(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        postprocess: ::std::os::raw::c_uint,
        boundswitch: f64,
        usevbds: ::std::os::raw::c_uint,
        allowlocal: ::std::os::raw::c_uint,
        minfrac: f64,
        maxfrac: f64,
        scale: f64,
        aggrrow: *mut SCIP_AGGRROW,
        cutcoefs: *mut f64,
        cutrhs: *mut f64,
        cutinds: *mut ::std::os::raw::c_int,
        cutnnz: *mut ::std::os::raw::c_int,
        cutefficacy: *mut f64,
        cutrank: *mut ::std::os::raw::c_int,
        cutislocal: *mut ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " performs a diving within the limits of the @p diveset parameters"]
    #[doc = ""]
    #[doc = "  This method performs a diving according to the settings defined by the diving settings @p diveset; Contrary to the"]
    #[doc = "  name, SCIP enters probing mode (not diving mode) and dives along a path into the tree. Domain propagation"]
    #[doc = "  is applied at every node in the tree, whereas probing LPs might be solved less frequently."]
    #[doc = ""]
    #[doc = "  Starting from the current LP solution, the algorithm selects candidates which maximize the"]
    #[doc = "  score defined by the @p diveset and whose solution value has not yet been rendered infeasible by propagation,"]
    #[doc = "  and propagates the bound change on this candidate."]
    #[doc = ""]
    #[doc = "  The algorithm iteratively selects the the next (unfixed) candidate in the list, until either enough domain changes"]
    #[doc = "  or the resolve frequency of the LP trigger an LP resolve (and hence, the set of potential candidates changes),"]
    #[doc = "  or the last node is proven to be infeasible. It optionally backtracks and tries the"]
    #[doc = "  other branching direction."]
    #[doc = ""]
    #[doc = "  After the set of remaining candidates is empty or the targeted depth is reached, the node LP is"]
    #[doc = "  solved, and the old candidates are replaced by the new LP candidates."]
    #[doc = ""]
    #[doc = "  @see heur_guideddiving.c for an example implementation of a dive set controlling the diving algorithm."]
    #[doc = ""]
    #[doc = "  @note the node from where the algorithm is called is checked for a basic LP solution. If the solution"]
    #[doc = "        is non-basic, e.g., when barrier without crossover is used, the method returns without performing a dive."]
    #[doc = ""]
    #[doc = "  @note currently, when multiple diving heuristics call this method and solve an LP at the same node, only the first"]
    #[doc = "        call will be executed, @see SCIPgetLastDiveNode()."]
    pub fn SCIPperformGenericDivingAlgorithm(
        scip: *mut SCIP,
        diveset: *mut SCIP_DIVESET,
        worksol: *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
        result: *mut SCIP_RESULT,
        nodeinfeasible: ::std::os::raw::c_uint,
        iterlim: ::std::os::raw::c_longlong,
        divecontext: SCIP_DIVECONTEXT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get a sub-SCIP copy of the transformed problem"]
    pub fn SCIPcopyLargeNeighborhoodSearch(
        sourcescip: *mut SCIP,
        subscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        suffix: *const ::std::os::raw::c_char,
        fixedvars: *mut *mut SCIP_VAR,
        fixedvals: *mut f64,
        nfixedvars: ::std::os::raw::c_int,
        uselprows: ::std::os::raw::c_uint,
        copycuts: ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a trust region neighborhood constraint to the @p targetscip"]
    #[doc = ""]
    #[doc = "  a trust region constraint measures the deviation from the current incumbent solution \\f$x^*\\f$ by an auxiliary"]
    #[doc = "  continuous variable \\f$v \\geq 0\\f$:"]
    #[doc = "  \\f["]
    #[doc = "    \\sum\\limits_{j\\in B} |x_j^* - x_j| = v"]
    #[doc = "  \\f]"]
    #[doc = "  Only binary variables are taken into account. The deviation is penalized in the objective function using"]
    #[doc = "  a positive \\p violpenalty."]
    #[doc = ""]
    #[doc = "  @note: the trust region constraint creates an auxiliary variable to penalize the deviation from"]
    #[doc = "  the current incumbent solution. This variable can afterwards be accessed using SCIPfindVar() by its name"]
    #[doc = "  'trustregion_violationvar'"]
    pub fn SCIPaddTrustregionNeighborhoodConstraint(
        scip: *mut SCIP,
        subscip: *mut SCIP,
        subvars: *mut *mut SCIP_VAR,
        violpenalty: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " includes a bandit algorithm virtual function table"]
    pub fn SCIPincludeBanditvtable(
        scip: *mut SCIP,
        banditvtable: *mut *mut SCIP_BANDITVTABLE,
        name: *const ::std::os::raw::c_char,
        banditfree: ::std::option::Option<
            unsafe extern "C" fn(blkmem: *mut BMS_BLKMEM, bandit: *mut SCIP_BANDIT) -> SCIP_RETCODE,
        >,
        banditselect: ::std::option::Option<
            unsafe extern "C" fn(
                bandit: *mut SCIP_BANDIT,
                selection: *mut ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        banditupdate: ::std::option::Option<
            unsafe extern "C" fn(
                bandit: *mut SCIP_BANDIT,
                selection: ::std::os::raw::c_int,
                score: f64,
            ) -> SCIP_RETCODE,
        >,
        banditreset: ::std::option::Option<
            unsafe extern "C" fn(
                bufmem: *mut BMS_BUFMEM,
                bandit: *mut SCIP_BANDIT,
                priorities: *mut f64,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the bandit virtual function table of the given name, or NULL if not existing"]
    pub fn SCIPfindBanditvtable(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_BANDITVTABLE;
}
extern "C" {
    #[doc = " calls destructor and frees memory of bandit algorithm"]
    pub fn SCIPfreeBandit(scip: *mut SCIP, bandit: *mut *mut SCIP_BANDIT) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reset the bandit algorithm"]
    pub fn SCIPresetBandit(
        scip: *mut SCIP,
        bandit: *mut SCIP_BANDIT,
        priorities: *mut f64,
        seed: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a Benders' decomposition and includes it in SCIP"]
    #[doc = ""]
    #[doc = "  To use the Benders' decomposition for solving a problem, it first has to be activated with a call to SCIPactivateBenders()."]
    #[doc = "  This should be done during the problem creation stage."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note method has all Benders' decomposition callbacks as arguments and is thus changed every time a new callback is"]
    #[doc = "        added in future releases; consider using SCIPincludeBendersBasic() and setter functions"]
    #[doc = "        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeBenders(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        cutlp: ::std::os::raw::c_uint,
        cutpseudo: ::std::os::raw::c_uint,
        cutrelax: ::std::os::raw::c_uint,
        shareauxvars: ::std::os::raw::c_uint,
        benderscopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                threadsafe: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        bendersfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersinitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersexitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
        bendersgetvar: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                var: *mut SCIP_VAR,
                mappedvar: *mut *mut SCIP_VAR,
                probnumber: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        benderscreatesub: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                probnumber: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        benderspresubsolve: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                type_: SCIP_BENDERSENFOTYPE,
                checkint: ::std::os::raw::c_uint,
                infeasible: *mut ::std::os::raw::c_uint,
                auxviol: *mut ::std::os::raw::c_uint,
                skipsolve: *mut ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        benderssolvesubconvex: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                probnumber: ::std::os::raw::c_int,
                onlyconvexcheck: ::std::os::raw::c_uint,
                objective: *mut f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        benderssolvesub: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                probnumber: ::std::os::raw::c_int,
                objective: *mut f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        benderspostsolve: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                type_: SCIP_BENDERSENFOTYPE,
                mergecands: *mut ::std::os::raw::c_int,
                npriomergecands: ::std::os::raw::c_int,
                nmergecands: ::std::os::raw::c_int,
                checkint: ::std::os::raw::c_uint,
                infeasible: ::std::os::raw::c_uint,
                merged: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        bendersfreesub: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                probnumber: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        bendersdata: *mut SCIP_BENDERSDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a Benders' decomposition and includes it in SCIP with all non-fundamental callbacks set to NULL"]
    #[doc = ""]
    #[doc = "  If needed, the non-fundamental callbacks can be added afterwards via setter functions SCIPsetBendersCopy(),"]
    #[doc = "  SCIPsetBendersFree(), SCIPsetBendersInity(), SCIPsetBendersExit(), SCIPsetBendersInitsol(), SCIPsetBendersExitsol(),"]
    #[doc = "  SCIPsetBendersFarkas()."]
    #[doc = ""]
    #[doc = "  To use the Benders' decomposition for solving a problem, it first has to be activated with a call to SCIPactivateBenders()."]
    #[doc = "  This should be done during the problem creation stage."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note if you want to set all callbacks with a single method call, consider using SCIPincludeBenders() instead"]
    pub fn SCIPincludeBendersBasic(
        scip: *mut SCIP,
        bendersptr: *mut *mut SCIP_BENDERS,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        cutlp: ::std::os::raw::c_uint,
        cutpseudo: ::std::os::raw::c_uint,
        cutrelax: ::std::os::raw::c_uint,
        shareauxvars: ::std::os::raw::c_uint,
        bendersgetvar: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                var: *mut SCIP_VAR,
                mappedvar: *mut *mut SCIP_VAR,
                probnumber: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        benderscreatesub: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                probnumber: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        bendersdata: *mut SCIP_BENDERSDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of benders"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersCopy(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        benderscopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                threadsafe: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of benders"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersFree(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of benders"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersInit(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of benders"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersExit(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets presolving initialization method of benders"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersInitpre(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersinitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets presolving deinitialization method of benders"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersExitpre(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersexitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of benders"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersInitsol(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of benders"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersExitsol(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        bendersexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the method called prior to solving the subproblems for benders"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersPresubsolve(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        benderspresubsolve: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                type_: SCIP_BENDERSENFOTYPE,
                checkint: ::std::os::raw::c_uint,
                infeasible: *mut ::std::os::raw::c_uint,
                auxviol: *mut ::std::os::raw::c_uint,
                skipsolve: *mut ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the subproblem solving and freeing methods for Benders' decomposition"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersSolveAndFreesub(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        benderssolvesubconvex: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                probnumber: ::std::os::raw::c_int,
                onlyconvexcheck: ::std::os::raw::c_uint,
                objective: *mut f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        benderssolvesub: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                probnumber: ::std::os::raw::c_int,
                objective: *mut f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        bendersfreesub: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                probnumber: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the post solving methods for benders"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersPostsolve(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        benderspostsolve: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                sol: *mut SCIP_SOL,
                type_: SCIP_BENDERSENFOTYPE,
                mergecands: *mut ::std::os::raw::c_int,
                npriomergecands: ::std::os::raw::c_int,
                nmergecands: ::std::os::raw::c_int,
                checkint: ::std::os::raw::c_uint,
                infeasible: ::std::os::raw::c_uint,
                merged: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the subproblem comparison method for determining the solving order in Benders' decomposition"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBendersSubproblemComp(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        benderssubcomp: ::std::option::Option<
            unsafe extern "C" fn(
                elem1: *mut ::std::os::raw::c_void,
                elem2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the Benders' decomposition of the given name, or NULL if not existing"]
    pub fn SCIPfindBenders(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_BENDERS;
}
extern "C" {
    #[doc = " returns the array of currently available Benders' decomposition; active Benders' decomposition are in the first"]
    #[doc = " slots of the array"]
    pub fn SCIPgetBenders(scip: *mut SCIP) -> *mut *mut SCIP_BENDERS;
}
extern "C" {
    #[doc = " returns the number of currently available Benders' decomposition"]
    pub fn SCIPgetNBenders(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of currently active Benders' decomposition"]
    pub fn SCIPgetNActiveBenders(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " activates the Benders' decomposition to be used for the current problem"]
    #[doc = ""]
    #[doc = "  This method should be called during the problem creation stage for all pricers that are necessary to solve"]
    #[doc = "  the problem model."]
    #[doc = ""]
    #[doc = "  @note The Benders' decompositions are automatically deactivated when the problem is freed."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPactivateBenders(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        nsubproblems: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " deactivates the Benders' decomposition"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPdeactivateBenders(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the priority of a Benders' decomposition"]
    pub fn SCIPsetBendersPriority(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        priority: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " calls the exec method of Benders' decomposition to solve the subproblems"]
    #[doc = ""]
    #[doc = "  The checkint flag indicates whether integer feasibility can be assumed. If it is not assumed, i.e. checkint =="]
    #[doc = "  FALSE, then only the convex relaxations of the subproblems are solved. If integer feasibility is assumed, i.e."]
    #[doc = "  checkint == TRUE, then the convex relaxations and the full CIP are solved to generate Benders' cuts and check"]
    #[doc = "  solution feasibility."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPsolveBendersSubproblems(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        sol: *mut SCIP_SOL,
        result: *mut SCIP_RESULT,
        infeasible: *mut ::std::os::raw::c_uint,
        auxviol: *mut ::std::os::raw::c_uint,
        type_: SCIP_BENDERSENFOTYPE,
        checkint: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the master problem variable for the given subproblem variable"]
    #[doc = ""]
    #[doc = "  This function is used as part of the cut generation process."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetBendersMasterVar(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        var: *mut SCIP_VAR,
        mappedvar: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the subproblem problem variable for the given master variable"]
    #[doc = ""]
    #[doc = "  This function is used as part of the cut generation process."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetBendersSubproblemVar(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        var: *mut SCIP_VAR,
        mappedvar: *mut *mut SCIP_VAR,
        probnumber: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the number of subproblems that are stored in the given Benders' decomposition"]
    #[doc = ""]
    #[doc = "  @return the number of subproblems in the Benders' decomposition"]
    pub fn SCIPgetBendersNSubproblems(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " registers the Benders' decomposition subproblem with the Benders' decomposition struct."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPaddBendersSubproblem(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        subproblem: *mut SCIP,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls the generic subproblem setup method for a Benders' decomposition subproblem"]
    #[doc = ""]
    #[doc = "  This is called if the user requires to solve the Benders' decomposition subproblem separately from the main Benders'"]
    #[doc = "  solving loop. This could be in the case of enhancement techniques."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPsetupBendersSubproblem(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        sol: *mut SCIP_SOL,
        probnumber: ::std::os::raw::c_int,
        type_: SCIP_BENDERSENFOTYPE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls the solving method for a single Benders' decomposition subproblem"]
    #[doc = ""]
    #[doc = "  The method either calls the users solve subproblem method or calls the generic method. In the case of the generic"]
    #[doc = "  method, the user must set up the subproblem prior to calling this method."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPsolveBendersSubproblem(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        sol: *mut SCIP_SOL,
        probnumber: ::std::os::raw::c_int,
        infeasible: *mut ::std::os::raw::c_uint,
        solvecip: ::std::os::raw::c_uint,
        objective: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees the subproblem after calling the solve subproblem method"]
    #[doc = ""]
    #[doc = "  This will either call the user defined free"]
    #[doc = "  subproblem callback for Benders' decomposition or the default freeing methods. In the default case, if the"]
    #[doc = "  subproblem is an LP, then SCIPendProbing is called. If the subproblem is a MIP, then SCIPfreeTransform is called."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPfreeBendersSubproblem(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks the optimality of a Benders' decomposition subproblem by comparing the objective function value against the"]
    #[doc = "  value of the corresponding auxiliary variable"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if requested subproblem is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcheckBendersSubproblemOptimality(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        sol: *mut SCIP_SOL,
        probnumber: ::std::os::raw::c_int,
        optimal: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the value of the auxiliary variable for a given subproblem"]
    pub fn SCIPgetBendersAuxiliaryVarVal(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        sol: *mut SCIP_SOL,
        probnumber: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " solves an independent subproblem to identify its lower bound and updates the lower bound of the corresponding"]
    #[doc = "  auxiliary variable"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcomputeBendersSubproblemLowerbound(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        probnumber: ::std::os::raw::c_int,
        lowerbound: *mut f64,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " merges a subproblem into the master problem."]
    #[doc = ""]
    #[doc = "  This process just adds a copy of the subproblem variables and constraints to the master problem, but keeps the"]
    #[doc = "  subproblem stored in the Benders' decomposition data structure.  The reason for keeping the subproblem available is"]
    #[doc = "  for when it is queried for solutions after the problem is solved."]
    #[doc = ""]
    #[doc = "  Once the subproblem is merged into the master problem, then the subproblem is flagged as disabled. This means that"]
    #[doc = "  it will not be solved in the subsequent subproblem solving loops."]
    #[doc = ""]
    #[doc = "  The associated auxiliary variables are kept in the master problem. The objective function of the merged subproblem"]
    #[doc = "  is added as an underestimator constraint."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPmergeBendersSubproblemIntoMaster(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        probnumber: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " applies a Benders' decomposition to the selected decomposition from the decomposition store"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPapplyBendersDecomposition(
        scip: *mut SCIP,
        decompindex: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a Benders' cut algorithms and includes it in the associated Benders' decomposition"]
    #[doc = ""]
    #[doc = "  This should be called from the SCIPincludeBendersXyz for the associated Benders' decomposition. It is only possible"]
    #[doc = "  to include a Benders' cut algorithm if a Benders' decomposition has already been included"]
    #[doc = "  This should be done during the problem creation stage."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note method has all Benders' decomposition callbacks as arguments and is thus changed every time a new callback is"]
    #[doc = "        added in future releases; consider using SCIPincludeBendersBasic() and setter functions"]
    #[doc = "        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeBenderscut(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        islpcut: ::std::os::raw::c_uint,
        benderscutcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                benderscut: *mut SCIP_BENDERSCUT,
            ) -> SCIP_RETCODE,
        >,
        benderscutfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
        benderscutinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
        benderscutexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
        benderscutinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
        benderscutexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
        benderscutexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                benderscut: *mut SCIP_BENDERSCUT,
                sol: *mut SCIP_SOL,
                probnumber: ::std::os::raw::c_int,
                type_: SCIP_BENDERSENFOTYPE,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        benderscutdata: *mut SCIP_BENDERSCUTDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a Benders' cut and includes it an associated Benders' decomposition with all non-fundamental callbacks set to NULL"]
    #[doc = ""]
    #[doc = "  If needed, the non-fundamental callbacks can be added afterwards via setter functions SCIPsetBenderscutCopy(),"]
    #[doc = "  SCIPsetBenderscutFree(), SCIPsetBenderscutInit(), SCIPsetBenderscutExit(), SCIPsetBenderscutInitsol(),"]
    #[doc = "  SCIPsetBenderscutExitsol()."]
    #[doc = ""]
    #[doc = "  This should be done during the problem creation stage."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note if you want to set all callbacks with a single method call, consider using SCIPincludeBenders() instead"]
    pub fn SCIPincludeBenderscutBasic(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        benderscutptr: *mut *mut SCIP_BENDERSCUT,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        islpcut: ::std::os::raw::c_uint,
        benderscutexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                benderscut: *mut SCIP_BENDERSCUT,
                sol: *mut SCIP_SOL,
                probnumber: ::std::os::raw::c_int,
                type_: SCIP_BENDERSENFOTYPE,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        benderscutdata: *mut SCIP_BENDERSCUTDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of Benders' decomposition cut"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutCopy(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                benders: *mut SCIP_BENDERS,
                benderscut: *mut SCIP_BENDERSCUT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of benderscut"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutFree(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of benderscut"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutInit(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of benderscut"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutExit(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of benderscut"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutInitsol(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of benderscut"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutExitsol(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        benderscutexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, benderscut: *mut SCIP_BENDERSCUT) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the priority of a Benders' decomposition cut algorithm"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetBenderscutPriority(
        scip: *mut SCIP,
        benderscut: *mut SCIP_BENDERSCUT,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds the generated cuts to the Benders' cut storage"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPstoreBendersCut(
        scip: *mut SCIP,
        benders: *mut SCIP_BENDERS,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
        nvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " applies the Benders' decomposition cuts in storage to the input SCIP instance"]
    #[doc = ""]
    #[doc = "  When calling the function, the user must be sure that the variables are associated with the input SCIP instance."]
    #[doc = "  The main use of this method is to transfer Benders' cuts between solvers in ParaSCIP."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPapplyBendersStoredCuts(scip: *mut SCIP, benders: *mut SCIP_BENDERS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a branching rule and includes it in SCIP"]
    #[doc = ""]
    #[doc = "  @note method has all branching rule callbacks as arguments and is thus changed every time a new"]
    #[doc = "        callback is added in future releases; consider using SCIPincludeBranchruleBasic() and setter functions"]
    #[doc = "        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeBranchrule(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        maxdepth: ::std::os::raw::c_int,
        maxbounddist: f64,
        branchcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
        branchfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
        branchinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
        branchexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
        branchinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
        branchexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
        branchexeclp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                branchrule: *mut SCIP_BRANCHRULE,
                allowaddcons: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        branchexecext: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                branchrule: *mut SCIP_BRANCHRULE,
                allowaddcons: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        branchexecps: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                branchrule: *mut SCIP_BRANCHRULE,
                allowaddcons: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        branchruledata: *mut SCIP_BRANCHRULEDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a branching rule and includes it in SCIP. All non-fundamental (or optional) callbacks will be set to NULL."]
    #[doc = "  Optional callbacks can be set via specific setter functions, see SCIPsetBranchruleInit(), SCIPsetBranchruleExit(),"]
    #[doc = "  SCIPsetBranchruleCopy(), SCIPsetBranchruleFree(), SCIPsetBranchruleInitsol(), SCIPsetBranchruleExitsol(),"]
    #[doc = "  SCIPsetBranchruleExecLp(), SCIPsetBranchruleExecExt(), and SCIPsetBranchruleExecPs()."]
    #[doc = ""]
    #[doc = "  @note if you want to set all callbacks with a single method call, consider using SCIPincludeBranchrule() instead"]
    pub fn SCIPincludeBranchruleBasic(
        scip: *mut SCIP,
        branchruleptr: *mut *mut SCIP_BRANCHRULE,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        maxdepth: ::std::os::raw::c_int,
        maxbounddist: f64,
        branchruledata: *mut SCIP_BRANCHRULEDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of branching rule"]
    pub fn SCIPsetBranchruleCopy(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of branching rule"]
    pub fn SCIPsetBranchruleFree(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of branching rule"]
    pub fn SCIPsetBranchruleInit(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of branching rule"]
    pub fn SCIPsetBranchruleExit(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of branching rule"]
    pub fn SCIPsetBranchruleInitsol(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of branching rule"]
    pub fn SCIPsetBranchruleExitsol(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, branchrule: *mut SCIP_BRANCHRULE) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets branching execution method for fractional LP solutions"]
    pub fn SCIPsetBranchruleExecLp(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchexeclp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                branchrule: *mut SCIP_BRANCHRULE,
                allowaddcons: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets branching execution method for external candidates"]
    pub fn SCIPsetBranchruleExecExt(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchexecext: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                branchrule: *mut SCIP_BRANCHRULE,
                allowaddcons: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets branching execution method for not completely fixed pseudo solutions"]
    pub fn SCIPsetBranchruleExecPs(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        branchexecps: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                branchrule: *mut SCIP_BRANCHRULE,
                allowaddcons: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the branching rule of the given name, or NULL if not existing"]
    pub fn SCIPfindBranchrule(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_BRANCHRULE;
}
extern "C" {
    #[doc = " returns the array of currently available branching rules"]
    pub fn SCIPgetBranchrules(scip: *mut SCIP) -> *mut *mut SCIP_BRANCHRULE;
}
extern "C" {
    #[doc = " returns the number of currently available branching rules"]
    pub fn SCIPgetNBranchrules(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a branching rule"]
    pub fn SCIPsetBranchrulePriority(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets maximal depth level, up to which this branching rule should be used (-1 for no limit)"]
    pub fn SCIPsetBranchruleMaxdepth(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        maxdepth: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets maximal relative distance from current node's dual bound to primal bound for applying branching rule"]
    pub fn SCIPsetBranchruleMaxbounddist(
        scip: *mut SCIP,
        branchrule: *mut SCIP_BRANCHRULE,
        maxbounddist: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets branching candidates for LP solution branching (fractional variables) along with solution values,"]
    #[doc = "  fractionalities, and number of branching candidates; The number of branching candidates does NOT"]
    #[doc = "  account for fractional implicit integer variables which should not be used for branching decisions."]
    #[doc = ""]
    #[doc = "  Fractional implicit integer variables are stored at the positions *nlpcands to *nlpcands + *nfracimplvars - 1"]
    #[doc = ""]
    #[doc = "  branching rules should always select the branching candidate among the first npriolpcands of the candidate"]
    #[doc = "  list"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPBranchCands(
        scip: *mut SCIP,
        lpcands: *mut *mut *mut SCIP_VAR,
        lpcandssol: *mut *mut f64,
        lpcandsfrac: *mut *mut f64,
        nlpcands: *mut ::std::os::raw::c_int,
        npriolpcands: *mut ::std::os::raw::c_int,
        nfracimplvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of branching candidates for LP solution branching (number of fractional variables)"]
    #[doc = ""]
    #[doc = "  @return the number of branching candidates for LP solution branching (number of fractional variables)."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNLPBranchCands(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of branching candidates with maximal priority for LP solution branching"]
    #[doc = ""]
    #[doc = "  @return the number of branching candidates with maximal priority for LP solution branching."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioLPBranchCands(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets external branching candidates along with solution values, scores, and number of branching candidates;"]
    #[doc = "  these branching candidates can be used by relaxations or nonlinear constraint handlers;"]
    #[doc = "  branching rules should always select the branching candidate among the first nprioexterncands of the candidate"]
    #[doc = "  list"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    #[doc = ""]
    #[doc = "  @note Candidate variables with maximal priority are ordered: binaries first, then integers, implicit integers and"]
    #[doc = "        continuous last."]
    pub fn SCIPgetExternBranchCands(
        scip: *mut SCIP,
        externcands: *mut *mut *mut SCIP_VAR,
        externcandssol: *mut *mut f64,
        externcandsscore: *mut *mut f64,
        nexterncands: *mut ::std::os::raw::c_int,
        nprioexterncands: *mut ::std::os::raw::c_int,
        nprioexternbins: *mut ::std::os::raw::c_int,
        nprioexternints: *mut ::std::os::raw::c_int,
        nprioexternimpls: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of external branching candidates"]
    #[doc = ""]
    #[doc = "  @return the number of external branching candidates."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNExternBranchCands(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of external branching candidates with maximal branch priority"]
    #[doc = ""]
    #[doc = "  @return the number of external branching candidates with maximal branch priority."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioExternBranchCands(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of binary external branching candidates with maximal branch priority"]
    #[doc = ""]
    #[doc = "  @return the number of binary external branching candidates with maximal branch priority."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioExternBranchBins(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of integer external branching candidates with maximal branch priority"]
    #[doc = ""]
    #[doc = "  @return the number of integer external branching candidates with maximal branch priority."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioExternBranchInts(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of implicit integer external branching candidates with maximal branch priority"]
    #[doc = ""]
    #[doc = "  @return the number of implicit integer external branching candidates with maximal branch priority."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioExternBranchImpls(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of continuous external branching candidates with maximal branch priority"]
    #[doc = ""]
    #[doc = "  @return the number of continuous external branching candidates with maximal branch priority."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioExternBranchConts(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " insert variable, its score and its solution value into the external branching candidate storage"]
    #[doc = " the relative difference of the current lower and upper bounds of a continuous variable must be at least epsilon"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPaddExternBranchCand(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        score: f64,
        solval: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes all external candidates from the storage for external branching"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPclearExternBranchCands(scip: *mut SCIP);
}
extern "C" {
    #[doc = " checks whether the given variable is contained in the candidate storage for external branching"]
    #[doc = ""]
    #[doc = "  @return whether the given variable is contained in the candidate storage for external branching."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcontainsExternBranchCand(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets branching candidates for pseudo solution branching (non-fixed variables) along with the number of candidates"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetPseudoBranchCands(
        scip: *mut SCIP,
        pseudocands: *mut *mut *mut SCIP_VAR,
        npseudocands: *mut ::std::os::raw::c_int,
        npriopseudocands: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of branching candidates for pseudo solution branching (non-fixed variables)"]
    #[doc = ""]
    #[doc = "  @return the number branching candidates for pseudo solution branching (non-fixed variables)."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPseudoBranchCands(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of branching candidates with maximal branch priority for pseudo solution branching"]
    #[doc = ""]
    #[doc = "  @return the number of branching candidates with maximal branch priority for pseudo solution branching."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioPseudoBranchCands(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of binary branching candidates with maximal branch priority for pseudo solution branching"]
    #[doc = ""]
    #[doc = "  @return the number of binary branching candidates with maximal branch priority for pseudo solution branching."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioPseudoBranchBins(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of integer branching candidates with maximal branch priority for pseudo solution branching"]
    #[doc = ""]
    #[doc = "  @return the number of integer branching candidates with maximal branch priority for pseudo solution branching."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioPseudoBranchInts(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of implicit integer branching candidates with maximal branch priority for pseudo solution branching"]
    #[doc = ""]
    #[doc = "  @return the number of implicit integer branching candidates with maximal branch priority for pseudo solution branching."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNPrioPseudoBranchImpls(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " calculates the branching score out of the gain predictions for a binary branching"]
    #[doc = ""]
    #[doc = "  @return the branching score out of the gain predictions for a binary branching."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetBranchScore(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        downgain: f64,
        upgain: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " calculates the branching score out of the gain predictions for a branching with arbitrary many children"]
    #[doc = ""]
    #[doc = "  @return the branching score out of the gain predictions for a branching with arbitrary many children."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetBranchScoreMultiple(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        nchildren: ::std::os::raw::c_int,
        gains: *mut f64,
    ) -> f64;
}
extern "C" {
    #[doc = " computes a branching point for a continuous or discrete variable"]
    #[doc = ""]
    #[doc = "  @see SCIPbranchGetBranchingPoint"]
    #[doc = ""]
    #[doc = "  @return the branching point for a continuous or discrete variable."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetBranchingPoint(scip: *mut SCIP, var: *mut SCIP_VAR, suggestion: f64) -> f64;
}
extern "C" {
    #[doc = " calculates the node selection priority for moving the given variable's LP value to the given target value;"]
    #[doc = "  this node selection priority can be given to the SCIPcreateChild() call"]
    #[doc = ""]
    #[doc = "  @return the node selection priority for moving the given variable's LP value to the given target value."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcalcNodeselPriority(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        branchdir: SCIP_BRANCHDIR,
        targetvalue: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " calculates an estimate for the objective of the best feasible solution contained in the subtree after applying the given"]
    #[doc = "  branching; this estimate can be given to the SCIPcreateChild() call"]
    #[doc = ""]
    #[doc = "  @return the estimate for the objective of the best feasible solution contained in the subtree after applying the given"]
    #[doc = "  branching."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcalcChildEstimate(scip: *mut SCIP, var: *mut SCIP_VAR, targetvalue: f64) -> f64;
}
extern "C" {
    #[doc = " calculates the increase of the estimate for the objective of the best feasible solution contained in the subtree"]
    #[doc = "  after applying the given branching"]
    #[doc = ""]
    #[doc = "  @return the increase of the estimate for the objective of the best feasible solution contained in the subtree after"]
    #[doc = "          applying the given branching."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcalcChildEstimateIncrease(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        varsol: f64,
        targetvalue: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " creates a child node of the focus node"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcreateChild(
        scip: *mut SCIP,
        node: *mut *mut SCIP_NODE,
        nodeselprio: f64,
        estimate: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " branches on a non-continuous variable v using the current LP or pseudo solution;"]
    #[doc = "  if solution value x' is fractional, two child nodes will be created"]
    #[doc = "  (x <= floor(x'), x >= ceil(x')),"]
    #[doc = "  if solution value is integral, the x' is equal to lower or upper bound of the branching"]
    #[doc = "  variable and the bounds of v are finite, then two child nodes will be created"]
    #[doc = "  (x <= x'', x >= x''+1 with x'' = floor((lb + ub)/2)),"]
    #[doc = "  otherwise (up to) three child nodes will be created"]
    #[doc = "  (x <= x'-1, x == x', x >= x'+1)"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        downchild: *mut *mut SCIP_NODE,
        eqchild: *mut *mut SCIP_NODE,
        upchild: *mut *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " branches a variable x using a given domain hole; two child nodes (x <= left, x >= right) are created"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchVarHole(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        left: f64,
        right: f64,
        downchild: *mut *mut SCIP_NODE,
        upchild: *mut *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " branches on a variable x using a given value x';"]
    #[doc = "  for continuous variables with relative domain width larger epsilon, x' must not be one of the bounds;"]
    #[doc = "  two child nodes (x <= x', x >= x') are created;"]
    #[doc = "  for integer variables, if solution value x' is fractional, two child nodes are created"]
    #[doc = "  (x <= floor(x'), x >= ceil(x')),"]
    #[doc = "  if x' is integral, three child nodes are created"]
    #[doc = "  (x <= x'-1, x == x', x >= x'+1)"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchVarVal(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        val: f64,
        downchild: *mut *mut SCIP_NODE,
        eqchild: *mut *mut SCIP_NODE,
        upchild: *mut *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " n-ary branching on a variable x using a given value"]
    #[doc = ""]
    #[doc = "  Branches on variable x such that up to n/2 children are created on each side of the usual branching value."]
    #[doc = "  The branching value is selected as in SCIPbranchVarVal()."]
    #[doc = "  The parameters minwidth and widthfactor determine the domain width of the branching variable in the child nodes."]
    #[doc = "  If n is odd, one child with domain width 'width' and having the branching value in the middle is created."]
    #[doc = "  Otherwise, two children with domain width 'width' and being left and right of the branching value are created."]
    #[doc = "  Next further nodes to the left and right are created, where width is multiplied by widthfactor with increasing distance"]
    #[doc = "  from the first nodes."]
    #[doc = "  The initial width is calculated such that n/2 nodes are created to the left and to the right of the branching value."]
    #[doc = "  If this value is below minwidth, the initial width is set to minwidth, which may result in creating less than n nodes."]
    #[doc = ""]
    #[doc = "  Giving a large value for widthfactor results in creating children with small domain when close to the branching value"]
    #[doc = "  and large domain when closer to the current variable bounds. That is, setting widthfactor to a very large value and n to 3"]
    #[doc = "  results in a ternary branching where the branching variable is mostly fixed in the middle child."]
    #[doc = "  Setting widthfactor to 1.0 results in children where the branching variable always has the same domain width"]
    #[doc = "  (except for one child if the branching value is not in the middle)."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchVarValNary(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        val: f64,
        n: ::std::os::raw::c_int,
        minwidth: f64,
        widthfactor: f64,
        nchildren: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls branching rules to branch on an LP solution; if no fractional variables exist, the result is SCIP_DIDNOTRUN;"]
    #[doc = "  if the branch priority of an unfixed variable is larger than the maximal branch priority of the fractional"]
    #[doc = "  variables, pseudo solution branching is applied on the unfixed variables with maximal branch priority"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchLP(scip: *mut SCIP, result: *mut SCIP_RESULT) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls branching rules to branch on a external candidates; if no such candidates exist, the result is SCIP_DIDNOTRUN"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchExtern(scip: *mut SCIP, result: *mut SCIP_RESULT) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls branching rules to branch on a pseudo solution; if no unfixed variables exist, the result is SCIP_DIDNOTRUN"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPbranchPseudo(scip: *mut SCIP, result: *mut SCIP_RESULT) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = "@addtogroup PublicCompressionMethods"]
    #[doc = ""]
    #[doc = " @{"]
    #[doc = ""]
    #[doc = "  @note method has all compression callbacks as arguments and is thus changed every time a new"]
    #[doc = "        callback is added in future releases; consider using SCIPincludeComprBasic() and setter functions"]
    #[doc = "        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeCompr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        minnnodes: ::std::os::raw::c_int,
        comprcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
        comprfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
        comprinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
        comprexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
        comprinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
        comprexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
        comprexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                compr: *mut SCIP_COMPR,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        comprdata: *mut SCIP_COMPRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a tree compression and includes it in SCIP with its most fundamental callbacks."]
    #[doc = "  All non-fundamental (or optional) callbacks"]
    #[doc = "  as, e. g., init and exit callbacks, will be set to NULL."]
    #[doc = "  Optional callbacks can be set via specific setter functions, see SCIPsetComprCopy(), SCIPsetComprFree(),"]
    #[doc = "  SCIPsetComprInit(), SCIPsetComprExit(), SCIPsetComprInitsol(), and SCIPsetComprExitsol()"]
    #[doc = ""]
    #[doc = "  @note if you want to set all callbacks with a single method call, consider using SCIPincludeCompr() instead"]
    pub fn SCIPincludeComprBasic(
        scip: *mut SCIP,
        compr: *mut *mut SCIP_COMPR,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        minnnodes: ::std::os::raw::c_int,
        comprexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                compr: *mut SCIP_COMPR,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        comprdata: *mut SCIP_COMPRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of tree compression"]
    pub fn SCIPsetComprCopy(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        comprcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of tree compression"]
    pub fn SCIPsetComprFree(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        comprfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of tree compression"]
    pub fn SCIPsetComprInit(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        comprinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of tree compression"]
    pub fn SCIPsetComprExit(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        comprexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of tree compression"]
    pub fn SCIPsetComprInitsol(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        comprinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of tree compression"]
    pub fn SCIPsetComprExitsol(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        comprexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, compr: *mut SCIP_COMPR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the tree compression of the given name, or NULL if not existing"]
    pub fn SCIPfindCompr(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_COMPR;
}
extern "C" {
    #[doc = " returns the array of currently available tree compression"]
    pub fn SCIPgetComprs(scip: *mut SCIP) -> *mut *mut SCIP_COMPR;
}
extern "C" {
    #[doc = " returns the number of currently available tree compression"]
    pub fn SCIPgetNCompr(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set the priority of a tree compression method"]
    pub fn SCIPsetComprPriority(
        scip: *mut SCIP,
        compr: *mut SCIP_COMPR,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a concurrent solver type and includes it in SCIP."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPincludeConcsolverType(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        prefpriodefault: f64,
        concsolvercreateinst: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                concsolvertype: *mut SCIP_CONCSOLVERTYPE,
                concsolver: *mut SCIP_CONCSOLVER,
            ) -> SCIP_RETCODE,
        >,
        concsolverdestroyinst: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, concsolver: *mut SCIP_CONCSOLVER) -> SCIP_RETCODE,
        >,
        concsolverinitseeds: ::std::option::Option<
            unsafe extern "C" fn(
                concsolver: *mut SCIP_CONCSOLVER,
                seed: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        concsolverexec: ::std::option::Option<
            unsafe extern "C" fn(
                concsolver: *mut SCIP_CONCSOLVER,
                solvingtime: *mut f64,
                nlpiterations: *mut ::std::os::raw::c_longlong,
                nnodes: *mut ::std::os::raw::c_longlong,
            ) -> SCIP_RETCODE,
        >,
        concsolvercopysolvdata: ::std::option::Option<
            unsafe extern "C" fn(concsolver: *mut SCIP_CONCSOLVER, scip: *mut SCIP) -> SCIP_RETCODE,
        >,
        concsolverstop: ::std::option::Option<
            unsafe extern "C" fn(concsolver: *mut SCIP_CONCSOLVER) -> SCIP_RETCODE,
        >,
        concsolversyncwrite: ::std::option::Option<
            unsafe extern "C" fn(
                concsolver: *mut SCIP_CONCSOLVER,
                syncstore: *mut SCIP_SYNCSTORE,
                syncdata: *mut SCIP_SYNCDATA,
                maxcandsols: ::std::os::raw::c_int,
                maxsharedsols: ::std::os::raw::c_int,
                nsolsshared: *mut ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        concsolversyncread: ::std::option::Option<
            unsafe extern "C" fn(
                concsolver: *mut SCIP_CONCSOLVER,
                syncstore: *mut SCIP_SYNCSTORE,
                syncdata: *mut SCIP_SYNCDATA,
                nsolsrecvd: *mut ::std::os::raw::c_int,
                ntighterbnds: *mut ::std::os::raw::c_int,
                ntighterintbnds: *mut ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        concsolvertypefreedata: ::std::option::Option<
            unsafe extern "C" fn(data: *mut *mut SCIP_CONCSOLVERTYPEDATA),
        >,
        data: *mut SCIP_CONCSOLVERTYPEDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the concurrent solver type with the given name, or NULL if not existing"]
    pub fn SCIPfindConcsolverType(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_CONCSOLVERTYPE;
}
extern "C" {
    #[doc = " returns the array of included concurrent solver types"]
    pub fn SCIPgetConcsolverTypes(scip: *mut SCIP) -> *mut *mut SCIP_CONCSOLVERTYPE;
}
extern "C" {
    #[doc = " returns the number of included concurrent solver types"]
    pub fn SCIPgetNConcsolverTypes(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Constructs the parallel interface to execute processes concurrently."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPconstructSyncstore(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " releases the current synchronization store"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = "       - \\ref SCIP_STAGE_FREE"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPfreeSyncstore(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Gets the synchronization store."]
    #[doc = ""]
    #[doc = "  @return the \\ref SCIP_SYNCSTORE parallel interface pointer to submit jobs for concurrent processing."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetSyncstore(scip: *mut SCIP) -> *mut SCIP_SYNCSTORE;
}
extern "C" {
    #[doc = " creates a conflict handler and includes it in SCIP"]
    #[doc = ""]
    #[doc = "  @note method has all conflict handler callbacks as arguments and is thus changed every time a new"]
    #[doc = "        callback is added"]
    #[doc = "        in future releases; consider using SCIPincludeConflicthdlrBasic() and setter functions"]
    #[doc = "        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeConflicthdlr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        conflictcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
        conflictfree: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
        conflictinit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
        conflictexit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
        conflictinitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
        conflictexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
        conflictexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
                node: *mut SCIP_NODE,
                validnode: *mut SCIP_NODE,
                bdchginfos: *mut *mut SCIP_BDCHGINFO,
                relaxedbds: *mut f64,
                nbdchginfos: ::std::os::raw::c_int,
                conftype: SCIP_CONFTYPE,
                cutoffinvolved: ::std::os::raw::c_uint,
                separate: ::std::os::raw::c_uint,
                local: ::std::os::raw::c_uint,
                dynamic: ::std::os::raw::c_uint,
                removable: ::std::os::raw::c_uint,
                resolved: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conflicthdlrdata: *mut SCIP_CONFLICTHDLRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a conflict handler and includes it in SCIP with its most fundamental callbacks. All non-fundamental"]
    #[doc = "  (or optional) callbacks as, e.g., init and exit callbacks, will be set to NULL."]
    #[doc = "  Optional callbacks can be set via specific setter functions SCIPsetConflicthdlrCopy(), SCIPsetConflicthdlrFree(),"]
    #[doc = "  SCIPsetConflicthdlrInit(), SCIPsetConflicthdlrExit(), SCIPsetConflicthdlrInitsol(),"]
    #[doc = "  and SCIPsetConflicthdlrExitsol()"]
    #[doc = ""]
    #[doc = "  @note if you want to set all callbacks with a single method call, consider using SCIPincludeConflicthdlr() instead"]
    pub fn SCIPincludeConflicthdlrBasic(
        scip: *mut SCIP,
        conflicthdlrptr: *mut *mut SCIP_CONFLICTHDLR,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        conflictexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
                node: *mut SCIP_NODE,
                validnode: *mut SCIP_NODE,
                bdchginfos: *mut *mut SCIP_BDCHGINFO,
                relaxedbds: *mut f64,
                nbdchginfos: ::std::os::raw::c_int,
                conftype: SCIP_CONFTYPE,
                cutoffinvolved: ::std::os::raw::c_uint,
                separate: ::std::os::raw::c_uint,
                local: ::std::os::raw::c_uint,
                dynamic: ::std::os::raw::c_uint,
                removable: ::std::os::raw::c_uint,
                resolved: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conflicthdlrdata: *mut SCIP_CONFLICTHDLRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set copy method of conflict handler"]
    pub fn SCIPsetConflicthdlrCopy(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflictcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set destructor of conflict handler"]
    pub fn SCIPsetConflicthdlrFree(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflictfree: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set initialization method of conflict handler"]
    pub fn SCIPsetConflicthdlrInit(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflictinit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set deinitialization method of conflict handler"]
    pub fn SCIPsetConflicthdlrExit(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflictexit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set solving process initialization method of conflict handler"]
    pub fn SCIPsetConflicthdlrInitsol(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflictinitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set solving process deinitialization method of conflict handler"]
    pub fn SCIPsetConflicthdlrExitsol(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        conflictexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conflicthdlr: *mut SCIP_CONFLICTHDLR,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the conflict handler of the given name, or NULL if not existing"]
    pub fn SCIPfindConflicthdlr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_CONFLICTHDLR;
}
extern "C" {
    #[doc = " returns the array of currently available conflict handlers"]
    pub fn SCIPgetConflicthdlrs(scip: *mut SCIP) -> *mut *mut SCIP_CONFLICTHDLR;
}
extern "C" {
    #[doc = " returns the number of currently available conflict handlers"]
    pub fn SCIPgetNConflicthdlrs(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a conflict handler"]
    pub fn SCIPsetConflicthdlrPriority(
        scip: *mut SCIP,
        conflicthdlr: *mut SCIP_CONFLICTHDLR,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " return TRUE if conflict analysis is applicable; In case the function return FALSE there is no need to initialize the"]
    #[doc = "  conflict analysis since it will not be applied"]
    #[doc = ""]
    #[doc = "  @return return TRUE if conflict analysis is applicable; In case the function return FALSE there is no need to initialize the"]
    #[doc = "          conflict analysis since it will not be applied"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note SCIP stage does not get changed"]
    pub fn SCIPisConflictAnalysisApplicable(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " initializes the conflict analysis by clearing the conflict candidate queue; this method must be called before you"]
    #[doc = "  enter the conflict variables by calling SCIPaddConflictLb(), SCIPaddConflictUb(), SCIPaddConflictBd(),"]
    #[doc = "  SCIPaddConflictRelaxedLb(), SCIPaddConflictRelaxedUb(), SCIPaddConflictRelaxedBd(), or SCIPaddConflictBinvar();"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note SCIP stage does not get changed"]
    pub fn SCIPinitConflictAnalysis(
        scip: *mut SCIP,
        conftype: SCIP_CONFTYPE,
        iscutoffinvolved: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds lower bound of variable at the time of the given bound change index to the conflict analysis' candidate storage;"]
    #[doc = "  this method should be called in one of the following two cases:"]
    #[doc = "   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictLb() should be called for each lower bound"]
    #[doc = "      that led to the conflict (e.g. the infeasibility of globally or locally valid constraint)."]
    #[doc = "   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictLb() should be called"]
    #[doc = "      for each lower bound, whose current assignment led to the deduction of the given conflict bound."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictLb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds lower bound of variable at the time of the given bound change index to the conflict analysis' candidate storage"]
    #[doc = "  with the additional information of a relaxed lower bound; this relaxed lower bound is the one which would be enough"]
    #[doc = "  to explain a certain bound change;"]
    #[doc = "  this method should be called in one of the following two cases:"]
    #[doc = "   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictRelaxedLb() should be called for each (relaxed) lower bound"]
    #[doc = "      that led to the conflict (e.g. the infeasibility of globally or locally valid constraint)."]
    #[doc = "   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictRelexedLb() should be called"]
    #[doc = "      for each (relaxed) lower bound, whose current assignment led to the deduction of the given conflict bound."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictRelaxedLb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        relaxedlb: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds upper bound of variable at the time of the given bound change index to the conflict analysis' candidate storage;"]
    #[doc = "  this method should be called in one of the following two cases:"]
    #[doc = "   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictUb() should be called for each upper bound that"]
    #[doc = "      led to the conflict (e.g. the infeasibility of globally or locally valid constraint)."]
    #[doc = "   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictUb() should be called for"]
    #[doc = "      each upper bound, whose current assignment led to the deduction of the given conflict bound."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictUb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds upper bound of variable at the time of the given bound change index to the conflict analysis' candidate storage"]
    #[doc = "  with the additional information of a relaxed upper bound; this relaxed upper bound is the one which would be enough"]
    #[doc = "  to explain a certain bound change;"]
    #[doc = "  this method should be called in one of the following two cases:"]
    #[doc = "   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictRelaxedUb() should be called for each (relaxed) upper"]
    #[doc = "      bound that led to the conflict (e.g. the infeasibility of globally or locally valid constraint)."]
    #[doc = "   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictRelaxedUb() should be"]
    #[doc = "      called for each (relaxed) upper bound, whose current assignment led to the deduction of the given conflict"]
    #[doc = "      bound."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictRelaxedUb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        relaxedub: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds lower or upper bound of variable at the time of the given bound change index to the conflict analysis' candidate"]
    #[doc = "  storage; this method should be called in one of the following two cases:"]
    #[doc = "   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictBd() should be called for each bound"]
    #[doc = "      that led to the conflict (e.g. the infeasibility of globally or locally valid constraint)."]
    #[doc = "   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictBd() should be called"]
    #[doc = "      for each bound, whose current assignment led to the deduction of the given conflict bound."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictBd(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds lower or upper bound of variable at the time of the given bound change index to the conflict analysis'"]
    #[doc = "  candidate storage; with the additional information of a relaxed upper bound; this relaxed upper bound is the one"]
    #[doc = "  which would be enough to explain a certain bound change;"]
    #[doc = "  this method should be called in one of the following two cases:"]
    #[doc = "   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictRelaxedBd() should be called for each (relaxed)"]
    #[doc = "      bound that led to the conflict (e.g. the infeasibility of globally or locally valid constraint)."]
    #[doc = "   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictRelaxedBd() should be"]
    #[doc = "      called for each (relaxed) bound, whose current assignment led to the deduction of the given conflict bound."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictRelaxedBd(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
        relaxedbd: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds changed bound of fixed binary variable to the conflict analysis' candidate storage;"]
    #[doc = "  this method should be called in one of the following two cases:"]
    #[doc = "   1. Before calling the SCIPanalyzeConflict() method, SCIPaddConflictBinvar() should be called for each fixed binary"]
    #[doc = "      variable that led to the conflict (e.g. the infeasibility of globally or locally valid constraint)."]
    #[doc = "   2. In the propagation conflict resolving method of a constraint handler, SCIPaddConflictBinvar() should be called"]
    #[doc = "      for each binary variable, whose current fixing led to the deduction of the given conflict bound."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note SCIP stage does not get changed"]
    pub fn SCIPaddConflictBinvar(scip: *mut SCIP, var: *mut SCIP_VAR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks if the given variable is already part of the current conflict set or queued for resolving with the same or"]
    #[doc = "  even stronger bound"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note SCIP stage does not get changed"]
    pub fn SCIPisConflictVarUsed(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
        used: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the conflict lower bound if the variable is present in the current conflict set; otherwise the global lower"]
    #[doc = "  bound"]
    #[doc = ""]
    #[doc = "  @return returns the conflict lower bound if the variable is present in the current conflict set; otherwise the global lower"]
    #[doc = "          bound"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note SCIP stage does not get changed"]
    pub fn SCIPgetConflictVarLb(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the conflict upper bound if the variable is present in the current conflict set; otherwise minus global"]
    #[doc = "  upper bound"]
    #[doc = ""]
    #[doc = "  @return returns the conflict upper bound if the variable is present in the current conflict set; otherwise minus global"]
    #[doc = "          upper bound"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note SCIP stage does not get changed"]
    pub fn SCIPgetConflictVarUb(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " analyzes conflict bounds that were added after a call to SCIPinitConflictAnalysis() with calls to"]
    #[doc = "  SCIPaddConflictLb(), SCIPaddConflictUb(), SCIPaddConflictBd(), SCIPaddConflictRelaxedLb(),"]
    #[doc = "  SCIPaddConflictRelaxedUb(), SCIPaddConflictRelaxedBd(), or SCIPaddConflictBinvar(); on success, calls the conflict"]
    #[doc = "  handlers to create a conflict constraint out of the resulting conflict set; the given valid depth must be a depth"]
    #[doc = "  level, at which the conflict set defined by calls to SCIPaddConflictLb(), SCIPaddConflictUb(), SCIPaddConflictBd(),"]
    #[doc = "  SCIPaddConflictRelaxedLb(), SCIPaddConflictRelaxedUb(), SCIPaddConflictRelaxedBd(), and SCIPaddConflictBinvar() is"]
    #[doc = "  valid for the whole subtree; if the conflict was found by a violated constraint, use SCIPanalyzeConflictCons()"]
    #[doc = "  instead of SCIPanalyzeConflict() to make sure, that the correct valid depth is used"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note SCIP stage does not get changed"]
    pub fn SCIPanalyzeConflict(
        scip: *mut SCIP,
        validdepth: ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " analyzes conflict bounds that were added with calls to SCIPaddConflictLb(), SCIPaddConflictUb(),"]
    #[doc = "  SCIPaddConflictBd(), SCIPaddConflictRelaxedLb(), SCIPaddConflictRelaxedUb(), SCIPaddConflictRelaxedBd(), or"]
    #[doc = "  SCIPaddConflictBinvar(); on success, calls the conflict handlers to create a conflict constraint out of the"]
    #[doc = "  resulting conflict set; the given constraint must be the constraint that detected the conflict, i.e. the constraint"]
    #[doc = "  that is infeasible in the local bounds of the initial conflict set (defined by calls to SCIPaddConflictLb(),"]
    #[doc = "  SCIPaddConflictUb(), SCIPaddConflictBd(), SCIPaddConflictRelaxedLb(), SCIPaddConflictRelaxedUb(),"]
    #[doc = "  SCIPaddConflictRelaxedBd(), and SCIPaddConflictBinvar())"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note SCIP stage does not get changed"]
    pub fn SCIPanalyzeConflictCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a constraint handler and includes it in SCIP."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note method has all constraint handler callbacks as arguments and is thus changed every time a new"]
    #[doc = "        callback is added"]
    #[doc = "        in future releases; consider using SCIPincludeConshdlrBasic() and setter functions"]
    #[doc = "        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeConshdlr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        sepapriority: ::std::os::raw::c_int,
        enfopriority: ::std::os::raw::c_int,
        chckpriority: ::std::os::raw::c_int,
        sepafreq: ::std::os::raw::c_int,
        propfreq: ::std::os::raw::c_int,
        eagerfreq: ::std::os::raw::c_int,
        maxprerounds: ::std::os::raw::c_int,
        delaysepa: ::std::os::raw::c_uint,
        delayprop: ::std::os::raw::c_uint,
        needscons: ::std::os::raw::c_uint,
        proptiming: SCIP_PROPTIMING,
        presoltiming: SCIP_PRESOLTIMING,
        conshdlrcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                valid: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, conshdlr: *mut SCIP_CONSHDLR) -> SCIP_RETCODE,
        >,
        consinit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consexit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consinitpre: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consexitpre: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consinitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                restart: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consdelete: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                consdata: *mut *mut SCIP_CONSDATA,
            ) -> SCIP_RETCODE,
        >,
        constrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                sourcecons: *mut SCIP_CONS,
                targetcons: *mut *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
        consinitlp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                infeasible: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        conssepalp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conssepasol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                sol: *mut SCIP_SOL,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        consenfolp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        consenforelax: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sol: *mut SCIP_SOL,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        consenfops: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                objinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conscheck: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                sol: *mut SCIP_SOL,
                checkintegrality: ::std::os::raw::c_uint,
                checklprows: ::std::os::raw::c_uint,
                printreason: ::std::os::raw::c_uint,
                completely: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        consprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                nmarkedconss: ::std::os::raw::c_int,
                proptiming: SCIP_PROPTIMING,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conspresol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nrounds: ::std::os::raw::c_int,
                presoltiming: SCIP_PRESOLTIMING,
                nnewfixedvars: ::std::os::raw::c_int,
                nnewaggrvars: ::std::os::raw::c_int,
                nnewchgvartypes: ::std::os::raw::c_int,
                nnewchgbds: ::std::os::raw::c_int,
                nnewholes: ::std::os::raw::c_int,
                nnewdelconss: ::std::os::raw::c_int,
                nnewaddconss: ::std::os::raw::c_int,
                nnewupgdconss: ::std::os::raw::c_int,
                nnewchgcoefs: ::std::os::raw::c_int,
                nnewchgsides: ::std::os::raw::c_int,
                nfixedvars: *mut ::std::os::raw::c_int,
                naggrvars: *mut ::std::os::raw::c_int,
                nchgvartypes: *mut ::std::os::raw::c_int,
                nchgbds: *mut ::std::os::raw::c_int,
                naddholes: *mut ::std::os::raw::c_int,
                ndelconss: *mut ::std::os::raw::c_int,
                naddconss: *mut ::std::os::raw::c_int,
                nupgdconss: *mut ::std::os::raw::c_int,
                nchgcoefs: *mut ::std::os::raw::c_int,
                nchgsides: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        consresprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                infervar: *mut SCIP_VAR,
                inferinfo: ::std::os::raw::c_int,
                boundtype: SCIP_BOUNDTYPE,
                bdchgidx: *mut SCIP_BDCHGIDX,
                relaxedbd: f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conslock: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                locktype: SCIP_LOCKTYPE,
                nlockspos: ::std::os::raw::c_int,
                nlocksneg: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consactive: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
        consdeactive: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
        consenable: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
        consdisable: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
        consdelvars: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        consprint: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                file: *mut FILE,
            ) -> SCIP_RETCODE,
        >,
        conscopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                cons: *mut *mut SCIP_CONS,
                name: *const ::std::os::raw::c_char,
                sourcescip: *mut SCIP,
                sourceconshdlr: *mut SCIP_CONSHDLR,
                sourcecons: *mut SCIP_CONS,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                initial: ::std::os::raw::c_uint,
                separate: ::std::os::raw::c_uint,
                enforce: ::std::os::raw::c_uint,
                check: ::std::os::raw::c_uint,
                propagate: ::std::os::raw::c_uint,
                local: ::std::os::raw::c_uint,
                modifiable: ::std::os::raw::c_uint,
                dynamic: ::std::os::raw::c_uint,
                removable: ::std::os::raw::c_uint,
                stickingatnode: ::std::os::raw::c_uint,
                global: ::std::os::raw::c_uint,
                valid: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consparse: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut *mut SCIP_CONS,
                name: *const ::std::os::raw::c_char,
                str_: *const ::std::os::raw::c_char,
                initial: ::std::os::raw::c_uint,
                separate: ::std::os::raw::c_uint,
                enforce: ::std::os::raw::c_uint,
                check: ::std::os::raw::c_uint,
                propagate: ::std::os::raw::c_uint,
                local: ::std::os::raw::c_uint,
                modifiable: ::std::os::raw::c_uint,
                dynamic: ::std::os::raw::c_uint,
                removable: ::std::os::raw::c_uint,
                stickingatnode: ::std::os::raw::c_uint,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consgetvars: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                vars: *mut *mut SCIP_VAR,
                varssize: ::std::os::raw::c_int,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consgetnvars: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                nvars: *mut ::std::os::raw::c_int,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        consgetdivebdchgs: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                diveset: *mut SCIP_DIVESET,
                sol: *mut SCIP_SOL,
                success: *mut ::std::os::raw::c_uint,
                infeasible: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        conshdlrdata: *mut SCIP_CONSHDLRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a constraint handler and includes it in SCIP. All non-fundamental (or optional) callbacks will be set to NULL."]
    #[doc = "  Optional callbacks can be set via specific setter functions, see SCIPsetConshdlrInit(), SCIPsetConshdlrExit(),"]
    #[doc = "  SCIPsetConshdlrCopy(), SCIPsetConshdlrFree(), SCIPsetConshdlrInitsol(), SCIPsetConshdlrExitsol(),"]
    #[doc = "  SCIPsetConshdlrInitpre(), SCIPsetConshdlrExitpre(), SCIPsetConshdlrPresol(), SCIPsetConshdlrDelete(),"]
    #[doc = "  SCIPsetConshdlrDelvars(), SCIPsetConshdlrInitlp(), SCIPsetConshdlrActive(), SCIPsetConshdlrDeactive(),"]
    #[doc = "  SCIPsetConshdlrEnable(), SCIPsetConshdlrDisable(), SCIPsetConshdlrResprop(), SCIPsetConshdlrTrans(),"]
    #[doc = "  SCIPsetConshdlrPrint(), SCIPsetConshdlrParse(), SCIPsetConshdlrGetVars(), SCIPsetConshdlrGetNVars(), and"]
    #[doc = "  SCIPsetConshdlrGetDiveBdChgs()."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note if you want to set all callbacks with a single method call, consider using SCIPincludeConshdlr() instead"]
    pub fn SCIPincludeConshdlrBasic(
        scip: *mut SCIP,
        conshdlrptr: *mut *mut SCIP_CONSHDLR,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        enfopriority: ::std::os::raw::c_int,
        chckpriority: ::std::os::raw::c_int,
        eagerfreq: ::std::os::raw::c_int,
        needscons: ::std::os::raw::c_uint,
        consenfolp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        consenfops: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                objinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conscheck: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                sol: *mut SCIP_SOL,
                checkintegrality: ::std::os::raw::c_uint,
                checklprows: ::std::os::raw::c_uint,
                printreason: ::std::os::raw::c_uint,
                completely: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conslock: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                locktype: SCIP_LOCKTYPE,
                nlockspos: ::std::os::raw::c_int,
                nlocksneg: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
        conshdlrdata: *mut SCIP_CONSHDLRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets all separation related callbacks/parameters of the constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrSepa(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        conssepalp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        conssepasol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                sol: *mut SCIP_SOL,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        sepafreq: ::std::os::raw::c_int,
        sepapriority: ::std::os::raw::c_int,
        delaysepa: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets both the propagation callback and the propagation frequency of the constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrProp(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                nmarkedconss: ::std::os::raw::c_int,
                proptiming: SCIP_PROPTIMING,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        propfreq: ::std::os::raw::c_int,
        delayprop: ::std::os::raw::c_uint,
        proptiming: SCIP_PROPTIMING,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets relaxation enforcement method of the constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrEnforelax(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consenforelax: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sol: *mut SCIP_SOL,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nusefulconss: ::std::os::raw::c_int,
                solinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of both the constraint handler and each associated constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrCopy(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        conshdlrcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                valid: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        conscopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                cons: *mut *mut SCIP_CONS,
                name: *const ::std::os::raw::c_char,
                sourcescip: *mut SCIP,
                sourceconshdlr: *mut SCIP_CONSHDLR,
                sourcecons: *mut SCIP_CONS,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                initial: ::std::os::raw::c_uint,
                separate: ::std::os::raw::c_uint,
                enforce: ::std::os::raw::c_uint,
                check: ::std::os::raw::c_uint,
                propagate: ::std::os::raw::c_uint,
                local: ::std::os::raw::c_uint,
                modifiable: ::std::os::raw::c_uint,
                dynamic: ::std::os::raw::c_uint,
                removable: ::std::os::raw::c_uint,
                stickingatnode: ::std::os::raw::c_uint,
                global: ::std::os::raw::c_uint,
                valid: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrFree(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, conshdlr: *mut SCIP_CONSHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrInit(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consinit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrExit(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consexit: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrInitsol(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consinitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrExitsol(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                restart: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets preprocessing initialization method of constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrInitpre(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consinitpre: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets preprocessing deinitialization method of constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrExitpre(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consexitpre: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets presolving method of constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrPresol(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        conspresol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                nrounds: ::std::os::raw::c_int,
                presoltiming: SCIP_PRESOLTIMING,
                nnewfixedvars: ::std::os::raw::c_int,
                nnewaggrvars: ::std::os::raw::c_int,
                nnewchgvartypes: ::std::os::raw::c_int,
                nnewchgbds: ::std::os::raw::c_int,
                nnewholes: ::std::os::raw::c_int,
                nnewdelconss: ::std::os::raw::c_int,
                nnewaddconss: ::std::os::raw::c_int,
                nnewupgdconss: ::std::os::raw::c_int,
                nnewchgcoefs: ::std::os::raw::c_int,
                nnewchgsides: ::std::os::raw::c_int,
                nfixedvars: *mut ::std::os::raw::c_int,
                naggrvars: *mut ::std::os::raw::c_int,
                nchgvartypes: *mut ::std::os::raw::c_int,
                nchgbds: *mut ::std::os::raw::c_int,
                naddholes: *mut ::std::os::raw::c_int,
                ndelconss: *mut ::std::os::raw::c_int,
                naddconss: *mut ::std::os::raw::c_int,
                nupgdconss: *mut ::std::os::raw::c_int,
                nchgcoefs: *mut ::std::os::raw::c_int,
                nchgsides: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        maxprerounds: ::std::os::raw::c_int,
        presoltiming: SCIP_PRESOLTIMING,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets method of constraint handler to free specific constraint data"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrDelete(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consdelete: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                consdata: *mut *mut SCIP_CONSDATA,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets method of constraint handler to transform constraint data into data belonging to the transformed problem"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrTrans(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        constrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                sourcecons: *mut SCIP_CONS,
                targetcons: *mut *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets method of constraint handler to initialize LP with relaxations of \"initial\" constraints"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrInitlp(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consinitlp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                infeasible: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets propagation conflict resolving method of constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrResprop(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consresprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                infervar: *mut SCIP_VAR,
                inferinfo: ::std::os::raw::c_int,
                boundtype: SCIP_BOUNDTYPE,
                bdchgidx: *mut SCIP_BDCHGIDX,
                relaxedbd: f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets activation notification method of constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrActive(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consactive: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deactivation notification method of constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrDeactive(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consdeactive: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets enabling notification method of constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrEnable(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consenable: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets disabling notification method of constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrDisable(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consdisable: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets variable deletion method of constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrDelvars(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consdelvars: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets constraint display method of constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrPrint(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consprint: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                file: *mut FILE,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets constraint parsing method of constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrParse(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consparse: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut *mut SCIP_CONS,
                name: *const ::std::os::raw::c_char,
                str_: *const ::std::os::raw::c_char,
                initial: ::std::os::raw::c_uint,
                separate: ::std::os::raw::c_uint,
                enforce: ::std::os::raw::c_uint,
                check: ::std::os::raw::c_uint,
                propagate: ::std::os::raw::c_uint,
                local: ::std::os::raw::c_uint,
                modifiable: ::std::os::raw::c_uint,
                dynamic: ::std::os::raw::c_uint,
                removable: ::std::os::raw::c_uint,
                stickingatnode: ::std::os::raw::c_uint,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets constraint variable getter method of constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrGetVars(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consgetvars: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                vars: *mut *mut SCIP_VAR,
                varssize: ::std::os::raw::c_int,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets constraint variable number getter method of constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrGetNVars(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consgetnvars: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                cons: *mut SCIP_CONS,
                nvars: *mut ::std::os::raw::c_int,
                success: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets diving enforcement method of constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetConshdlrGetDiveBdChgs(
        scip: *mut SCIP,
        conshdlr: *mut SCIP_CONSHDLR,
        consgetdivebdchgs: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                conshdlr: *mut SCIP_CONSHDLR,
                diveset: *mut SCIP_DIVESET,
                sol: *mut SCIP_SOL,
                success: *mut ::std::os::raw::c_uint,
                infeasible: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the constraint handler of the given name, or NULL if not existing"]
    pub fn SCIPfindConshdlr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_CONSHDLR;
}
extern "C" {
    #[doc = " returns the array of currently available constraint handlers"]
    pub fn SCIPgetConshdlrs(scip: *mut SCIP) -> *mut *mut SCIP_CONSHDLR;
}
extern "C" {
    #[doc = " returns the number of currently available constraint handlers"]
    pub fn SCIPgetNConshdlrs(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates and captures a constraint of the given constraint handler"]
    #[doc = ""]
    #[doc = "  @warning If a constraint is marked to be checked for feasibility but not to be enforced, a LP or pseudo solution may"]
    #[doc = "           be declared feasible even if it violates this particular constraint.  This constellation should only be"]
    #[doc = "           used, if no LP or pseudo solution can violate the constraint -- e.g. if a local constraint is redundant due"]
    #[doc = "           to the variable's local bounds."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = ""]
    #[doc = "  @note the constraint gets captured, hence at one point you have to release it using the method SCIPreleaseCons()"]
    pub fn SCIPcreateCons(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        conshdlr: *mut SCIP_CONSHDLR,
        consdata: *mut SCIP_CONSDATA,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " parses constraint information (in cip format) out of a string; if the parsing process was successful a constraint is"]
    #[doc = "  creates and captures;"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = ""]
    #[doc = "  @warning If a constraint is marked to be checked for feasibility but not to be enforced, a LP or pseudo solution may"]
    #[doc = "           be declared feasible even if it violates this particular constraint.  This constellation should only be"]
    #[doc = "           used, if no LP or pseudo solution can violate the constraint -- e.g. if a local constraint is redundant due"]
    #[doc = "           to the variable's local bounds."]
    pub fn SCIPparseCons(
        scip: *mut SCIP,
        cons: *mut *mut SCIP_CONS,
        str_: *const ::std::os::raw::c_char,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " increases usage counter of constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcaptureCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " decreases usage counter of constraint, if the usage pointer reaches zero the constraint gets freed"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  @note the pointer of the constraint will be NULLed"]
    pub fn SCIPreleaseCons(scip: *mut SCIP, cons: *mut *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " change constraint name"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note to get the current name of a constraint, use SCIPconsGetName() from pub_cons.h"]
    pub fn SCIPchgConsName(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the initial flag of the given constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsInitial(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        initial: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the separate flag of the given constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsSeparated(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        separate: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the enforce flag of the given constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsEnforced(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        enforce: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the check flag of the given constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsChecked(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        check: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the propagate flag of the given constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsPropagated(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        propagate: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the local flag of the given constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsLocal(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        local: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the modifiable flag of the given constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPsetConsModifiable(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        modifiable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the dynamic flag of the given constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsDynamic(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        dynamic: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the removable flag of the given constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsRemovable(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the stickingatnode flag of the given constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetConsStickingAtNode(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        stickingatnode: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " updates the flags of the first constraint according to the ones of the second constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPupdateConsFlags(
        scip: *mut SCIP,
        cons0: *mut SCIP_CONS,
        cons1: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets and captures transformed constraint of a given constraint; if the constraint is not yet transformed,"]
    #[doc = "  a new transformed constraint for this constraint is created"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPtransformCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        transcons: *mut *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets and captures transformed constraints for an array of constraints;"]
    #[doc = "  if a constraint in the array is not yet transformed, a new transformed constraint for this constraint is created;"]
    #[doc = "  it is possible to call this method with conss == transconss"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPtransformConss(
        scip: *mut SCIP,
        nconss: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        transconss: *mut *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets corresponding transformed constraint of a given constraint;"]
    #[doc = "  returns NULL as transcons, if transformed constraint is not yet existing"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetTransformedCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        transcons: *mut *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets corresponding transformed constraints for an array of constraints;"]
    #[doc = "  stores NULL in a transconss slot, if the transformed constraint is not yet existing;"]
    #[doc = "  it is possible to call this method with conss == transconss, but remember that constraints that are not"]
    #[doc = "  yet transformed will be replaced with NULL"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetTransformedConss(
        scip: *mut SCIP,
        nconss: ::std::os::raw::c_int,
        conss: *mut *mut SCIP_CONS,
        transconss: *mut *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds given value to age of constraint, but age can never become negative;"]
    #[doc = "  should be called"]
    #[doc = "   - in constraint separation, if no cut was found for this constraint,"]
    #[doc = "   - in constraint enforcing, if constraint was feasible, and"]
    #[doc = "   - in constraint propagation, if no domain reduction was deduced;"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPaddConsAge(scip: *mut SCIP, cons: *mut SCIP_CONS, deltaage: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " increases age of constraint by 1.0;"]
    #[doc = "  should be called"]
    #[doc = "   - in constraint separation, if no cut was found for this constraint,"]
    #[doc = "   - in constraint enforcing, if constraint was feasible, and"]
    #[doc = "   - in constraint propagation, if no domain reduction was deduced;"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPincConsAge(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " resets age of constraint to zero;"]
    #[doc = "  should be called"]
    #[doc = "   - in constraint separation, if a cut was found for this constraint,"]
    #[doc = "   - in constraint enforcing, if the constraint was violated, and"]
    #[doc = "   - in constraint propagation, if a domain reduction was deduced;"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPresetConsAge(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enables constraint's separation, propagation, and enforcing capabilities"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPenableCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " disables constraint's separation, propagation, and enforcing capabilities, s.t. the constraint is not propagated,"]
    #[doc = "  separated, and enforced anymore until it is enabled again with a call to SCIPenableCons();"]
    #[doc = "  in contrast to SCIPdelConsLocal() and SCIPdelConsNode(), the disabling is not associated to a node in the tree and"]
    #[doc = "  does not consume memory; therefore, the constraint is neither automatically enabled on leaving the node nor"]
    #[doc = "  automatically disabled again on entering the node again;"]
    #[doc = "  note that the constraints enforcing capabilities are necessary for the solution's feasibility, if the constraint"]
    #[doc = "  is a model constraint; that means, you must be sure that the constraint cannot be violated in the current subtree,"]
    #[doc = "  and you have to enable it again manually by calling SCIPenableCons(), if this subtree is left (e.g. by using"]
    #[doc = "  an appropriate event handler that watches the corresponding variables' domain changes)"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPdisableCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enables constraint's separation capabilities"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPenableConsSeparation(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " disables constraint's separation capabilities s.t. the constraint is not propagated anymore until the separation"]
    #[doc = "  is enabled again with a call to SCIPenableConsSeparation(); in contrast to SCIPdelConsLocal() and SCIPdelConsNode(),"]
    #[doc = "  the disabling is not associated to a node in the tree and does not consume memory; therefore, the constraint"]
    #[doc = "  is neither automatically enabled on leaving the node nor automatically disabled again on entering the node again"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPdisableConsSeparation(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enables constraint's propagation capabilities"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPenableConsPropagation(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " disables constraint's propagation capabilities s.t. the constraint is not propagated anymore until the propagation"]
    #[doc = "  is enabled again with a call to SCIPenableConsPropagation(); in contrast to SCIPdelConsLocal() and SCIPdelConsNode(),"]
    #[doc = "  the disabling is not associated to a node in the tree and does not consume memory; therefore, the constraint"]
    #[doc = "  is neither automatically enabled on leaving the node nor automatically disabled again on entering the node again"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPdisableConsPropagation(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " marks constraint to be propagated"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @note if a constraint is marked to be propagated, the age of the constraint will be ignored for propagation"]
    pub fn SCIPmarkConsPropagate(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " unmarks the constraint to be propagated"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPunmarkConsPropagate(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds given values to lock status of type @p locktype of the constraint and updates the rounding locks of the involved variables"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPaddConsLocksType(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        locktype: SCIP_LOCKTYPE,
        nlockspos: ::std::os::raw::c_int,
        nlocksneg: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds given values to lock status of the constraint and updates the rounding locks of the involved variables"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  @note This methods always adds locks of type model"]
    pub fn SCIPaddConsLocks(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        nlockspos: ::std::os::raw::c_int,
        nlocksneg: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks single constraint for feasibility of the given solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcheckCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
        checkintegrality: ::std::os::raw::c_uint,
        checklprows: ::std::os::raw::c_uint,
        printreason: ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enforces single constraint for a given pseudo solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note This is an advanced method and should be used with caution.  It may only be called for constraints that were not"]
    #[doc = "        added to SCIP beforehand."]
    pub fn SCIPenfopsCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        solinfeasible: ::std::os::raw::c_uint,
        objinfeasible: ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enforces single constraint for a given LP solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note This is an advanced method and should be used with caution.  It may only be called for constraints that were not"]
    #[doc = "        added to SCIP beforehand."]
    pub fn SCIPenfolpCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        solinfeasible: ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enforces single constraint for a given relaxation solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note This is an advanced method and should be used with caution.  It may only be called for constraints that were not"]
    #[doc = "        added to SCIP beforehand."]
    pub fn SCIPenforelaxCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
        solinfeasible: ::std::os::raw::c_uint,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls LP initialization method for single constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note This is an advanced method and should be used with caution.  It may only be called for constraints that were not"]
    #[doc = "        added to SCIP beforehand."]
    pub fn SCIPinitlpCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls separation method of single constraint for LP solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note This is an advanced method and should be used with caution."]
    pub fn SCIPsepalpCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls separation method of single constraint for given primal solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note This is an advanced method and should be used with caution."]
    pub fn SCIPsepasolCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        sol: *mut SCIP_SOL,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls domain propagation method of single constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note This is an advanced method and should be used with caution."]
    pub fn SCIPpropCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        proptiming: SCIP_PROPTIMING,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " resolves propagation conflict of single constraint"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note This is an advanced method and should be used with caution.  It may only be called for constraints that were not"]
    #[doc = "        added to SCIP beforehand."]
    pub fn SCIPrespropCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        infervar: *mut SCIP_VAR,
        inferinfo: ::std::os::raw::c_int,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
        relaxedbd: f64,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " presolves of single constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = ""]
    #[doc = "  @note This is an advanced method and should be used with caution."]
    pub fn SCIPpresolCons(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        nrounds: ::std::os::raw::c_int,
        presoltiming: SCIP_PRESOLTIMING,
        nnewfixedvars: ::std::os::raw::c_int,
        nnewaggrvars: ::std::os::raw::c_int,
        nnewchgvartypes: ::std::os::raw::c_int,
        nnewchgbds: ::std::os::raw::c_int,
        nnewholes: ::std::os::raw::c_int,
        nnewdelconss: ::std::os::raw::c_int,
        nnewaddconss: ::std::os::raw::c_int,
        nnewupgdconss: ::std::os::raw::c_int,
        nnewchgcoefs: ::std::os::raw::c_int,
        nnewchgsides: ::std::os::raw::c_int,
        nfixedvars: *mut ::std::os::raw::c_int,
        naggrvars: *mut ::std::os::raw::c_int,
        nchgvartypes: *mut ::std::os::raw::c_int,
        nchgbds: *mut ::std::os::raw::c_int,
        naddholes: *mut ::std::os::raw::c_int,
        ndelconss: *mut ::std::os::raw::c_int,
        naddconss: *mut ::std::os::raw::c_int,
        nupgdconss: *mut ::std::os::raw::c_int,
        nchgcoefs: *mut ::std::os::raw::c_int,
        nchgsides: *mut ::std::os::raw::c_int,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls constraint activation notification method of single constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = ""]
    #[doc = "  @note This is an advanced method and should be used with caution.  It may only be called for constraints that were not"]
    #[doc = "      added to SCIP beforehand."]
    pub fn SCIPactiveCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calls constraint deactivation notification method of single constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note This is an advanced method and should be used with caution. It may only be called for constraints that were not"]
    #[doc = "        added to SCIP beforehand."]
    pub fn SCIPdeactiveCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs constraint information to file stream via the message handler system"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  @note If the message handler is set to a NULL pointer nothing will be printed."]
    #[doc = "  @note The file stream will not be flushed directly, this can be achieved by calling SCIPinfoMessage() printing a"]
    #[doc = "        newline character."]
    pub fn SCIPprintCons(scip: *mut SCIP, cons: *mut SCIP_CONS, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " method to collect the variables of a constraint"]
    #[doc = ""]
    #[doc = "  If the number of variables is greater than the available slots in the variable array, nothing happens except that"]
    #[doc = "  the success point is set to FALSE. With the method SCIPgetConsNVars() it is possible to get the number of variables"]
    #[doc = "  a constraint has in its scope."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  @note The success pointer indicates if all variables were copied into the vars arrray."]
    #[doc = ""]
    #[doc = "  @note It might be that a constraint handler does not support this functionality, in that case the success pointer is"]
    #[doc = "        set to FALSE."]
    pub fn SCIPgetConsVars(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        vars: *mut *mut SCIP_VAR,
        varssize: ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " method to collect the number of variables of a constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  @note The success pointer indicates if the contraint handler was able to return the number of variables"]
    #[doc = ""]
    #[doc = "  @note It might be that a constraint handler does not support this functionality, in that case the success pointer is"]
    #[doc = "        set to FALSE"]
    pub fn SCIPgetConsNVars(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        nvars: *mut ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies plugins from sourcescip to targetscip; in case that a constraint handler which does not need constraints"]
    #[doc = "  cannot be copied, valid will return FALSE. All plugins can declare that, if their copy process failed, the"]
    #[doc = "  copied SCIP instance might not represent the same problem semantics as the original."]
    #[doc = "  Note that in this case dual reductions might be invalid."]
    #[doc = ""]
    #[doc = "  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex."]
    #[doc = "        Also, 'passmessagehdlr' should be set to FALSE."]
    #[doc = ""]
    #[doc = "  @note Do not change the source SCIP environment during the copying process."]
    #[doc = ""]
    #[doc = "  @note This method does not copy Benders' plugins. To this end, the method SCIPcopyBenders() must be called"]
    #[doc = "        separately."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if sourcescip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if targetscip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_FREE"]
    #[doc = ""]
    #[doc = "  @post After calling this method targetscip reaches one of the following stages depending on if and when the solution"]
    #[doc = "        process was interrupted:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note sourcescip stage does not get changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyPlugins(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        copyreaders: ::std::os::raw::c_uint,
        copypricers: ::std::os::raw::c_uint,
        copyconshdlrs: ::std::os::raw::c_uint,
        copyconflicthdlrs: ::std::os::raw::c_uint,
        copypresolvers: ::std::os::raw::c_uint,
        copyrelaxators: ::std::os::raw::c_uint,
        copyseparators: ::std::os::raw::c_uint,
        copypropagators: ::std::os::raw::c_uint,
        copyheuristics: ::std::os::raw::c_uint,
        copyeventhdlrs: ::std::os::raw::c_uint,
        copynodeselectors: ::std::os::raw::c_uint,
        copybranchrules: ::std::os::raw::c_uint,
        copydisplays: ::std::os::raw::c_uint,
        copydialogs: ::std::os::raw::c_uint,
        copytables: ::std::os::raw::c_uint,
        copynlpis: ::std::os::raw::c_uint,
        passmessagehdlr: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies all Benders' decomposition plugins"]
    #[doc = ""]
    #[doc = "  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex."]
    #[doc = "  @note the 'threadsafe' parameter must be set to TRUE if you are absolutely certain that the source and target"]
    #[doc = "        SCIP instances will be solved in parallel. The usual case is to set this to FALSE, since thread safety"]
    #[doc = "        typically incurs a performance cost."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if sourcescip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if targetscip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_FREE"]
    #[doc = ""]
    #[doc = "  @post After calling this method targetscip reaches one of the following stages depending on if and when the solution"]
    #[doc = "        process was interrupted:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note sourcescip stage does not get changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyBenders(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        threadsafe: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " create a problem by copying the problem data of the source SCIP"]
    #[doc = ""]
    #[doc = "  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex."]
    #[doc = "  @note Do not change the source SCIP environment during the copying process"]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if sourcescip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if targetscip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_FREE"]
    #[doc = ""]
    #[doc = "  @post After calling this method targetscip reaches one of the following stages depending on if and when the solution"]
    #[doc = "        process was interrupted:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note sourcescip stage does not get changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyProb(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        name: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " create a problem by copying the original problem data of the source SCIP"]
    #[doc = ""]
    #[doc = "  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex."]
    #[doc = "  @note Do not change the source SCIP environment during the copying process"]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if sourcescip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if targetscip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_FREE"]
    #[doc = ""]
    #[doc = "  @post After calling this method targetscip reaches one of the following stages depending on if and when the solution"]
    #[doc = "        process was interrupted:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note sourcescip stage does not get changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyOrigProb(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        name: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enables constraint compression."]
    #[doc = ""]
    #[doc = "  If constraint compression is enabled, fixed variables will be treated as constants"]
    #[doc = "  by all constraints that are copied after calling this method."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPenableConsCompression(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " is constraint compression enabled?"]
    #[doc = ""]
    #[doc = "  If constraint compression is enabled, fixed variables can be treated as constants"]
    #[doc = "  by all constraints that are copied after calling this method."]
    #[doc = ""]
    #[doc = "  @return TRUE if problem constraint compression is enabled, otherwise FALSE"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if scip is in one of the following stages:"]
    #[doc = "      - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "      - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisConsCompressionEnabled(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns copy of the source variable; if there already is a copy of the source variable in the variable hash map,"]
    #[doc = "  it is just returned as target variable; otherwise, if the variables it not marked as relaxation-only, a new variable"]
    #[doc = "  will be created and added to the target SCIP; this created variable is added to the variable hash map and returned as target variable;"]
    #[doc = "  relaxation-only variables are not copied and FALSE is returned in *success"]
    #[doc = ""]
    #[doc = "  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex."]
    #[doc = "  @note Do not change the source SCIP environment during the copying process"]
    #[doc = "  @note if a new variable was created, this variable will be added to the target-SCIP, but it is not captured"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if sourcescip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if targetscip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note targetscip stage does not get changed"]
    #[doc = ""]
    #[doc = "  @note sourcescip stage does not get changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetVarCopy(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        sourcevar: *mut SCIP_VAR,
        targetvar: *mut *mut SCIP_VAR,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Copies all active (thus unfixed) variables from source-SCIP, except those that are marked as relaxation only,"]
    #[doc = "  and adds these variable to the target-SCIP."]
    #[doc = ""]
    #[doc = "  The mapping between these variables are stored in the variable hashmap."]
    #[doc = ""]
    #[doc = "  The target-SCIP has to be in problem creation stage."]
    #[doc = ""]
    #[doc = "  @note the variables are added to the target-SCIP but not captured"]
    #[doc = ""]
    #[doc = "  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex."]
    #[doc = "  @note Do not change the source SCIP environment during the copying process"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if sourcescip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if targetscip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note sourcescip stage does not get changed"]
    #[doc = ""]
    #[doc = "  @note targetscip stage does not get changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyVars(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        fixedvars: *mut *mut SCIP_VAR,
        fixedvals: *mut f64,
        nfixedvars: ::std::os::raw::c_int,
        global: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies all original variables from source-SCIP and adds these variable to the target-SCIP; the mapping between these"]
    #[doc = "  variables are stored in the variable hashmap, target-SCIP has to be in problem creation stage, fixed and aggregated"]
    #[doc = "  variables do not get copied"]
    #[doc = ""]
    #[doc = "  @note the variables are added to the target-SCIP but not captured"]
    #[doc = ""]
    #[doc = "  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex."]
    #[doc = "  @note Do not change the source SCIP environment during the copying process"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if sourcescip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if targetscip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note sourcescip stage does not get changed"]
    #[doc = ""]
    #[doc = "  @note targetscip stage does not get changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyOrigVars(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        fixedvars: *mut *mut SCIP_VAR,
        fixedvals: *mut f64,
        nfixedvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " merges the histories of variables from a source SCIP into a target SCIP. The two data structures should point to"]
    #[doc = "  different SCIP instances."]
    #[doc = ""]
    #[doc = "  @note the notion of source and target is inverted here; \\p sourcescip usually denotes a copied SCIP instance, whereas"]
    #[doc = "        \\p targetscip denotes the original instance"]
    pub fn SCIPmergeVariableStatistics(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        sourcevars: *mut *mut SCIP_VAR,
        targetvars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " translates a solution from a subscip to the main scip"]
    #[doc = ""]
    #[doc = " Variables that are relaxation-only in the master SCIP are set to 0 or the bound closest to 0. Such variables"]
    #[doc = " are represented as NULL entry in the \\p subvars array."]
    #[doc = ""]
    #[doc = " @note This method allocates a new solution of the main \\p scip that needs to be freed by the user."]
    pub fn SCIPtranslateSubSol(
        scip: *mut SCIP,
        subscip: *mut SCIP,
        subsol: *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
        subvars: *mut *mut SCIP_VAR,
        newsol: *mut *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks the solutions from the subscip and adds the first one that is found feasible to the master SCIP"]
    #[doc = ""]
    #[doc = " Variables that are relaxation-only in the master SCIP are set to 0 or the bound closest to 0. Such variables"]
    #[doc = " are represented as NULL entry in the \\p subvars array."]
    pub fn SCIPtranslateSubSols(
        scip: *mut SCIP,
        subscip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        subvars: *mut *mut SCIP_VAR,
        success: *mut ::std::os::raw::c_uint,
        solindex: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns copy of the source constraint; if there already is a copy of the source constraint in the constraint hash"]
    #[doc = "  map, it is just returned as target constraint; elsewise a new constraint will be created; this created constraint is"]
    #[doc = "  added to the constraint hash map and returned as target constraint; the variable map is used to map the variables of"]
    #[doc = "  the source SCIP to the variables of the target SCIP"]
    #[doc = ""]
    #[doc = "  @warning If a constraint is marked to be checked for feasibility but not to be enforced, a LP or pseudo solution may"]
    #[doc = "           be declared feasible even if it violates this particular constraint.  This constellation should only be"]
    #[doc = "           used, if no LP or pseudo solution can violate the constraint -- e.g. if a local constraint is redundant due"]
    #[doc = "           to the variable's local bounds."]
    #[doc = ""]
    #[doc = "  @note The constraint is not added to the target SCIP. You can check whether a constraint is added by calling"]
    #[doc = "        SCIPconsIsAdded(). (If you mix SCIPgetConsCopy() with SCIPcopyConss() you should pay attention to what you add"]
    #[doc = "        explicitly and what is already added.)"]
    #[doc = ""]
    #[doc = "  @note The constraint is always captured, either during the creation of the copy or after finding the copy of the"]
    #[doc = "        constraint in the constraint hash map"]
    #[doc = ""]
    #[doc = "  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex."]
    #[doc = "  @note Do not change the source SCIP environment during the copying process"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if sourcescip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if targetscip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = ""]
    #[doc = "  @note sourcescip stage does not get changed"]
    #[doc = ""]
    #[doc = "  @note targetscip stage does not get changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetConsCopy(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        sourcecons: *mut SCIP_CONS,
        targetcons: *mut *mut SCIP_CONS,
        sourceconshdlr: *mut SCIP_CONSHDLR,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        name: *const ::std::os::raw::c_char,
        initial: ::std::os::raw::c_uint,
        separate: ::std::os::raw::c_uint,
        enforce: ::std::os::raw::c_uint,
        check: ::std::os::raw::c_uint,
        propagate: ::std::os::raw::c_uint,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        dynamic: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        stickingatnode: ::std::os::raw::c_uint,
        global: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies constraints from the source-SCIP and adds these to the target-SCIP; for mapping the"]
    #[doc = "  variables between the source and the target SCIP a hash map can be given; if the variable hash"]
    #[doc = "  map is NULL or necessary variable mapping is missing, the required variables are created in the"]
    #[doc = "  target-SCIP and added to the hash map, if not NULL; all variables which are created are added to"]
    #[doc = "  the target-SCIP but not (user) captured; if the constraint hash map is not NULL the mapping"]
    #[doc = "  between the constraints of the source and target-SCIP is stored"]
    #[doc = ""]
    #[doc = "  *valid is set to TRUE iff all constraints that are marked as checked or enforced were copied successfully."]
    #[doc = "  If other constraints could not be copied, *valid can still be set to TRUE."]
    #[doc = ""]
    #[doc = "  @note the constraints are added to the target-SCIP but are not (user) captured in the target SCIP. (If you mix"]
    #[doc = "        SCIPgetConsCopy() with SCIPcopyConss() you should pay attention to what you add explicitly and what is already"]
    #[doc = "        added.) You can check whether a constraint is added by calling SCIPconsIsAdded()."]
    #[doc = ""]
    #[doc = "  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex."]
    #[doc = "  @note Do not change the source SCIP environment during the copying process"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if sourcescip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if targetscip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note sourcescip stage does not get changed"]
    #[doc = ""]
    #[doc = "  @note targetscip stage does not get changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyConss(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        enablepricing: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies all original constraints from the source-SCIP and adds these to the target-SCIP; for mapping the"]
    #[doc = "  variables between the source and the target SCIP a hash map can be given; if the variable hash"]
    #[doc = "  map is NULL or necessary variable mapping is missing, the required variables are created in the"]
    #[doc = "  target-SCIP and added to the hash map, if not NULL; all variables which are created are added to"]
    #[doc = "  the target-SCIP but not (user) captured; if the constraint hash map is not NULL the mapping"]
    #[doc = "  between the constraints of the source and target-SCIP is stored"]
    #[doc = ""]
    #[doc = "  @note the constraints are added to the target-SCIP but are not (user) captured in the target SCIP. (If you mix"]
    #[doc = "        SCIPgetConsCopy() with SCIPcopyConss() you should pay attention to what you add explicitly and what is already"]
    #[doc = "        added.) You can check whether a constraint is added by calling SCIPconsIsAdded()."]
    #[doc = ""]
    #[doc = "  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex."]
    #[doc = "  @note Do not change the source SCIP environment during the copying process"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if sourcescip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if targetscip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note sourcescip stage does not get changed"]
    #[doc = ""]
    #[doc = "  @note targetscip stage does not get changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyOrigConss(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        enablepricing: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " convert all active cuts from cutpool to linear constraints"]
    #[doc = ""]
    #[doc = "  @note Do not change the source SCIP environment during the copying process"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = ""]
    #[doc = "  @note SCIP stage does not get changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPconvertCutsToConss(
        scip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        ncutsadded: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies all active cuts from cutpool of sourcescip to linear constraints in targetscip"]
    #[doc = ""]
    #[doc = "  Cuts that contain variables that are marked as relaxation-only are skipped."]
    #[doc = ""]
    #[doc = "  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex."]
    #[doc = "  @note Do not change the source SCIP environment during the copying process"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if sourcescip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if targetscip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = ""]
    #[doc = "  @note sourcescip stage does not get changed"]
    #[doc = ""]
    #[doc = "  @note targetscip stage does not get changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyCuts(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        ncutsadded: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies all active conflicts from the conflict pool of sourcescip and adds them as linear constraints to targetscip"]
    #[doc = ""]
    #[doc = "  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex."]
    #[doc = "  @note Do not change the source SCIP environment during the copying process"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if sourcescip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if targetscip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = ""]
    #[doc = "  @note sourcescip stage does not change"]
    #[doc = ""]
    #[doc = "  @note targetscip stage does not change"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyConflicts(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        enablepricing: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies implications and cliques of sourcescip to targetscip"]
    #[doc = ""]
    #[doc = "  This function should be called for a targetscip in transformed stage. It can save time in presolving of the"]
    #[doc = "  targetscip, since implications and cliques are copied."]
    #[doc = ""]
    #[doc = "  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex."]
    #[doc = "  @note Do not change the source SCIP environment during the copying process"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if sourcescip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if targetscip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note sourcescip stage does not get changed"]
    #[doc = ""]
    #[doc = "  @note targetscip stage does not get changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyImplicationsCliques(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        global: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        nbdchgs: *mut ::std::os::raw::c_int,
        ncopied: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies parameter settings from sourcescip to targetscip"]
    #[doc = ""]
    #[doc = "  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex."]
    #[doc = "  @note Do not change the source SCIP environment during the copying process"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if sourcescip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if targetscip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_FREE"]
    #[doc = ""]
    #[doc = "  @note sourcescip stage does not get changed"]
    #[doc = ""]
    #[doc = "  @note targetscip stage does not get changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyParamSettings(sourcescip: *mut SCIP, targetscip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets depth of current scip instance (increased by each copy call)"]
    #[doc = ""]
    #[doc = "  @return Depth of subscip of SCIP is returned."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  @note SCIP stage does not get changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetSubscipDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets depth of scip instance"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note SCIP stage does not get changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPsetSubscipDepth(scip: *mut SCIP, newdepth: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " copies source SCIP to target SCIP; the copying process is done in the following order:"]
    #[doc = "  1) copy the plugins"]
    #[doc = "  2) copy the settings"]
    #[doc = "  3) create problem data in target-SCIP and copy the problem data of the source-SCIP"]
    #[doc = "  4) copy all active variables except those are marked as relaxation-only"]
    #[doc = "  5) copy all constraints"]
    #[doc = ""]
    #[doc = "  The source problem depends on the stage of the \\p sourcescip - In SCIP_STAGE_PROBLEM, the original problem is copied,"]
    #[doc = "  otherwise, the transformed problem is copied. For an explicit copy of the original problem, use SCIPcopyOrig()."]
    #[doc = ""]
    #[doc = "  @note all variables and constraints which are created in the target-SCIP are not (user) captured"]
    #[doc = ""]
    #[doc = "  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex."]
    #[doc = "        Also, 'passmessagehdlr' should be set to FALSE."]
    #[doc = "  @note the 'threadsafe' parameter should only be set to TRUE if you are absolutely certain that the source and target"]
    #[doc = "        SCIP instances will be solved in parallel. The usual case is to set this to FALSE, since thread safety"]
    #[doc = "        typically incurs a performance cost."]
    #[doc = "  @note Do not change the source SCIP environment during the copying process"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if sourcescip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if targetscip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_FREE"]
    #[doc = ""]
    #[doc = "  @note sourcescip stage does not get changed"]
    #[doc = ""]
    #[doc = "  @note targetscip stage does not get changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopy(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        suffix: *const ::std::os::raw::c_char,
        global: ::std::os::raw::c_uint,
        enablepricing: ::std::os::raw::c_uint,
        threadsafe: ::std::os::raw::c_uint,
        passmessagehdlr: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies source SCIP to target SCIP but compresses constraints"]
    #[doc = ""]
    #[doc = "  constraint compression is performed by removing fixed variables immediately"]
    #[doc = "  during constraint creation if the involved constraint handlers support"]
    #[doc = "  compression"]
    #[doc = ""]
    #[doc = "  the copying process is done in the following order:"]
    #[doc = "  1) copy the plugins"]
    #[doc = "  2) copy the settings"]
    #[doc = "  3) create problem data in target-SCIP and copy the problem data of the source-SCIP"]
    #[doc = "  4) copy all active variables except those are marked as relaxation-only"]
    #[doc = "     a) fix all variable copies specified by \\p fixedvars, \\p fixedvals, and \\p nfixedvars"]
    #[doc = "     b) enable constraint compression"]
    #[doc = "  5) copy all constraints"]
    #[doc = ""]
    #[doc = " The source problem depends on the stage of the \\p sourcescip - In SCIP_STAGE_PROBLEM, the original problem is copied,"]
    #[doc = " otherwise, the transformed problem is copied. For an explicit copy of the original problem, use SCIPcopyOrigConsCompression()."]
    #[doc = ""]
    #[doc = "  @note: in case that a combination of local bounds and explicit fixing values should be used,"]
    #[doc = "         the fixing value of a variable is preferred if local bounds and fixing value disagree."]
    #[doc = ""]
    #[doc = "  @note all variables and constraints which are created in the target-SCIP are not (user) captured"]
    #[doc = ""]
    #[doc = "  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex."]
    #[doc = "        Also, 'passmessagehdlr' should be set to FALSE."]
    #[doc = "  @note the 'threadsafe' parameter should only be set to TRUE if you are absolutely certain that the source and target"]
    #[doc = "        SCIP instances will be solved in parallel. The usual case is to set this to FALSE, since thread safety"]
    #[doc = "        typically incurs a performance cost."]
    #[doc = "  @note Do not change the source SCIP environment during the copying process"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if sourcescip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if targetscip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_FREE"]
    #[doc = ""]
    #[doc = "  @note sourcescip stage does not get changed"]
    #[doc = ""]
    #[doc = "  @note targetscip stage does not get changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyConsCompression(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        suffix: *const ::std::os::raw::c_char,
        fixedvars: *mut *mut SCIP_VAR,
        fixedvals: *mut f64,
        nfixedvars: ::std::os::raw::c_int,
        global: ::std::os::raw::c_uint,
        enablepricing: ::std::os::raw::c_uint,
        threadsafe: ::std::os::raw::c_uint,
        passmessagehdlr: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies source SCIP original problem to target SCIP; the copying process is done in the following order:"]
    #[doc = "  1) copy the plugins"]
    #[doc = "  2) copy the settings"]
    #[doc = "  3) create problem data in target-SCIP and copy the original problem data of the source-SCIP"]
    #[doc = "  4) copy all original variables"]
    #[doc = "  5) copy all original constraints"]
    #[doc = ""]
    #[doc = "  @note all variables and constraints which are created in the target-SCIP are not (user) captured"]
    #[doc = ""]
    #[doc = "  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex."]
    #[doc = "        Also, 'passmessagehdlr' should be set to FALSE."]
    #[doc = "  @note the 'threadsafe' parameter should only be set to TRUE if you are absolutely certain that the source and target"]
    #[doc = "        SCIP instances will be solved in parallel. The usual case is to set this to FALSE, since thread safety"]
    #[doc = "        typically incurs a performance cost."]
    #[doc = "  @note Do not change the source SCIP environment during the copying process"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if sourcescip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if targetscip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_FREE"]
    #[doc = ""]
    #[doc = "  @note sourcescip stage does not get changed"]
    #[doc = ""]
    #[doc = "  @note targetscip stage does not get changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyOrig(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        suffix: *const ::std::os::raw::c_char,
        enablepricing: ::std::os::raw::c_uint,
        threadsafe: ::std::os::raw::c_uint,
        passmessagehdlr: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies source SCIP original problem to target SCIP but compresses constraints"]
    #[doc = ""]
    #[doc = "  constraint compression is performed by removing fixed variables immediately"]
    #[doc = "  during constraint creation if the involved constraint handlers support"]
    #[doc = "  compression"]
    #[doc = ""]
    #[doc = "  the copying process is done in the following order:"]
    #[doc = "  1) copy the plugins"]
    #[doc = "  2) copy the settings"]
    #[doc = "  3) create problem data in target-SCIP and copy the problem data of the source-SCIP"]
    #[doc = "  4) copy all original variables"]
    #[doc = "     a) fix all variable copies specified by \\p fixedvars, \\p fixedvals, and \\p nfixedvars"]
    #[doc = "     b) enable constraint compression"]
    #[doc = "  5) copy all constraints"]
    #[doc = ""]
    #[doc = "  @note all variables and constraints which are created in the target-SCIP are not (user) captured"]
    #[doc = ""]
    #[doc = "  @note In a multi thread case, you need to lock the copying procedure from outside with a mutex."]
    #[doc = "        Also, 'passmessagehdlr' should be set to FALSE."]
    #[doc = "  @note the 'threadsafe' parameter should only be set to TRUE if you are absolutely certain that the source and target"]
    #[doc = "        SCIP instances will be solved in parallel. The usual case is to set this to FALSE, since thread safety"]
    #[doc = "        typically incurs a performance cost."]
    #[doc = "  @note Do not change the source SCIP environment during the copying process"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if sourcescip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if targetscip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_FREE"]
    #[doc = ""]
    #[doc = "  @note sourcescip stage does not get changed"]
    #[doc = ""]
    #[doc = "  @note targetscip stage does not get changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyOrigConsCompression(
        sourcescip: *mut SCIP,
        targetscip: *mut SCIP,
        varmap: *mut SCIP_HASHMAP,
        consmap: *mut SCIP_HASHMAP,
        suffix: *const ::std::os::raw::c_char,
        fixedvars: *mut *mut SCIP_VAR,
        fixedvals: *mut f64,
        nfixedvars: ::std::os::raw::c_int,
        enablepricing: ::std::os::raw::c_uint,
        threadsafe: ::std::os::raw::c_uint,
        passmessagehdlr: ::std::os::raw::c_uint,
        valid: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks if there is enough time and memory left for copying the sourcescip into a sub-SCIP and solve the sub-SCIP"]
    #[doc = ""]
    #[doc = "  This is the case if the time and memory limit that would be passed to the sub-SCIP are larger than 0.0"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if sourcescip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcheckCopyLimits(
        sourcescip: *mut SCIP,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies limits from source SCIP to target SCIP"]
    #[doc = ""]
    #[doc = "  @note time and memory limit are reduced by the amount already spent in the source SCIP before installing the limit"]
    #[doc = "        in the target SCIP"]
    #[doc = "  @note all other limits are disabled and need to be enabled afterwards, if needed"]
    #[doc = ""]
    #[doc = "  @see SCIPsetCommonSubscipParams() to set further working limits and other parameters commonly used for auxiliary problems"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if sourcescip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcopyLimits(sourcescip: *mut SCIP, targetscip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the working limits as well as common search parameters for the auxiliary problem"]
    #[doc = ""]
    #[doc = "  @note memory and time limits are not affected, and must be set using SCIPcopyLimits() instead"]
    pub fn SCIPsetCommonSubscipParams(
        sourcescip: *mut SCIP,
        subscip: *mut SCIP,
        nsubnodes: ::std::os::raw::c_longlong,
        nstallnodes: ::std::os::raw::c_longlong,
        bestsollimit: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns efficacy of the cut with respect to the given primal solution or the current LP solution:"]
    #[doc = "  e = -feasibility/norm"]
    #[doc = ""]
    #[doc = "  @return the efficacy of the cut with respect to the given primal solution or the current LP solution:"]
    #[doc = "          e = -feasibility/norm"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetCutEfficacy(scip: *mut SCIP, sol: *mut SCIP_SOL, cut: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns whether the cut's efficacy with respect to the given primal solution or the current LP solution is greater"]
    #[doc = "  than the minimal cut efficacy"]
    #[doc = ""]
    #[doc = "  @return TRUE if the cut's efficacy with respect to the given primal solution or the current LP solution is greater"]
    #[doc = "          than the minimal cut efficacy, otherwise FALSE"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPisCutEfficacious(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        cut: *mut SCIP_ROW,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if the given cut's efficacy is larger than the minimal cut efficacy"]
    #[doc = ""]
    #[doc = "  @return TRUE if the given cut's efficacy is larger than the minimal cut efficacy, otherwise FALSE"]
    pub fn SCIPisEfficacious(scip: *mut SCIP, efficacy: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " calculates the efficacy norm of the given vector, which depends on the \"separating/efficacynorm\" parameter"]
    #[doc = ""]
    #[doc = "  @return the efficacy norm of the given vector, which depends on the \"separating/efficacynorm\" parameter"]
    pub fn SCIPgetVectorEfficacyNorm(
        scip: *mut SCIP,
        vals: *mut f64,
        nvals: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " indicates whether a cut is applicable"]
    #[doc = ""]
    #[doc = "  If the cut has only one variable and this method returns FALSE, it may"]
    #[doc = "  still be possible that the cut can be added to the LP (as a row instead"]
    #[doc = "  of a boundchange), but it will be a very weak cut. The user is asked"]
    #[doc = "  to avoid such cuts."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @return whether the cut is modifiable, not a bound change, or a bound change that changes bounds by at least epsilon"]
    pub fn SCIPisCutApplicable(scip: *mut SCIP, cut: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " adds cut to separation storage"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @deprecated Please use SCIPaddRow() instead, or, if the row is a global cut and it might be useful to keep it for future use,"]
    #[doc = "  consider adding it to the global cutpool with SCIPaddPoolCut()."]
    pub fn SCIPaddCut(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        cut: *mut SCIP_ROW,
        forcecut: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds row to separation storage"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddRow(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        forcecut: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks if cut is already existing in global cutpool"]
    #[doc = ""]
    #[doc = "  @return TRUE is returned if the cut is not already existing in the global cutpool, FALSE otherwise"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPisCutNew(scip: *mut SCIP, row: *mut SCIP_ROW) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " if not already existing, adds row to global cut pool"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddPoolCut(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes the row from the global cut pool"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPdelPoolCut(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets current cuts in the global cut pool"]
    #[doc = ""]
    #[doc = "  @return the current cuts in the global cut pool"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetPoolCuts(scip: *mut SCIP) -> *mut *mut SCIP_CUT;
}
extern "C" {
    #[doc = " gets current number of rows in the global cut pool"]
    #[doc = ""]
    #[doc = "  @return the current number of rows in the global cut pool"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNPoolCuts(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the global cut pool used by SCIP"]
    #[doc = ""]
    #[doc = "  @return the global cut pool used by SCIP"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetGlobalCutpool(scip: *mut SCIP) -> *mut SCIP_CUTPOOL;
}
extern "C" {
    #[doc = " creates a cut pool"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateCutpool(
        scip: *mut SCIP,
        cutpool: *mut *mut SCIP_CUTPOOL,
        agelimit: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a cut pool"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPfreeCutpool(scip: *mut SCIP, cutpool: *mut *mut SCIP_CUTPOOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " if not already existing, adds row to a cut pool and captures it"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddRowCutpool(
        scip: *mut SCIP,
        cutpool: *mut SCIP_CUTPOOL,
        row: *mut SCIP_ROW,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds row to a cut pool and captures it; doesn't check for multiple cuts"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddNewRowCutpool(
        scip: *mut SCIP,
        cutpool: *mut SCIP_CUTPOOL,
        row: *mut SCIP_ROW,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes the LP row from a cut pool"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPdelRowCutpool(
        scip: *mut SCIP,
        cutpool: *mut SCIP_CUTPOOL,
        row: *mut SCIP_ROW,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " separates cuts from a cut pool"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPseparateCutpool(
        scip: *mut SCIP,
        cutpool: *mut SCIP_CUTPOOL,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " separates cuts w.r.t. given solution from a cut pool"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPseparateSolCutpool(
        scip: *mut SCIP,
        cutpool: *mut SCIP_CUTPOOL,
        sol: *mut SCIP_SOL,
        result: *mut SCIP_RESULT,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " if not already existing, adds row to the delayed global cut pool"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is the stages \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddDelayedPoolCut(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes the row from the delayed global cut pool"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is the stages \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPdelDelayedPoolCut(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets current cuts in the delayed global cut pool"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is the stages \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetDelayedPoolCuts(scip: *mut SCIP) -> *mut *mut SCIP_CUT;
}
extern "C" {
    #[doc = " gets current number of rows in the delayed global cut pool"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is the stages \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNDelayedPoolCuts(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the delayed global cut pool used by SCIP"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is the stages \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetDelayedGlobalCutpool(scip: *mut SCIP) -> *mut SCIP_CUTPOOL;
}
extern "C" {
    #[doc = " separates the given primal solution or the current LP solution by calling the separators and constraint handlers'"]
    #[doc = "  separation methods;"]
    #[doc = "  the generated cuts are stored in the separation storage and can be accessed with the methods SCIPgetCuts() and"]
    #[doc = "  SCIPgetNCuts();"]
    #[doc = "  after evaluating the cuts, you have to call SCIPclearCuts() in order to remove the cuts from the"]
    #[doc = "  separation storage;"]
    #[doc = "  it is possible to call SCIPseparateSol() multiple times with different solutions and evaluate the found cuts"]
    #[doc = "  afterwards"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPseparateSol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        pretendroot: ::std::os::raw::c_uint,
        allowlocal: ::std::os::raw::c_uint,
        onlydelayed: ::std::os::raw::c_uint,
        delayed: *mut ::std::os::raw::c_uint,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the array of cuts currently stored in the separation storage"]
    #[doc = ""]
    #[doc = "  @return the array of cuts currently stored in the separation storage"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetCuts(scip: *mut SCIP) -> *mut *mut SCIP_ROW;
}
extern "C" {
    #[doc = " get current number of cuts in the separation storage"]
    #[doc = ""]
    #[doc = "  @return the current number of cuts in the separation storage"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNCuts(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " clears the separation storage"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPclearCuts(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes cuts that are inefficacious w.r.t. the current LP solution from separation storage without adding the cuts to the LP"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPremoveInefficaciousCuts(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a dynamic array of real values"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreateRealarray(
        scip: *mut SCIP,
        realarray: *mut *mut SCIP_REALARRAY,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a dynamic array of real values"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPfreeRealarray(scip: *mut SCIP, realarray: *mut *mut SCIP_REALARRAY) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " extends dynamic array to be able to store indices from minidx to maxidx"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPextendRealarray(
        scip: *mut SCIP,
        realarray: *mut SCIP_REALARRAY,
        minidx: ::std::os::raw::c_int,
        maxidx: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " clears a dynamic real array"]
    #[doc = ""]
    #[doc = "  @return clears a dynamic real array"]
    pub fn SCIPclearRealarray(scip: *mut SCIP, realarray: *mut SCIP_REALARRAY) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets value of entry in dynamic array"]
    pub fn SCIPgetRealarrayVal(
        scip: *mut SCIP,
        realarray: *mut SCIP_REALARRAY,
        idx: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " sets value of entry in dynamic array"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetRealarrayVal(
        scip: *mut SCIP,
        realarray: *mut SCIP_REALARRAY,
        idx: ::std::os::raw::c_int,
        val: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " increases value of entry in dynamic array"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPincRealarrayVal(
        scip: *mut SCIP,
        realarray: *mut SCIP_REALARRAY,
        idx: ::std::os::raw::c_int,
        incval: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the minimal index of all stored non-zero elements"]
    #[doc = ""]
    #[doc = "  @return the minimal index of all stored non-zero elements"]
    pub fn SCIPgetRealarrayMinIdx(
        scip: *mut SCIP,
        realarray: *mut SCIP_REALARRAY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the maximal index of all stored non-zero elements"]
    #[doc = ""]
    #[doc = "  @return the maximal index of all stored non-zero elements"]
    pub fn SCIPgetRealarrayMaxIdx(
        scip: *mut SCIP,
        realarray: *mut SCIP_REALARRAY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates a dynamic array of int values"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreateIntarray(scip: *mut SCIP, intarray: *mut *mut SCIP_INTARRAY) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a dynamic array of int values"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPfreeIntarray(scip: *mut SCIP, intarray: *mut *mut SCIP_INTARRAY) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " extends dynamic array to be able to store indices from minidx to maxidx"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPextendIntarray(
        scip: *mut SCIP,
        intarray: *mut SCIP_INTARRAY,
        minidx: ::std::os::raw::c_int,
        maxidx: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " clears a dynamic int array"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPclearIntarray(scip: *mut SCIP, intarray: *mut SCIP_INTARRAY) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets value of entry in dynamic array"]
    #[doc = ""]
    #[doc = "  @return value of entry in dynamic array"]
    pub fn SCIPgetIntarrayVal(
        scip: *mut SCIP,
        intarray: *mut SCIP_INTARRAY,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets value of entry in dynamic array"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetIntarrayVal(
        scip: *mut SCIP,
        intarray: *mut SCIP_INTARRAY,
        idx: ::std::os::raw::c_int,
        val: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " increases value of entry in dynamic array"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPincIntarrayVal(
        scip: *mut SCIP,
        intarray: *mut SCIP_INTARRAY,
        idx: ::std::os::raw::c_int,
        incval: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the minimal index of all stored non-zero elements"]
    #[doc = ""]
    #[doc = "  @return the minimal index of all stored non-zero elements"]
    pub fn SCIPgetIntarrayMinIdx(
        scip: *mut SCIP,
        intarray: *mut SCIP_INTARRAY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the maximal index of all stored non-zero elements"]
    #[doc = ""]
    #[doc = "  @return the maximal index of all stored non-zero elements"]
    pub fn SCIPgetIntarrayMaxIdx(
        scip: *mut SCIP,
        intarray: *mut SCIP_INTARRAY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates a dynamic array of bool values"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreateBoolarray(
        scip: *mut SCIP,
        boolarray: *mut *mut SCIP_BOOLARRAY,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a dynamic array of bool values"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPfreeBoolarray(scip: *mut SCIP, boolarray: *mut *mut SCIP_BOOLARRAY) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " extends dynamic array to be able to store indices from minidx to maxidx"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPextendBoolarray(
        scip: *mut SCIP,
        boolarray: *mut SCIP_BOOLARRAY,
        minidx: ::std::os::raw::c_int,
        maxidx: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " clears a dynamic bool array"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPclearBoolarray(scip: *mut SCIP, boolarray: *mut SCIP_BOOLARRAY) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets value of entry in dynamic array"]
    #[doc = ""]
    #[doc = "  @return value of entry in dynamic array at position idx"]
    pub fn SCIPgetBoolarrayVal(
        scip: *mut SCIP,
        boolarray: *mut SCIP_BOOLARRAY,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets value of entry in dynamic array"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetBoolarrayVal(
        scip: *mut SCIP,
        boolarray: *mut SCIP_BOOLARRAY,
        idx: ::std::os::raw::c_int,
        val: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the minimal index of all stored non-zero elements"]
    #[doc = ""]
    #[doc = "  @return the minimal index of all stored non-zero elements"]
    pub fn SCIPgetBoolarrayMinIdx(
        scip: *mut SCIP,
        boolarray: *mut SCIP_BOOLARRAY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the maximal index of all stored non-zero elements"]
    #[doc = ""]
    #[doc = "  @return the maximal index of all stored non-zero elements"]
    pub fn SCIPgetBoolarrayMaxIdx(
        scip: *mut SCIP,
        boolarray: *mut SCIP_BOOLARRAY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates a dynamic array of pointers"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreatePtrarray(scip: *mut SCIP, ptrarray: *mut *mut SCIP_PTRARRAY) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a dynamic array of pointers"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPfreePtrarray(scip: *mut SCIP, ptrarray: *mut *mut SCIP_PTRARRAY) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " extends dynamic array to be able to store indices from minidx to maxidx"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPextendPtrarray(
        scip: *mut SCIP,
        ptrarray: *mut SCIP_PTRARRAY,
        minidx: ::std::os::raw::c_int,
        maxidx: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " clears a dynamic pointer array"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPclearPtrarray(scip: *mut SCIP, ptrarray: *mut SCIP_PTRARRAY) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets value of entry in dynamic array"]
    pub fn SCIPgetPtrarrayVal(
        scip: *mut SCIP,
        ptrarray: *mut SCIP_PTRARRAY,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " sets value of entry in dynamic array"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetPtrarrayVal(
        scip: *mut SCIP,
        ptrarray: *mut SCIP_PTRARRAY,
        idx: ::std::os::raw::c_int,
        val: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the minimal index of all stored non-zero elements"]
    #[doc = ""]
    #[doc = "  @return the minimal index of all stored non-zero elements"]
    pub fn SCIPgetPtrarrayMinIdx(
        scip: *mut SCIP,
        ptrarray: *mut SCIP_PTRARRAY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the maximal index of all stored non-zero elements"]
    #[doc = ""]
    #[doc = "  @return the maximal index of all stored non-zero elements"]
    pub fn SCIPgetPtrarrayMaxIdx(
        scip: *mut SCIP,
        ptrarray: *mut SCIP_PTRARRAY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates a disjoint set (union find) structure \\p djset for \\p ncomponents many components (of size one)"]
    pub fn SCIPcreateDisjointset(
        scip: *mut SCIP,
        djset: *mut *mut SCIP_DISJOINTSET,
        ncomponents: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees the disjoint set (union find) data structure"]
    pub fn SCIPfreeDisjointset(scip: *mut SCIP, djset: *mut *mut SCIP_DISJOINTSET);
}
extern "C" {
    #[doc = " creates directed graph structure"]
    pub fn SCIPcreateDigraph(
        scip: *mut SCIP,
        digraph: *mut *mut SCIP_DIGRAPH,
        nnodes: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " copies directed graph structure"]
    #[doc = ""]
    #[doc = "  The copying procedure uses the memory of the passed SCIP instance. The user must ensure that the digraph lives"]
    #[doc = "  as most as long as the SCIP instance."]
    #[doc = ""]
    #[doc = "  @note The data in nodedata is copied verbatim. This possibly has to be adapted by the user."]
    pub fn SCIPcopyDigraph(
        scip: *mut SCIP,
        targetdigraph: *mut *mut SCIP_DIGRAPH,
        sourcedigraph: *mut SCIP_DIGRAPH,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enable debug solution mechanism"]
    #[doc = ""]
    #[doc = "  the debug solution mechanism allows to trace back the invalidation of"]
    #[doc = "  a debug solution during the solution process of SCIP. It must be explicitly"]
    #[doc = "  enabled for the SCIP data structure."]
    #[doc = ""]
    #[doc = "  @see debug.h for more information on debug solution mechanism"]
    pub fn SCIPenableDebugSol(scip: *mut SCIP);
}
extern "C" {
    #[doc = " disable solution debugging mechanism"]
    #[doc = ""]
    #[doc = "  @see debug.h for more information on debug solution mechanism"]
    pub fn SCIPdisableDebugSol(scip: *mut SCIP);
}
extern "C" {
    #[doc = " creates a decomposition"]
    pub fn SCIPcreateDecomp(
        scip: *mut SCIP,
        decomp: *mut *mut SCIP_DECOMP,
        nblocks: ::std::os::raw::c_int,
        original: ::std::os::raw::c_uint,
        benderslabels: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a decomposition"]
    pub fn SCIPfreeDecomp(scip: *mut SCIP, decomp: *mut *mut SCIP_DECOMP);
}
extern "C" {
    #[doc = " adds decomposition to SCIP"]
    pub fn SCIPaddDecomp(scip: *mut SCIP, decomp: *mut SCIP_DECOMP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets available user decompositions for either the original or transformed problem"]
    pub fn SCIPgetDecomps(
        scip: *mut SCIP,
        decomps: *mut *mut *mut SCIP_DECOMP,
        ndecomps: *mut ::std::os::raw::c_int,
        original: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns TRUE if the constraint \\p cons contains only linking variables in decomposition \\p decomp"]
    pub fn SCIPhasConsOnlyLinkVars(
        scip: *mut SCIP,
        decomp: *mut SCIP_DECOMP,
        cons: *mut SCIP_CONS,
        hasonlylinkvars: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " computes constraint labels from variable labels"]
    #[doc = ""]
    #[doc = "  Existing labels for the constraints are simply overridden"]
    #[doc = ""]
    #[doc = "  The computed labels depend on the flag SCIPdecompUseBendersLabels() of the decomposition. If the flag is set"]
    #[doc = "  to FALSE, the labeling assigns"]
    #[doc = ""]
    #[doc = "  - label i, if only variables labeled i are present in the constraint (and optionally linking variables)"]
    #[doc = "  - SCIP_DECOMP_LINKCONS, if there are either only variables labeled with SCIP_DECOMP_LINKVAR present, or"]
    #[doc = "    if there are variables with more than one block label."]
    #[doc = ""]
    #[doc = "  If the flag is set to TRUE, the assignment is the same, unless variables from 2 named blocks occur in the same"]
    #[doc = "  constraint, which is an invalid labeling for the Benders case."]
    pub fn SCIPcomputeDecompConsLabels(
        scip: *mut SCIP,
        decomp: *mut SCIP_DECOMP,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a decomposition of the variables from a labeling of the constraints"]
    #[doc = ""]
    #[doc = "  NOTE: by default, the variable labeling is based on a Dantzig-Wolfe decomposition. This means that constraints in named"]
    #[doc = "  blocks have have precedence over linking constraints. If a variable exists in constraints from"]
    #[doc = "  two or more named blocks, then this variable is marked as a linking variable."]
    #[doc = "  If a variable occurs in exactly one named block i>=0, it is assigned label i."]
    #[doc = "  Variables which are only in linking constraints are unlabeled. However, SCIPdecompGetVarsLabels() will"]
    #[doc = "  label them as linking variables."]
    #[doc = ""]
    #[doc = "  If the variables should be labeled for the application of Benders' decomposition, the decomposition must be"]
    #[doc = "  flagged explicitly via SCIPdecompSetUseBendersLabels()."]
    #[doc = "  With this setting, the presence in linking constraints takes precedence over the presence in named blocks."]
    #[doc = "  Now, a variable is considered linking if it is present in at least one linking constraint and an arbitrary"]
    #[doc = "  number of constraints from named blocks."]
    pub fn SCIPcomputeDecompVarsLabels(
        scip: *mut SCIP,
        decomp: *mut SCIP_DECOMP,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " assigns linking constraints to blocks"]
    #[doc = ""]
    #[doc = " Each linking constraint is assigned to the most frequent block among its variables."]
    #[doc = " Variables of other blocks are relabeled as linking variables."]
    #[doc = " Constraints that have only linking variables are skipped."]
    #[doc = ""]
    #[doc = " @note: In contrast to SCIPcomputeDecompConsLabels(), this method potentially relabels variables."]
    pub fn SCIPassignDecompLinkConss(
        scip: *mut SCIP,
        decomp: *mut SCIP_DECOMP,
        conss: *mut *mut SCIP_CONS,
        nconss: ::std::os::raw::c_int,
        nskipconss: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " computes decomposition statistics and store them in the decomposition object"]
    pub fn SCIPcomputeDecompStats(
        scip: *mut SCIP,
        decomp: *mut SCIP_DECOMP,
        uselimits: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and includes dialog"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPincludeDialog(
        scip: *mut SCIP,
        dialog: *mut *mut SCIP_DIALOG,
        dialogcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> SCIP_RETCODE,
        >,
        dialogexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                dialog: *mut SCIP_DIALOG,
                dialoghdlr: *mut SCIP_DIALOGHDLR,
                nextdialog: *mut *mut SCIP_DIALOG,
            ) -> SCIP_RETCODE,
        >,
        dialogdesc: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> SCIP_RETCODE,
        >,
        dialogfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> SCIP_RETCODE,
        >,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        issubmenu: ::std::os::raw::c_uint,
        dialogdata: *mut SCIP_DIALOGDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns if the dialog already exists"]
    #[doc = ""]
    #[doc = "  @return TRUE is returned if the dialog exists, otherwise FALSE."]
    pub fn SCIPexistsDialog(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " captures a dialog"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcaptureDialog(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " releases a dialog"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPreleaseDialog(scip: *mut SCIP, dialog: *mut *mut SCIP_DIALOG) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " makes given dialog the root dialog of SCIP's interactive user shell; captures dialog and releases former root dialog"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetRootDialog(scip: *mut SCIP, dialog: *mut SCIP_DIALOG) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the root dialog of SCIP's interactive user shell"]
    #[doc = ""]
    #[doc = "  @return the root dialog of SCIP's interactive user shell is returned."]
    pub fn SCIPgetRootDialog(scip: *mut SCIP) -> *mut SCIP_DIALOG;
}
extern "C" {
    #[doc = " adds a sub dialog to the given dialog as menu entry and captures it"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddDialogEntry(
        scip: *mut SCIP,
        dialog: *mut SCIP_DIALOG,
        subdialog: *mut SCIP_DIALOG,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a single line of input which is treated as if the user entered the command line"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddDialogInputLine(
        scip: *mut SCIP,
        inputline: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a single line of input to the command history which can be accessed with the cursor keys"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddDialogHistoryLine(
        scip: *mut SCIP,
        inputline: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " starts interactive mode of SCIP by executing the root dialog"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_FREE"]
    #[doc = ""]
    #[doc = "  @post After calling this method \\SCIP reaches one of the following stages depending on if and when the"]
    #[doc = "        interactive shell was closed:"]
    #[doc = "        - \\ref SCIP_STAGE_PROBLEM if the interactive shell was closed after the problem was created"]
    #[doc = "        - \\ref SCIP_STAGE_TRANSFORMED if the interactive shell was closed after the problem was transformed"]
    #[doc = "        - \\ref SCIP_STAGE_PRESOLVING if the interactive shell was closed  during presolving"]
    #[doc = "        - \\ref SCIP_STAGE_PRESOLVED if the interactive shell was closed after presolve"]
    #[doc = "        - \\ref SCIP_STAGE_SOLVING if the interactive shell was closed during the tree search"]
    #[doc = "        - \\ref SCIP_STAGE_SOLVED if the interactive shell was closed after the problem was solved"]
    #[doc = "        - \\ref SCIP_STAGE_FREE if the interactive shell was closed after the problem was freed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPstartInteraction(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a display column and includes it in SCIP"]
    pub fn SCIPincludeDisp(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        header: *const ::std::os::raw::c_char,
        dispstatus: SCIP_DISPSTATUS,
        dispcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, disp: *mut SCIP_DISP) -> SCIP_RETCODE,
        >,
        dispfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, disp: *mut SCIP_DISP) -> SCIP_RETCODE,
        >,
        dispinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, disp: *mut SCIP_DISP) -> SCIP_RETCODE,
        >,
        dispexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, disp: *mut SCIP_DISP) -> SCIP_RETCODE,
        >,
        dispinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, disp: *mut SCIP_DISP) -> SCIP_RETCODE,
        >,
        dispexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, disp: *mut SCIP_DISP) -> SCIP_RETCODE,
        >,
        dispoutput: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                disp: *mut SCIP_DISP,
                file: *mut FILE,
            ) -> SCIP_RETCODE,
        >,
        dispdata: *mut SCIP_DISPDATA,
        width: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_int,
        position: ::std::os::raw::c_int,
        stripline: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the display column of the given name, or NULL if not existing"]
    pub fn SCIPfindDisp(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_DISP;
}
extern "C" {
    #[doc = " returns the array of currently available display columns"]
    pub fn SCIPgetDisps(scip: *mut SCIP) -> *mut *mut SCIP_DISP;
}
extern "C" {
    #[doc = " returns the number of currently available display columns"]
    pub fn SCIPgetNDisps(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " automatically selects display columns for being shown w.r.t. the display width parameter"]
    pub fn SCIPautoselectDisps(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the display column mode"]
    pub fn SCIPchgDispMode(disp: *mut SCIP_DISP, mode: SCIP_DISPMODE);
}
extern "C" {
    #[doc = " creates an event handler and includes it in SCIP"]
    #[doc = ""]
    #[doc = "  @note method has all event handler callbacks as arguments and is thus changed every time a new"]
    #[doc = "        callback is added in future releases; consider using SCIPincludeEventhdlrBasic() and setter functions"]
    #[doc = "        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeEventhdlr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        eventcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
        eventfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
        eventinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
        eventexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
        eventinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
        eventexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
        eventdelete: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                eventhdlr: *mut SCIP_EVENTHDLR,
                eventdata: *mut *mut SCIP_EVENTDATA,
            ) -> SCIP_RETCODE,
        >,
        eventexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                eventhdlr: *mut SCIP_EVENTHDLR,
                event: *mut SCIP_EVENT,
                eventdata: *mut SCIP_EVENTDATA,
            ) -> SCIP_RETCODE,
        >,
        eventhdlrdata: *mut SCIP_EVENTHDLRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates an event handler and includes it in SCIP with all its non-fundamental callbacks set"]
    #[doc = "  to NULL; if needed, non-fundamental callbacks can be set afterwards via setter functions"]
    #[doc = "  SCIPsetEventhdlrCopy(), SCIPsetEventhdlrFree(), SCIPsetEventhdlrInit(), SCIPsetEventhdlrExit(),"]
    #[doc = "  SCIPsetEventhdlrInitsol(), SCIPsetEventhdlrExitsol(), and SCIPsetEventhdlrDelete()"]
    #[doc = ""]
    #[doc = "  @note if you want to set all callbacks with a single method call, consider using SCIPincludeEventhdlr() instead"]
    pub fn SCIPincludeEventhdlrBasic(
        scip: *mut SCIP,
        eventhdlrptr: *mut *mut SCIP_EVENTHDLR,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        eventexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                eventhdlr: *mut SCIP_EVENTHDLR,
                event: *mut SCIP_EVENT,
                eventdata: *mut SCIP_EVENTDATA,
            ) -> SCIP_RETCODE,
        >,
        eventhdlrdata: *mut SCIP_EVENTHDLRDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy callback of the event handler"]
    pub fn SCIPsetEventhdlrCopy(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization callback of the event handler"]
    pub fn SCIPsetEventhdlrFree(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization callback of the event handler"]
    pub fn SCIPsetEventhdlrInit(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization callback of the event handler"]
    pub fn SCIPsetEventhdlrExit(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization callback of the event handler"]
    pub fn SCIPsetEventhdlrInitsol(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization callback of the event handler"]
    pub fn SCIPsetEventhdlrExitsol(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, eventhdlr: *mut SCIP_EVENTHDLR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets callback of the event handler to free specific event data"]
    pub fn SCIPsetEventhdlrDelete(
        scip: *mut SCIP,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdelete: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                eventhdlr: *mut SCIP_EVENTHDLR,
                eventdata: *mut *mut SCIP_EVENTDATA,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the event handler of the given name, or NULL if not existing"]
    pub fn SCIPfindEventhdlr(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_EVENTHDLR;
}
extern "C" {
    #[doc = " returns the array of currently available event handlers"]
    pub fn SCIPgetEventhdlrs(scip: *mut SCIP) -> *mut *mut SCIP_EVENTHDLR;
}
extern "C" {
    #[doc = " returns the number of currently available event handlers"]
    pub fn SCIPgetNEventhdlrs(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " catches a global (not variable or row dependent) event"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPcatchEvent(
        scip: *mut SCIP,
        eventtype: SCIP_EVENTTYPE,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdata: *mut SCIP_EVENTDATA,
        filterpos: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " drops a global event (stops to track event)"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPdropEvent(
        scip: *mut SCIP,
        eventtype: SCIP_EVENTTYPE,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdata: *mut SCIP_EVENTDATA,
        filterpos: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " catches an objective value or domain change event on the given transformed variable"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPcatchVarEvent(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        eventtype: SCIP_EVENTTYPE,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdata: *mut SCIP_EVENTDATA,
        filterpos: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " drops an objective value or domain change event (stops to track event) on the given transformed variable"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPdropVarEvent(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        eventtype: SCIP_EVENTTYPE,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdata: *mut SCIP_EVENTDATA,
        filterpos: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " catches a row coefficient, constant, or side change event on the given row"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPcatchRowEvent(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        eventtype: SCIP_EVENTTYPE,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdata: *mut SCIP_EVENTDATA,
        filterpos: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " drops a row coefficient, constant, or side change event (stops to track event) on the given row"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPdropRowEvent(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        eventtype: SCIP_EVENTTYPE,
        eventhdlr: *mut SCIP_EVENTHDLR,
        eventdata: *mut SCIP_EVENTDATA,
        filterpos: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " replaces array of variables in expression tree by corresponding transformed variables"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetExprtreeTransformedVars(
        scip: *mut SCIP,
        tree: *mut SCIP_EXPRTREE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " evaluates an expression tree for a primal solution or LP solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPevalExprtreeSol(
        scip: *mut SCIP,
        tree: *mut SCIP_EXPRTREE,
        sol: *mut SCIP_SOL,
        val: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " evaluates an expression tree w.r.t. current global bounds"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPevalExprtreeGlobalBounds(
        scip: *mut SCIP,
        tree: *mut SCIP_EXPRTREE,
        infinity: f64,
        val: *mut SCIP_INTERVAL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " evaluates an expression tree w.r.t. current local bounds"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPevalExprtreeLocalBounds(
        scip: *mut SCIP,
        tree: *mut SCIP_EXPRTREE,
        infinity: f64,
        val: *mut SCIP_INTERVAL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns complete SCIP version number in the format \"major . minor tech\""]
    #[doc = ""]
    #[doc = "  @return complete SCIP version"]
    pub fn SCIPversion() -> f64;
}
extern "C" {
    #[doc = " returns SCIP major version"]
    #[doc = ""]
    #[doc = "  @return major SCIP version"]
    pub fn SCIPmajorVersion() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns SCIP minor version"]
    #[doc = ""]
    #[doc = "  @return minor SCIP version"]
    pub fn SCIPminorVersion() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns SCIP technical version"]
    #[doc = ""]
    #[doc = "  @return technical SCIP version"]
    pub fn SCIPtechVersion() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns SCIP sub version number"]
    #[doc = ""]
    #[doc = "  @return subversion SCIP version"]
    pub fn SCIPsubversion() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " prints a version information line to a file stream via the message handler system"]
    #[doc = ""]
    #[doc = "  @note If the message handler is set to a NULL pointer nothing will be printed"]
    pub fn SCIPprintVersion(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " prints detailed information on the compile-time flags"]
    #[doc = ""]
    #[doc = "  @note If the message handler is set to a NULL pointer nothing will be printed"]
    pub fn SCIPprintBuildOptions(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " prints error message for the given SCIP_RETCODE via the error prints method"]
    pub fn SCIPprintError(retcode: SCIP_RETCODE);
}
#[link(name = "libscip")]
extern "C" {
    #[doc = " creates and initializes SCIP data structures"]
    #[doc = ""]
    #[doc = "  @note The SCIP default message handler is installed. Use the method SCIPsetMessagehdlr() to install your own"]
    #[doc = "        message handler or SCIPsetMessagehdlrLogfile() and SCIPsetMessagehdlrQuiet() to write into a log"]
    #[doc = "        file and turn off/on the display output, respectively."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @post After calling this method @p scip reached the solving stage \\ref SCIP_STAGE_INIT"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcreate(scip: *mut *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees SCIP data structures"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_FREE"]
    #[doc = ""]
    #[doc = "  @post After calling this method \\SCIP reached the solving stage \\ref SCIP_STAGE_FREE"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPfree(scip: *mut *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns current stage of SCIP"]
    #[doc = ""]
    #[doc = "  @return the current SCIP stage"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetStage(scip: *mut SCIP) -> SCIP_STAGE;
}
extern "C" {
    #[doc = " outputs SCIP stage and solution status if applicable via the message handler"]
    #[doc = ""]
    #[doc = "  @note If the message handler is set to a NULL pointer nothing will be printed"]
    #[doc = ""]
    #[doc = "  @note If limits have been changed between the solution and the call to this function, the status is recomputed and"]
    #[doc = "        thus may to correspond to the original status."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPprintStage(scip: *mut SCIP, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets solution status"]
    #[doc = ""]
    #[doc = "  @return SCIP solution status"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Status \"SCIP_STATUS\" for a complete list of all possible solving status."]
    pub fn SCIPgetStatus(scip: *mut SCIP) -> SCIP_STATUS;
}
extern "C" {
    #[doc = " outputs solution status"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Status \"SCIP_STATUS\" for a complete list of all possible solving status."]
    pub fn SCIPprintStatus(scip: *mut SCIP, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether the current stage belongs to the transformed problem space"]
    #[doc = ""]
    #[doc = "  @return Returns TRUE if the \\SCIP instance is transformed, otherwise FALSE"]
    pub fn SCIPisTransformed(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the solution process is arithmetically exact, i.e., not subject to roundoff errors"]
    #[doc = ""]
    #[doc = "  @note This feature is not supported yet!"]
    #[doc = ""]
    #[doc = "  @return Returns TRUE if \\SCIP is exact solving mode, otherwise FALSE"]
    pub fn SCIPisExactSolve(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the presolving process would be finished given no more presolving reductions are found in this"]
    #[doc = "  presolving round"]
    #[doc = ""]
    #[doc = "  Checks whether the number of presolving rounds is not exceeded and the presolving reductions found in the current"]
    #[doc = "  presolving round suffice to trigger another presolving round."]
    #[doc = ""]
    #[doc = "  @note if subsequent presolvers find more reductions, presolving might continue even if the method returns FALSE"]
    #[doc = "  @note does not check whether infeasibility or unboundedness was already detected in presolving (which would result"]
    #[doc = "        in presolving being stopped although the method returns TRUE)"]
    #[doc = ""]
    #[doc = "  @return Returns TRUE if presolving is finished if no further reductions are detected"]
    pub fn SCIPisPresolveFinished(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether SCIP has performed presolving during the last solve"]
    #[doc = ""]
    #[doc = "  @return Returns TRUE if presolving was performed during the last solve"]
    pub fn SCIPhasPerformedPresolve(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the user pressed CTRL-C to interrupt the solving process"]
    #[doc = ""]
    #[doc = "  @return Returns TRUE if Ctrl-C was pressed, otherwise FALSE."]
    pub fn SCIPpressedCtrlC(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the solving process should be / was stopped before proving optimality;"]
    #[doc = "  if the solving process should be / was stopped, the status returned by SCIPgetStatus() yields"]
    #[doc = "  the reason for the premature abort"]
    #[doc = ""]
    #[doc = "  @return Returns TRUE if solving process is stopped/interrupted, otherwise FALSE."]
    pub fn SCIPisStopped(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " includes information about an external code linked into the SCIP library"]
    pub fn SCIPincludeExternalCodeInformation(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns an array of names of currently included external codes"]
    pub fn SCIPgetExternalCodeNames(scip: *mut SCIP) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns an array of the descriptions of currently included external codes"]
    #[doc = ""]
    #[doc = "  @note some descriptions may be NULL"]
    pub fn SCIPgetExternalCodeDescriptions(scip: *mut SCIP) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " returns the number of currently included information on external codes"]
    pub fn SCIPgetNExternalCodes(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " prints information on external codes to a file stream via the message handler system"]
    #[doc = ""]
    #[doc = "  @note If the message handler is set to a NULL pointer nothing will be printed"]
    pub fn SCIPprintExternalCodes(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " creates a primal heuristic and includes it in SCIP."]
    #[doc = ""]
    #[doc = "  @note method has all heuristic callbacks as arguments and is thus changed every time a new"]
    #[doc = "        callback is added in future releases; consider using SCIPincludeHeurBasic() and setter functions"]
    #[doc = "        if you seek for a method which is less likely to change in future releases"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPincludeHeur(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        dispchar: ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        freqofs: ::std::os::raw::c_int,
        maxdepth: ::std::os::raw::c_int,
        timingmask: SCIP_HEURTIMING,
        usessubscip: ::std::os::raw::c_uint,
        heurcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
        heurfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
        heurinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
        heurexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
        heurinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
        heurexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
        heurexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                heur: *mut SCIP_HEUR,
                heurtiming: SCIP_HEURTIMING,
                nodeinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        heurdata: *mut SCIP_HEURDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a primal heuristic and includes it in SCIP with its most fundamental callbacks."]
    #[doc = "  All non-fundamental (or optional) callbacks"]
    #[doc = "  as, e. g., init and exit callbacks, will be set to NULL."]
    #[doc = "  Optional callbacks can be set via specific setter functions, see SCIPsetHeurCopy(), SCIPsetHeurFree(),"]
    #[doc = "  SCIPsetHeurInit(), SCIPsetHeurExit(), SCIPsetHeurInitsol(), and SCIPsetHeurExitsol()"]
    #[doc = ""]
    #[doc = "  @note if you want to set all callbacks with a single method call, consider using SCIPincludeHeur() instead"]
    pub fn SCIPincludeHeurBasic(
        scip: *mut SCIP,
        heur: *mut *mut SCIP_HEUR,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        dispchar: ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        freqofs: ::std::os::raw::c_int,
        maxdepth: ::std::os::raw::c_int,
        timingmask: SCIP_HEURTIMING,
        usessubscip: ::std::os::raw::c_uint,
        heurexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                heur: *mut SCIP_HEUR,
                heurtiming: SCIP_HEURTIMING,
                nodeinfeasible: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        heurdata: *mut SCIP_HEURDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of primal heuristic"]
    pub fn SCIPsetHeurCopy(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        heurcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of primal heuristic"]
    pub fn SCIPsetHeurFree(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        heurfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of primal heuristic"]
    pub fn SCIPsetHeurInit(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        heurinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of primal heuristic"]
    pub fn SCIPsetHeurExit(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        heurexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of primal heuristic"]
    pub fn SCIPsetHeurInitsol(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        heurinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of primal heuristic"]
    pub fn SCIPsetHeurExitsol(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        heurexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, heur: *mut SCIP_HEUR) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the primal heuristic of the given name, or NULL if not existing"]
    pub fn SCIPfindHeur(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_HEUR;
}
extern "C" {
    #[doc = " returns the array of currently available primal heuristics"]
    pub fn SCIPgetHeurs(scip: *mut SCIP) -> *mut *mut SCIP_HEUR;
}
extern "C" {
    #[doc = " returns the number of currently available primal heuristics"]
    pub fn SCIPgetNHeurs(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a primal heuristic"]
    pub fn SCIPsetHeurPriority(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " create a diving set associated with a primal heuristic. The primal heuristic needs to be included"]
    #[doc = "  before this method can be called. The diveset is installed in the array of divesets of the heuristic"]
    #[doc = "  and can be retrieved later by accessing SCIPheurGetDivesets()"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPcreateDiveset(
        scip: *mut SCIP,
        diveset: *mut *mut SCIP_DIVESET,
        heur: *mut SCIP_HEUR,
        name: *const ::std::os::raw::c_char,
        minreldepth: f64,
        maxreldepth: f64,
        maxlpiterquot: f64,
        maxdiveubquot: f64,
        maxdiveavgquot: f64,
        maxdiveubquotnosol: f64,
        maxdiveavgquotnosol: f64,
        lpresolvedomchgquot: f64,
        lpsolvefreq: ::std::os::raw::c_int,
        maxlpiterofs: ::std::os::raw::c_int,
        initialseed: ::std::os::raw::c_uint,
        backtrack: ::std::os::raw::c_uint,
        onlylpbranchcands: ::std::os::raw::c_uint,
        ispublic: ::std::os::raw::c_uint,
        specificsos1score: ::std::os::raw::c_uint,
        divesetgetscore: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                diveset: *mut SCIP_DIVESET,
                divetype: SCIP_DIVETYPE,
                cand: *mut SCIP_VAR,
                candsol: f64,
                candsfrac: f64,
                score: *mut f64,
                roundup: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        divesetavailable: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                diveset: *mut SCIP_DIVESET,
                available: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " check specific preconditions for diving, e.g., if an incumbent solution is available"]
    pub fn SCIPisDivesetAvailable(
        scip: *mut SCIP,
        diveset: *mut SCIP_DIVESET,
        available: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns, whether the LP was or is to be solved in the current node"]
    #[doc = ""]
    #[doc = "  @return whether the LP was or is to be solved in the current node."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPhasCurrentNodeLP(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns, whether the LP of the current node is already constructed"]
    #[doc = ""]
    #[doc = "  @return whether the LP of the current node is already constructed."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisLPConstructed(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " makes sure that the LP of the current node is loaded and may be accessed through the LP information methods"]
    #[doc = ""]
    #[doc = "  @warning Contructing the LP might change the amount of variables known in the transformed problem and therefore also"]
    #[doc = "           the variables array of SCIP (returned by SCIPgetVars() and SCIPgetVarsData()), so it might be necessary to"]
    #[doc = "           call one of the later method after this one"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPconstructLP(scip: *mut SCIP, cutoff: *mut ::std::os::raw::c_uint) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " makes sure that the LP of the current node is flushed"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPflushLP(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets solution status of current LP"]
    #[doc = ""]
    #[doc = "  @return the solution status of current LP."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPSolstat(scip: *mut SCIP) -> SCIP_LPSOLSTAT;
}
extern "C" {
    #[doc = " returns whether the current LP solution passed the primal feasibility check"]
    #[doc = ""]
    #[doc = "  @returns whether the current LP solution passed the primal feasibility check."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisLPPrimalReliable(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the current LP solution passed the dual feasibility check"]
    #[doc = ""]
    #[doc = "  @returns whether the current LP solution passed the dual feasibility check."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisLPDualReliable(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the current lp is a relaxation of the current problem and its optimal objective value is a local lower bound"]
    #[doc = ""]
    #[doc = "  @return whether the current lp is a relaxation of the current problem and its optimal objective value is a local lower bound."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisLPRelax(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets objective value of current LP (which is the sum of column and loose objective value)"]
    #[doc = ""]
    #[doc = "  @return the objective value of current LP (which is the sum of column and loose objective value)."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note This method returns the objective value of the current LP solution, which might be primal or dual infeasible"]
    #[doc = "        if a limit was hit during solving. It must not be used as a dual bound if the LP solution status returned by"]
    #[doc = "        SCIPgetLPSolstat() is SCIP_LPSOLSTAT_ITERLIMIT or SCIP_LPSOLSTAT_TIMELIMIT."]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPObjval(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets part of objective value of current LP that results from COLUMN variables only"]
    #[doc = ""]
    #[doc = "  @return the part of objective value of current LP that results from COLUMN variables only."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPColumnObjval(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets part of objective value of current LP that results from LOOSE variables only"]
    #[doc = ""]
    #[doc = "  @return part of objective value of current LP that results from LOOSE variables only."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPLooseObjval(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the global pseudo objective value; that is all variables set to their best  (w.r.t. the objective"]
    #[doc = "  function) global bound"]
    #[doc = ""]
    #[doc = "  @return the global pseudo objective value; that is all variables set to their best  (w.r.t. the objective"]
    #[doc = "  function) global bound."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetGlobalPseudoObjval(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the pseudo objective value for the current search node; that is all variables set to their best (w.r.t. the"]
    #[doc = "  objective function) local bound"]
    #[doc = ""]
    #[doc = "  @return the pseudo objective value for the current search node; that is all variables set to their best (w.r.t. the"]
    #[doc = "  objective function) local bound."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetPseudoObjval(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns whether the root lp is a relaxation of the problem and its optimal objective value is a global lower bound"]
    #[doc = ""]
    #[doc = "  @return whether the root lp is a relaxation of the problem and its optimal objective value is a global lower bound."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisRootLPRelax(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets the objective value of the root node LP or SCIP_INVALID if the root node LP was not (yet) solved"]
    #[doc = ""]
    #[doc = "  @return the objective value of the root node LP or SCIP_INVALID if the root node LP was not (yet) solved."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPRootObjval(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets part of the objective value of the root node LP that results from COLUMN variables only;"]
    #[doc = "  returns SCIP_INVALID if the root node LP was not (yet) solved"]
    #[doc = ""]
    #[doc = "  @return the part of the objective value of the root node LP that results from COLUMN variables only;"]
    #[doc = "  or SCIP_INVALID if the root node LP was not (yet) solved."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPRootColumnObjval(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets part of the objective value of the root node LP that results from LOOSE variables only;"]
    #[doc = "  returns SCIP_INVALID if the root node LP was not (yet) solved"]
    #[doc = ""]
    #[doc = "  @return the part of the objective value of the root node LP that results from LOOSE variables only;"]
    #[doc = "  or SCIP_INVALID if the root node LP was not (yet) solved."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPRootLooseObjval(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets current primal feasibility tolerance of LP"]
    pub fn SCIPgetLPFeastol(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " sets primal feasibility tolerance of LP"]
    pub fn SCIPsetLPFeastol(scip: *mut SCIP, newfeastol: f64);
}
extern "C" {
    #[doc = " resets primal feasibility tolerance of LP"]
    #[doc = ""]
    #[doc = " Sets primal feasibility tolerance to min of numerics/lpfeastolfactor * numerics/feastol and relaxfeastol."]
    pub fn SCIPresetLPFeastol(scip: *mut SCIP);
}
extern "C" {
    #[doc = " gets current LP columns along with the current number of LP columns"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPColsData(
        scip: *mut SCIP,
        cols: *mut *mut *mut SCIP_COL,
        ncols: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets current LP columns"]
    #[doc = ""]
    #[doc = "  @return the current LP columns."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPCols(scip: *mut SCIP) -> *mut *mut SCIP_COL;
}
extern "C" {
    #[doc = " gets current number of LP columns"]
    #[doc = ""]
    #[doc = "  @return the current number of LP columns."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNLPCols(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets current LP rows along with the current number of LP rows"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPRowsData(
        scip: *mut SCIP,
        rows: *mut *mut *mut SCIP_ROW,
        nrows: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets current LP rows"]
    #[doc = ""]
    #[doc = "  @return the current LP rows."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPRows(scip: *mut SCIP) -> *mut *mut SCIP_ROW;
}
extern "C" {
    #[doc = " gets current number of LP rows"]
    #[doc = ""]
    #[doc = "  @return the current number of LP rows."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetNLPRows(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns TRUE iff all columns, i.e. every variable with non-empty column w.r.t. all ever created rows, are present"]
    #[doc = "  in the LP, and FALSE, if there are additional already existing columns, that may be added to the LP in pricing"]
    #[doc = ""]
    #[doc = "  @return TRUE iff all columns, i.e. every variable with non-empty column w.r.t. all ever created rows, are present"]
    #[doc = "  in the LP, and FALSE, if there are additional already existing columns, that may be added to the LP in pricing."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPallColsInLP(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the current LP solution is basic, i.e. is defined by a valid simplex basis"]
    #[doc = ""]
    #[doc = "  @return whether the current LP solution is basic, i.e. is defined by a valid simplex basis."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPisLPSolBasic(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets all indices of basic columns and rows: index i >= 0 corresponds to column i, index i < 0 to row -i-1"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPBasisInd(scip: *mut SCIP, basisind: *mut ::std::os::raw::c_int)
        -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets a row from the inverse basis matrix B^-1"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPBInvRow(
        scip: *mut SCIP,
        r: ::std::os::raw::c_int,
        coefs: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets a column from the inverse basis matrix B^-1"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPBInvCol(
        scip: *mut SCIP,
        c: ::std::os::raw::c_int,
        coefs: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets a row from the product of inverse basis matrix B^-1 and coefficient matrix A (i.e. from B^-1 * A)"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPBInvARow(
        scip: *mut SCIP,
        r: ::std::os::raw::c_int,
        binvrow: *mut f64,
        coefs: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets a column from the product of inverse basis matrix B^-1 and coefficient matrix A (i.e. from B^-1 * A),"]
    #[doc = "  i.e., it computes B^-1 * A_c with A_c being the c'th column of A"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPBInvACol(
        scip: *mut SCIP,
        c: ::std::os::raw::c_int,
        coefs: *mut f64,
        inds: *mut ::std::os::raw::c_int,
        ninds: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calculates a weighted sum of all LP rows; for negative weights, the left and right hand side of the corresponding"]
    #[doc = "  LP row are swapped in the summation"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPsumLPRows(
        scip: *mut SCIP,
        weights: *mut f64,
        sumcoef: *mut SCIP_REALARRAY,
        sumlhs: *mut f64,
        sumrhs: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes current LP to a file"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPwriteLP(scip: *mut SCIP, filename: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes MIP relaxation of the current branch-and-bound node to a file"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPwriteMIP(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        genericnames: ::std::os::raw::c_uint,
        origobj: ::std::os::raw::c_uint,
        lazyconss: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the LP interface of SCIP;"]
    #[doc = "  with the LPI you can use all of the methods defined in lpi/lpi.h;"]
    #[doc = ""]
    #[doc = "  @warning You have to make sure, that the full internal state of the LPI does not change or is recovered completely"]
    #[doc = "           after the end of the method that uses the LPI. In particular, if you manipulate the LP or its solution"]
    #[doc = "           (e.g. by calling one of the SCIPlpiAdd...() or one of the SCIPlpiSolve...() methods), you have to check in"]
    #[doc = "           advance with SCIPlpiWasSolved() whether the LP is currently solved. If this is the case, you have to make"]
    #[doc = "           sure, the internal solution status is recovered completely at the end of your method. This can be achieved"]
    #[doc = "           by getting the LPI state before applying any LPI manipulations with SCIPlpiGetState() and restoring it"]
    #[doc = "           afterwards with SCIPlpiSetState() and SCIPlpiFreeState(). Additionally you have to resolve the LP with the"]
    #[doc = "           appropriate SCIPlpiSolve...() call in order to reinstall the internal solution status."]
    #[doc = ""]
    #[doc = "  @warning Make also sure, that all parameter values that you have changed are set back to their original values."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLPI(scip: *mut SCIP, lpi: *mut *mut SCIP_LPI) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Displays quality information about the current LP solution. An LP solution need to be available. Information printed"]
    #[doc = "  is subject to what the LP solver supports"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_FREE"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    #[doc = ""]
    #[doc = "  @note The printing process is done via the message handler system."]
    pub fn SCIPprintLPSolutionQuality(scip: *mut SCIP, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " compute relative interior point to current LP"]
    #[doc = "  @see SCIPlpComputeRelIntPoint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPcomputeLPRelIntPoint(
        scip: *mut SCIP,
        relaxrows: ::std::os::raw::c_uint,
        inclobjcutoff: ::std::os::raw::c_uint,
        timelimit: f64,
        iterlimit: ::std::os::raw::c_int,
        point: *mut *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the reduced costs of a column in the last (feasible) LP"]
    #[doc = ""]
    #[doc = "  @return the reduced costs of a column in the last (feasible) LP"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @note calling this method in SCIP_STAGE_SOLVED is only recommended to experienced users and should only be called"]
    #[doc = "        for pure LP instances (without presolving)"]
    #[doc = ""]
    #[doc = "  @note The return value of this method should be used carefully if the dual feasibility check was explictely disabled."]
    pub fn SCIPgetColRedcost(scip: *mut SCIP, col: *mut SCIP_COL) -> f64;
}
extern "C" {
    #[doc = " returns the Farkas coefficient of a column in the last (infeasible) LP"]
    #[doc = ""]
    #[doc = "  @return the Farkas coefficient of a column in the last (infeasible) LP"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetColFarkasCoef(scip: *mut SCIP, col: *mut SCIP_COL) -> f64;
}
extern "C" {
    #[doc = " marks a column to be not removable from the LP in the current node"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in the following stage of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPmarkColNotRemovableLocal(scip: *mut SCIP, col: *mut SCIP_COL);
}
extern "C" {
    #[doc = " creates and captures an LP row from a constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateRowConshdlr(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        conshdlr: *mut SCIP_CONSHDLR,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        cols: *mut *mut SCIP_COL,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an LP row from a constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateRowCons(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        cons: *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        cols: *mut *mut SCIP_COL,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an LP row from a separator"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateRowSepa(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        sepa: *mut SCIP_SEPA,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        cols: *mut *mut SCIP_COL,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an LP row from an unspecified source"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateRowUnspec(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        cols: *mut *mut SCIP_COL,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an LP row"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @deprecated Please use SCIPcreateRowConshdlr() or SCIPcreateRowSepa() when calling from a constraint handler or separator in order"]
    #[doc = "              to facilitate correct statistics. If the call is from neither a constraint handler or separator, use SCIPcreateRowUnspec()."]
    pub fn SCIPcreateRow(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        cols: *mut *mut SCIP_COL,
        vals: *mut f64,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an LP row without any coefficients from a constraint handler"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateEmptyRowConshdlr(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        conshdlr: *mut SCIP_CONSHDLR,
        name: *const ::std::os::raw::c_char,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an LP row without any coefficients from a constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateEmptyRowCons(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        cons: *mut SCIP_CONS,
        name: *const ::std::os::raw::c_char,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an LP row without any coefficients from a separator"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateEmptyRowSepa(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        sepa: *mut SCIP_SEPA,
        name: *const ::std::os::raw::c_char,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an LP row without any coefficients from an unspecified source"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateEmptyRowUnspec(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        name: *const ::std::os::raw::c_char,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an LP row without any coefficients"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @deprecated Please use SCIPcreateEmptyRowConshdlr() or SCIPcreateEmptyRowSepa() when calling from a constraint handler or separator in order"]
    #[doc = "              to facilitate correct statistics. If the call is from neither a constraint handler or separator, use SCIPcreateEmptyRowUnspec()."]
    pub fn SCIPcreateEmptyRow(
        scip: *mut SCIP,
        row: *mut *mut SCIP_ROW,
        name: *const ::std::os::raw::c_char,
        lhs: f64,
        rhs: f64,
        local: ::std::os::raw::c_uint,
        modifiable: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " increases usage counter of LP row"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcaptureRow(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " decreases usage counter of LP row, and frees memory if necessary"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPreleaseRow(scip: *mut SCIP, row: *mut *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes left hand side of LP row"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgRowLhs(scip: *mut SCIP, row: *mut SCIP_ROW, lhs: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes right hand side of LP row"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgRowRhs(scip: *mut SCIP, row: *mut SCIP_ROW, rhs: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " informs row, that all subsequent additions of variables to the row should be cached and not directly applied;"]
    #[doc = "  after all additions were applied, SCIPflushRowExtensions() must be called;"]
    #[doc = "  while the caching of row extensions is activated, information methods of the row give invalid results;"]
    #[doc = "  caching should be used, if a row is build with SCIPaddVarToRow() calls variable by variable to increase"]
    #[doc = "  the performance"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcacheRowExtensions(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " flushes all cached row extensions after a call of SCIPcacheRowExtensions() and merges coefficients with"]
    #[doc = "  equal columns into a single coefficient"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPflushRowExtensions(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " resolves variable to columns and adds them with the coefficient to the row"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @attention If the absolute value of val is below the SCIP epsilon tolerance, the variable will not added."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note In case calling this method in the enforcement process of an lp solution, it might be that some variables,"]
    #[doc = "        that were not yet in the LP (e.g. dynamic columns) will change their lp solution value returned by SCIP."]
    #[doc = "        For example, a variable, which has a negative objective value, that has no column in the lp yet, is in the lp solution"]
    #[doc = "        on its upper bound (variables with status SCIP_VARSTATUS_LOOSE are in an lp solution on it's best bound), but"]
    #[doc = "        creating the column, changes the solution value (variable than has status SCIP_VARSTATUS_COLUMN, and the"]
    #[doc = "        initialization sets the lp solution value) to 0.0. (This leads to the conclusion that, if a constraint was"]
    #[doc = "        violated, the linear relaxation might not be violated anymore.)"]
    pub fn SCIPaddVarToRow(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " resolves variables to columns and adds them with the coefficients to the row;"]
    #[doc = "  this method caches the row extensions and flushes them afterwards to gain better performance"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @attention If a coefficients absolute value is below the SCIP epsilon tolerance, the variable with its value is not added."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarsToRow(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " resolves variables to columns and adds them with the same single coefficient to the row;"]
    #[doc = "  this method caches the row extensions and flushes them afterwards to gain better performance"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @attention If the absolute value of val is below the SCIP epsilon tolerance, the variables will not added."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarsToRowSameCoef(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " tries to find a value, such that all row coefficients, if scaled with this value become integral"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcalcRowIntegralScalar(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        mindelta: f64,
        maxdelta: f64,
        maxdnom: ::std::os::raw::c_longlong,
        maxscale: f64,
        usecontvars: ::std::os::raw::c_uint,
        intscalar: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " tries to scale row, s.t. all coefficients (of integer variables) become integral"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPmakeRowIntegral(
        scip: *mut SCIP,
        row: *mut SCIP_ROW,
        mindelta: f64,
        maxdelta: f64,
        maxdnom: ::std::os::raw::c_longlong,
        maxscale: f64,
        usecontvars: ::std::os::raw::c_uint,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " marks a row to be not removable from the LP in the current node"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in the following stage of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPmarkRowNotRemovableLocal(scip: *mut SCIP, row: *mut SCIP_ROW);
}
extern "C" {
    #[doc = " returns number of integral columns in the row"]
    #[doc = ""]
    #[doc = "  @return number of integral columns in the row"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowNumIntCols(scip: *mut SCIP, row: *mut SCIP_ROW) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns minimal absolute value of row vector's non-zero coefficients"]
    #[doc = ""]
    #[doc = "  @return minimal absolute value of row vector's non-zero coefficients"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowMinCoef(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns maximal absolute value of row vector's non-zero coefficients"]
    #[doc = ""]
    #[doc = "  @return maximal absolute value of row vector's non-zero coefficients"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowMaxCoef(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns the minimal activity of a row w.r.t. the column's bounds"]
    #[doc = ""]
    #[doc = "  @return the minimal activity of a row w.r.t. the column's bounds"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowMinActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns the maximal activity of a row w.r.t. the column's bounds"]
    #[doc = ""]
    #[doc = "  @return the maximal activity of a row w.r.t. the column's bounds"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowMaxActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " recalculates the activity of a row in the last LP solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrecalcRowLPActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the activity of a row in the last LP solution"]
    #[doc = ""]
    #[doc = "  @return activity of a row in the last LP solution"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowLPActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns the feasibility of a row in the last LP solution"]
    #[doc = ""]
    #[doc = "  @return the feasibility of a row in the last LP solution: negative value means infeasibility"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowLPFeasibility(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " recalculates the activity of a row for the current pseudo solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrecalcRowPseudoActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the activity of a row for the current pseudo solution"]
    #[doc = ""]
    #[doc = "  @return the activity of a row for the current pseudo solution"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowPseudoActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns the feasibility of a row for the current pseudo solution: negative value means infeasibility"]
    #[doc = ""]
    #[doc = "  @return the feasibility of a row for the current pseudo solution: negative value means infeasibility"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowPseudoFeasibility(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " recalculates the activity of a row in the last LP or pseudo solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrecalcRowActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the activity of a row in the last LP or pseudo solution"]
    #[doc = ""]
    #[doc = "  @return the activity of a row in the last LP or pseudo solution"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowActivity(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns the feasibility of a row in the last LP or pseudo solution"]
    #[doc = ""]
    #[doc = "  @return the feasibility of a row in the last LP or pseudo solution"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowFeasibility(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " returns the activity of a row for the given primal solution"]
    #[doc = ""]
    #[doc = "  @return the activitiy of a row for the given primal solution"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowSolActivity(scip: *mut SCIP, row: *mut SCIP_ROW, sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " returns the feasibility of a row for the given primal solution"]
    #[doc = ""]
    #[doc = "  @return the feasibility of a row for the given primal solution"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowSolFeasibility(scip: *mut SCIP, row: *mut SCIP_ROW, sol: *mut SCIP_SOL)
        -> f64;
}
extern "C" {
    #[doc = " returns the parallelism of row with objective function"]
    #[doc = ""]
    #[doc = "  @return 1 is returned if the row is parallel to the objective function and 0 if it is orthogonal"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRowObjParallelism(scip: *mut SCIP, row: *mut SCIP_ROW) -> f64;
}
extern "C" {
    #[doc = " output row to file stream via the message handler system"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPprintRow(scip: *mut SCIP, row: *mut SCIP_ROW, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " initiates LP diving, making methods SCIPchgVarObjDive(), SCIPchgVarLbDive(), and SCIPchgVarUbDive() available"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    #[doc = ""]
    #[doc = "  @note diving is allowed even if the current LP is not flushed, not solved, or not solved to optimality; be aware"]
    #[doc = "  that solving the (first) diving LP may take longer than expect and that the latter two cases could stem from"]
    #[doc = "  numerical troubles during the last LP solve; because of this, most users will want to call this method only if"]
    #[doc = "  SCIPgetLPSolstat(scip) == SCIP_LPSOLSTAT_OPTIMAL"]
    pub fn SCIPstartDive(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " quits LP diving and resets bounds and objective values of columns to the current node's values"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPendDive(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes cutoffbound in current dive"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPchgCutoffboundDive(scip: *mut SCIP, newcutoffbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes variable's objective value in current dive"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPchgVarObjDive(scip: *mut SCIP, var: *mut SCIP_VAR, newobj: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes variable's lower bound in current dive"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPchgVarLbDive(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes variable's upper bound in current dive"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPchgVarUbDive(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a row to the LP in current dive"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPaddRowDive(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes row lhs in current dive, change will be undone after diving ends, for permanent changes use SCIPchgRowLhs()"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPchgRowLhsDive(scip: *mut SCIP, row: *mut SCIP_ROW, newlhs: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes row rhs in current dive, change will be undone after diving ends, for permanent changes use SCIPchgRowRhs()"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPchgRowRhsDive(scip: *mut SCIP, row: *mut SCIP_ROW, newrhs: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets variable's objective value in current dive"]
    #[doc = ""]
    #[doc = "  @return the variable's objective value in current dive."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetVarObjDive(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets variable's lower bound in current dive"]
    #[doc = ""]
    #[doc = "  @return the variable's lower bound in current dive."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetVarLbDive(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets variable's upper bound in current dive"]
    #[doc = ""]
    #[doc = "  @return the variable's upper bound in current dive."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetVarUbDive(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " solves the LP of the current dive; no separation or pricing is applied"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    #[doc = ""]
    #[doc = "  @note be aware that the LP solve may take longer than expected if SCIPgetLPSolstat(scip) != SCIP_LPSOLSTAT_OPTIMAL,"]
    #[doc = "  compare the explanation of SCIPstartDive()"]
    pub fn SCIPsolveDiveLP(
        scip: *mut SCIP,
        itlim: ::std::os::raw::c_int,
        lperror: *mut ::std::os::raw::c_uint,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the number of the node in the current branch and bound run, where the last LP was solved in diving"]
    #[doc = "  or probing mode"]
    #[doc = ""]
    #[doc = "  @return the number of the node in the current branch and bound run, where the last LP was solved in diving"]
    #[doc = "  or probing mode."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetLastDivenode(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns whether we are in diving mode"]
    #[doc = ""]
    #[doc = "  @return whether we are in diving mode."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPinDive(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " computes the changes to the problem when fixing to the optimal face"]
    #[doc = ""]
    #[doc = "  returns the degeneracy rate, i.e., the number of nonbasic variables with reduced cost 0"]
    #[doc = "  and the variable constraint ratio, i.e., the number of unfixed variables in relation to the basis size"]
    pub fn SCIPgetLPDegeneracy(
        scip: *mut SCIP,
        degeneracy: *mut f64,
        varconsratio: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns block memory to use at the current time"]
    #[doc = ""]
    #[doc = "  @return the block memory to use at the current time."]
    pub fn SCIPblkmem(scip: *mut SCIP) -> *mut BMS_BLKMEM;
}
extern "C" {
    #[doc = " returns buffer memory for short living temporary objects"]
    #[doc = ""]
    #[doc = "  @return the buffer memory for short living temporary objects"]
    pub fn SCIPbuffer(scip: *mut SCIP) -> *mut BMS_BUFMEM;
}
extern "C" {
    #[doc = " returns clean buffer memory for short living temporary objects initialized to all zero"]
    #[doc = ""]
    #[doc = "  @return the buffer memory for short living temporary objects initialized to all zero"]
    pub fn SCIPcleanbuffer(scip: *mut SCIP) -> *mut BMS_BUFMEM;
}
extern "C" {
    #[doc = " returns the total number of bytes used in block and buffer memory"]
    #[doc = ""]
    #[doc = "  @return the total number of bytes used in block and buffer memory."]
    pub fn SCIPgetMemUsed(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the total number of bytes in block and buffer memory"]
    #[doc = ""]
    #[doc = "  @return the total number of bytes in block and buffer memory."]
    pub fn SCIPgetMemTotal(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " returns the estimated number of bytes used by external software, e.g., the LP solver"]
    #[doc = ""]
    #[doc = "  @return the estimated number of bytes used by external software, e.g., the LP solver."]
    pub fn SCIPgetMemExternEstim(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " calculate memory size for dynamically allocated arrays"]
    #[doc = ""]
    #[doc = "  @return the memory size for dynamically allocated arrays."]
    pub fn SCIPcalcMemGrowSize(
        scip: *mut SCIP,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " extends a dynamically allocated block memory array to be able to store at least the given number of elements;"]
    #[doc = "  use SCIPensureBlockMemoryArray() define to call this method!"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPensureBlockMemoryArray_call(
        scip: *mut SCIP,
        arrayptr: *mut *mut ::std::os::raw::c_void,
        elemsize: size_t,
        arraysize: *mut ::std::os::raw::c_int,
        minsize: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " prints output about used memory"]
    pub fn SCIPprintMemoryDiagnostic(scip: *mut SCIP);
}
extern "C" {
    #[doc = " installs the given message handler, such that all messages are passed to this handler. A messages handler can be"]
    #[doc = "  created via SCIPmessagehdlrCreate()."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note The currently installed messages handler gets freed if this SCIP instance is its last user (w.r.t. capture/release)."]
    pub fn SCIPsetMessagehdlr(scip: *mut SCIP, messagehdlr: *mut SCIP_MESSAGEHDLR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the currently installed message handler"]
    #[doc = ""]
    #[doc = "  @return the currently installed message handler, or NULL if messages are currently suppressed"]
    pub fn SCIPgetMessagehdlr(scip: *mut SCIP) -> *mut SCIP_MESSAGEHDLR;
}
extern "C" {
    #[doc = " sets the log file name for the currently installed message handler"]
    pub fn SCIPsetMessagehdlrLogfile(scip: *mut SCIP, filename: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " sets the currently installed message handler to be quiet (or not)"]
    pub fn SCIPsetMessagehdlrQuiet(scip: *mut SCIP, quiet: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " prints a warning message via the message handler"]
    pub fn SCIPwarningMessage(scip: *mut SCIP, formatstr: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " prints a debug message"]
    pub fn SCIPprintDebugMessage(
        scip: *mut SCIP,
        sourcefile: *const ::std::os::raw::c_char,
        sourceline: ::std::os::raw::c_int,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " prints a debug message without precode"]
    pub fn SCIPdebugMessagePrint(scip: *mut SCIP, formatstr: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " prints a dialog message that requests user interaction or is a direct response to a user interactive command"]
    pub fn SCIPdialogMessage(
        scip: *mut SCIP,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " prints a message"]
    pub fn SCIPinfoMessage(
        scip: *mut SCIP,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " prints a message depending on the verbosity level"]
    pub fn SCIPverbMessage(
        scip: *mut SCIP,
        msgverblevel: SCIP_VERBLEVEL,
        file: *mut FILE,
        formatstr: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " returns the current message verbosity level"]
    #[doc = ""]
    #[doc = "  @return message verbosity level of SCIP"]
    #[doc = ""]
    #[doc = "  @see \\ref SCIP_VerbLevel \"SCIP_VERBLEVEL\" for a list of all verbosity levels"]
    pub fn SCIPgetVerbLevel(scip: *mut SCIP) -> SCIP_VERBLEVEL;
}
extern "C" {
    #[doc = " includes an NLPI in SCIP"]
    pub fn SCIPincludeNlpi(scip: *mut SCIP, nlpi: *mut SCIP_NLPI) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the NLPI of the given name, or NULL if not existing"]
    pub fn SCIPfindNlpi(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_NLPI;
}
extern "C" {
    #[doc = " returns the array of currently available NLPIs (sorted by priority)"]
    pub fn SCIPgetNlpis(scip: *mut SCIP) -> *mut *mut SCIP_NLPI;
}
extern "C" {
    #[doc = " returns the number of currently available NLPIs"]
    pub fn SCIPgetNNlpis(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of an NLPI"]
    pub fn SCIPsetNlpiPriority(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether the NLP relaxation has been enabled"]
    #[doc = ""]
    #[doc = "  If the NLP relaxation is enabled, then SCIP will construct the NLP relaxation when the solving process is about to begin."]
    #[doc = "  To check whether an NLP is existing, use SCIPisNLPConstructed()."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @see SCIPenableNLP"]
    pub fn SCIPisNLPEnabled(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " marks that there are constraints that are representable by nonlinear rows"]
    #[doc = ""]
    #[doc = "  This method should be called by a constraint handler if it has constraints that have a representation as nonlinear rows."]
    #[doc = ""]
    #[doc = "  The function should be called before the branch-and-bound process is initialized, e.g., when presolve is exiting."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPenableNLP(scip: *mut SCIP);
}
extern "C" {
    #[doc = " returns, whether an NLP has been constructed"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPisNLPConstructed(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether the NLP has a continuous variable in a nonlinear term"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPhasNLPContinuousNonlinearity(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets current NLP variables along with the current number of NLP variables"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPVarsData(
        scip: *mut SCIP,
        vars: *mut *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets array with variables of the NLP"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPVars(scip: *mut SCIP) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets current number of variables in NLP"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNNLPVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " computes for each variables the number of NLP rows in which the variable appears in a nonlinear var"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPVarsNonlinearity(
        scip: *mut SCIP,
        nlcount: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns dual solution values associated with lower bounds of NLP variables"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPVarsLbDualsol(scip: *mut SCIP) -> *mut f64;
}
extern "C" {
    #[doc = " returns dual solution values associated with upper bounds of NLP variables"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPVarsUbDualsol(scip: *mut SCIP) -> *mut f64;
}
extern "C" {
    #[doc = " gets current NLP nonlinear rows along with the current number of NLP nonlinear rows"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPNlRowsData(
        scip: *mut SCIP,
        nlrows: *mut *mut *mut SCIP_NLROW,
        nnlrows: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets array with nonlinear rows of the NLP"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPNlRows(scip: *mut SCIP) -> *mut *mut SCIP_NLROW;
}
extern "C" {
    #[doc = " gets current number of nonlinear rows in NLP"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNNLPNlRows(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " adds a nonlinear row to the NLP. This row is captured by the NLP."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddNlRow(scip: *mut SCIP, nlrow: *mut SCIP_NLROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes a nonlinear row from the NLP. This row is released in the NLP."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPdelNlRow(scip: *mut SCIP, nlrow: *mut SCIP_NLROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " makes sure that the NLP of the current node is flushed"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPflushNLP(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets or clears initial primal guess for NLP solution (start point for NLP solver)"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetNLPInitialGuess(scip: *mut SCIP, initialguess: *mut f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initial primal guess for NLP solution (start point for NLP solver)"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetNLPInitialGuessSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " solves the current NLP"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsolveNLP(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets solution status of current NLP"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPSolstat(scip: *mut SCIP) -> SCIP_NLPSOLSTAT;
}
extern "C" {
    #[doc = " gets termination status of last NLP solve"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPTermstat(scip: *mut SCIP) -> SCIP_NLPTERMSTAT;
}
extern "C" {
    #[doc = " gives statistics (number of iterations, solving time, ...) of last NLP solve"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPStatistics(
        scip: *mut SCIP,
        statistics: *mut SCIP_NLPSTATISTICS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets objective value of current NLP"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPObjval(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " indicates whether a feasible solution for the current NLP is available"]
    #[doc = " thus, returns whether the solution status <= feasible"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPhasNLPSolution(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets fractional variables of last NLP solution along with solution values and fractionalities"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPFracVars(
        scip: *mut SCIP,
        fracvars: *mut *mut *mut SCIP_VAR,
        fracvarssol: *mut *mut f64,
        fracvarsfrac: *mut *mut f64,
        nfracvars: *mut ::std::os::raw::c_int,
        npriofracvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets integer parameter of NLP"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPIntPar(
        scip: *mut SCIP,
        type_: SCIP_NLPPARAM,
        ival: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets integer parameter of NLP"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetNLPIntPar(
        scip: *mut SCIP,
        type_: SCIP_NLPPARAM,
        ival: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets floating point parameter of NLP"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPRealPar(scip: *mut SCIP, type_: SCIP_NLPPARAM, dval: *mut f64)
        -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets floating point parameter of NLP"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetNLPRealPar(scip: *mut SCIP, type_: SCIP_NLPPARAM, dval: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets string parameter of NLP"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPStringPar(
        scip: *mut SCIP,
        type_: SCIP_NLPPARAM,
        sval: *mut *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets string parameter of NLP"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetNLPStringPar(
        scip: *mut SCIP,
        type_: SCIP_NLPPARAM,
        sval: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes current NLP to a file"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPwriteNLP(scip: *mut SCIP, filename: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the NLP interface and problem used by the SCIP NLP;"]
    #[doc = "  with the NLPI and its problem you can use all of the methods defined in nlpi/nlpi.h;"]
    #[doc = ""]
    #[doc = "  @warning You have to make sure, that the full internal state of the NLPI does not change or is recovered completely"]
    #[doc = "           after the end of the method that uses the NLPI. In particular, if you manipulate the NLP or its solution"]
    #[doc = "           (e.g. by calling one of the SCIPnlpiAdd...() or the SCIPnlpiSolve() method), you have to check in advance"]
    #[doc = "           whether the NLP is currently solved.  If this is the case, you have to make sure, the internal solution"]
    #[doc = "           status is recovered completely at the end of your method. Additionally you have to resolve the NLP with"]
    #[doc = "           SCIPnlpiSolve() in order to reinstall the internal solution status."]
    #[doc = ""]
    #[doc = "  @warning Make also sure, that all parameter values that you have changed are set back to their original values."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLPI(
        scip: *mut SCIP,
        nlpi: *mut *mut SCIP_NLPI,
        nlpiproblem: *mut *mut SCIP_NLPIPROBLEM,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " initiates NLP diving making methods SCIPchgVarObjDiveNLP(), SCIPchgVarBoundsDiveNLP(), SCIPchgVarsBoundsDiveNLP(), and SCIPsolveDiveNLP() available"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPstartDiveNLP(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " ends NLP diving"]
    #[doc = ""]
    #[doc = "  Resets changes made by SCIPchgVarObjDiveNLP(), SCIPchgVarBoundsDiveNLP(), and SCIPchgVarsBoundsDiveNLP()."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPendDiveNLP(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes linear objective coefficient of a variable in diving NLP"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarObjDiveNLP(scip: *mut SCIP, var: *mut SCIP_VAR, coef: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes bounds of a variable in diving NLP"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarBoundsDiveNLP(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        lb: f64,
        ub: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes bounds of a set of variables in diving NLP"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarsBoundsDiveNLP(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        lbs: *mut f64,
        ubs: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " solves diving NLP"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsolveDiveNLP(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an NLP row"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateNlRow(
        scip: *mut SCIP,
        nlrow: *mut *mut SCIP_NLROW,
        name: *const ::std::os::raw::c_char,
        constant: f64,
        nlinvars: ::std::os::raw::c_int,
        linvars: *mut *mut SCIP_VAR,
        lincoefs: *mut f64,
        nquadvars: ::std::os::raw::c_int,
        quadvars: *mut *mut SCIP_VAR,
        nquadelems: ::std::os::raw::c_int,
        quadelems: *mut SCIP_QUADELEM,
        expression: *mut SCIP_EXPRTREE,
        lhs: f64,
        rhs: f64,
        curvature: SCIP_EXPRCURV,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an NLP nonlinear row without any coefficients"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateEmptyNlRow(
        scip: *mut SCIP,
        nlrow: *mut *mut SCIP_NLROW,
        name: *const ::std::os::raw::c_char,
        lhs: f64,
        rhs: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures an NLP row from a linear row"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateNlRowFromRow(
        scip: *mut SCIP,
        nlrow: *mut *mut SCIP_NLROW,
        row: *mut SCIP_ROW,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " increases usage counter of NLP nonlinear row"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcaptureNlRow(scip: *mut SCIP, nlrow: *mut SCIP_NLROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " decreases usage counter of NLP nonlinear row, and frees memory if necessary"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPreleaseNlRow(scip: *mut SCIP, nlrow: *mut *mut SCIP_NLROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes left hand side of NLP nonlinear row"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgNlRowLhs(scip: *mut SCIP, nlrow: *mut SCIP_NLROW, lhs: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes right hand side of NLP nonlinear row"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgNlRowRhs(scip: *mut SCIP, nlrow: *mut SCIP_NLROW, rhs: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes constant of NLP nonlinear row"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgNlRowConstant(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        constant: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds variable with a linear coefficient to the nonlinear row"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddLinearCoefToNlRow(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds variables with linear coefficients to the row"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddLinearCoefsToNlRow(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes linear coefficient of a variables in a row"]
    #[doc = ""]
    #[doc = "  Setting the coefficient to 0.0 means that it is removed from the row"]
    #[doc = "  the variable does not need to exists before."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgNlRowLinearCoef(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        var: *mut SCIP_VAR,
        coef: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds quadratic variable to the nonlinear row"]
    #[doc = ""]
    #[doc = "  After adding a quadratic variable, it can be used to add quadratic elements."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddQuadVarToNlRow(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        var: *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds quadratic variables to the nonlinear row"]
    #[doc = ""]
    #[doc = "  After adding quadratic variables, they can be used to add quadratic elements."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddQuadVarsToNlRow(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " add a quadratic element to the nonlinear row"]
    #[doc = ""]
    #[doc = "  Variable indices of the quadratic element need to be relative to quadratic variables array of row."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddQuadElementToNlRow(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        quadelem: SCIP_QUADELEM,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds quadratic elements to the nonlinear row"]
    #[doc = ""]
    #[doc = "  Variable indices of the quadratic elements need to be relative to quadratic variables array of row."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddQuadElementsToNlRow(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        nquadelems: ::std::os::raw::c_int,
        quadelems: *mut SCIP_QUADELEM,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes coefficient in quadratic part of a row"]
    #[doc = ""]
    #[doc = "  Setting the coefficient in the quadelement to 0.0 means that it is removed from the row"]
    #[doc = "  the element does not need to exists before."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgNlRowQuadElement(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        quadelement: SCIP_QUADELEM,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets or deletes expression tree in the nonlinear row"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetNlRowExprtree(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        exprtree: *mut SCIP_EXPRTREE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets a parameter of expression tree in the nonlinear row"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetNlRowExprtreeParam(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        paramidx: ::std::os::raw::c_int,
        paramval: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets parameters of expression tree in the nonlinear row"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetNlRowExprtreeParams(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        paramvals: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " recalculates the activity of a nonlinear row in the last NLP solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrecalcNlRowNLPActivity(scip: *mut SCIP, nlrow: *mut SCIP_NLROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the activity of a nonlinear row in the last NLP solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowNLPActivity(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        activity: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives the feasibility of a nonlinear row in the last NLP solution: negative value means infeasibility"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowNLPFeasibility(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        feasibility: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " recalculates the activity of a nonlinear row for the current pseudo solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrecalcNlRowPseudoActivity(scip: *mut SCIP, nlrow: *mut SCIP_NLROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives the activity of a nonlinear row for the current pseudo solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowPseudoActivity(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        pseudoactivity: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives the feasibility of a nonlinear row for the current pseudo solution: negative value means infeasibility"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowPseudoFeasibility(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        pseudofeasibility: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " recalculates the activity of a nonlinear row in the last NLP or pseudo solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrecalcNlRowActivity(scip: *mut SCIP, nlrow: *mut SCIP_NLROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives the activity of a nonlinear row in the last NLP or pseudo solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowActivity(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        activity: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives the feasibility of a nonlinear row in the last NLP or pseudo solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowFeasibility(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        feasibility: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives the activity of a nonlinear row for the given primal solution or NLP solution or pseudo solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowSolActivity(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        sol: *mut SCIP_SOL,
        activity: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives the feasibility of a nonlinear row for the given primal solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowSolFeasibility(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        sol: *mut SCIP_SOL,
        feasibility: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gives the minimal and maximal activity of a nonlinear row w.r.t. the variable's bounds"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNlRowActivityBounds(
        scip: *mut SCIP,
        nlrow: *mut SCIP_NLROW,
        minactivity: *mut f64,
        maxactivity: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " output nonlinear row to file stream"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPprintNlRow(scip: *mut SCIP, nlrow: *mut SCIP_NLROW, file: *mut FILE)
        -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a node selector and includes it in SCIP."]
    #[doc = ""]
    #[doc = "  @note method has all node selector callbacks as arguments and is thus changed every time a new"]
    #[doc = "        callback is added in future releases; consider using SCIPincludeNodeselBasic() and setter functions"]
    #[doc = "        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeNodesel(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        stdpriority: ::std::os::raw::c_int,
        memsavepriority: ::std::os::raw::c_int,
        nodeselcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
        nodeselselect: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nodesel: *mut SCIP_NODESEL,
                selnode: *mut *mut SCIP_NODE,
            ) -> SCIP_RETCODE,
        >,
        nodeselcomp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nodesel: *mut SCIP_NODESEL,
                node1: *mut SCIP_NODE,
                node2: *mut SCIP_NODE,
            ) -> ::std::os::raw::c_int,
        >,
        nodeseldata: *mut SCIP_NODESELDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Creates a node selector and includes it in SCIP with its most fundamental callbacks. All non-fundamental"]
    #[doc = "  (or optional) callbacks as, e.g., init and exit callbacks, will be set to NULL."]
    #[doc = "  Optional callbacks can be set via specific setter functions, see SCIPsetNodeselCopy(), SCIPsetNodeselFree(),"]
    #[doc = "  SCIPsetNodeselInit(), SCIPsetNodeselExit(), SCIPsetNodeselInitsol(), and SCIPsetNodeselExitsol()"]
    #[doc = ""]
    #[doc = "  @note if you want to set all callbacks with a single method call, consider using SCIPincludeNodesel() instead"]
    pub fn SCIPincludeNodeselBasic(
        scip: *mut SCIP,
        nodesel: *mut *mut SCIP_NODESEL,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        stdpriority: ::std::os::raw::c_int,
        memsavepriority: ::std::os::raw::c_int,
        nodeselselect: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nodesel: *mut SCIP_NODESEL,
                selnode: *mut *mut SCIP_NODE,
            ) -> SCIP_RETCODE,
        >,
        nodeselcomp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                nodesel: *mut SCIP_NODESEL,
                node1: *mut SCIP_NODE,
                node2: *mut SCIP_NODE,
            ) -> ::std::os::raw::c_int,
        >,
        nodeseldata: *mut SCIP_NODESELDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of node selector"]
    pub fn SCIPsetNodeselCopy(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        nodeselcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of node selector"]
    pub fn SCIPsetNodeselFree(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        nodeselfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of node selector"]
    pub fn SCIPsetNodeselInit(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        nodeselinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of node selector"]
    pub fn SCIPsetNodeselExit(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        nodeselexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of node selector"]
    pub fn SCIPsetNodeselInitsol(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        nodeselinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of node selector"]
    pub fn SCIPsetNodeselExitsol(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        nodeselexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, nodesel: *mut SCIP_NODESEL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the node selector of the given name, or NULL if not existing"]
    pub fn SCIPfindNodesel(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SCIP_NODESEL;
}
extern "C" {
    #[doc = " returns the array of currently available node selectors"]
    pub fn SCIPgetNodesels(scip: *mut SCIP) -> *mut *mut SCIP_NODESEL;
}
extern "C" {
    #[doc = " returns the number of currently available node selectors"]
    pub fn SCIPgetNNodesels(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a node selector in standard mode"]
    pub fn SCIPsetNodeselStdPriority(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the priority of a node selector in memory saving mode"]
    pub fn SCIPsetNodeselMemsavePriority(
        scip: *mut SCIP,
        nodesel: *mut SCIP_NODESEL,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the currently used node selector"]
    pub fn SCIPgetNodesel(scip: *mut SCIP) -> *mut SCIP_NODESEL;
}
extern "C" {
    #[doc = " computes coefficients of linearization of a square term in a reference point"]
    pub fn SCIPaddSquareLinearization(
        scip: *mut SCIP,
        sqrcoef: f64,
        refpoint: f64,
        isint: ::std::os::raw::c_uint,
        lincoef: *mut f64,
        linconstant: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " computes coefficients of secant of a square term"]
    pub fn SCIPaddSquareSecant(
        scip: *mut SCIP,
        sqrcoef: f64,
        lb: f64,
        ub: f64,
        refpoint: f64,
        lincoef: *mut f64,
        linconstant: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " computes coefficients of linearization of a bilinear term in a reference point"]
    pub fn SCIPaddBilinLinearization(
        scip: *mut SCIP,
        bilincoef: f64,
        refpointx: f64,
        refpointy: f64,
        lincoefx: *mut f64,
        lincoefy: *mut f64,
        linconstant: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " computes coefficients of McCormick under- or overestimation of a bilinear term"]
    pub fn SCIPaddBilinMcCormick(
        scip: *mut SCIP,
        bilincoef: f64,
        lbx: f64,
        ubx: f64,
        refpointx: f64,
        lby: f64,
        uby: f64,
        refpointy: f64,
        overestimate: ::std::os::raw::c_uint,
        lincoefx: *mut f64,
        lincoefy: *mut f64,
        linconstant: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " computes coefficients of linearization of a bilinear term in a reference point when given a linear inequality"]
    #[doc = "  involving only the variables of the bilinear term"]
    #[doc = ""]
    #[doc = "  @note the formulas are extracted from \"Convex envelopes of bivariate functions through the solution of KKT systems\""]
    #[doc = "        by Marco Locatelli"]
    pub fn SCIPcomputeBilinEnvelope1(
        scip: *mut SCIP,
        bilincoef: f64,
        lbx: f64,
        ubx: f64,
        refpointx: f64,
        lby: f64,
        uby: f64,
        refpointy: f64,
        overestimate: ::std::os::raw::c_uint,
        xcoef: f64,
        ycoef: f64,
        constant: f64,
        lincoefx: *mut f64,
        lincoefy: *mut f64,
        linconstant: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " computes coefficients of linearization of a bilinear term in a reference point when given two linear inequality"]
    #[doc = "  involving only the variables of the bilinear term"]
    #[doc = ""]
    #[doc = "  @note the formulas are extracted from \"Convex envelopes of bivariate functions through the solution of KKT systems\""]
    #[doc = "        by Marco Locatelli"]
    #[doc = ""]
    pub fn SCIPcomputeBilinEnvelope2(
        scip: *mut SCIP,
        bilincoef: f64,
        lbx: f64,
        ubx: f64,
        refpointx: f64,
        lby: f64,
        uby: f64,
        refpointy: f64,
        overestimate: ::std::os::raw::c_uint,
        alpha1: f64,
        beta1: f64,
        gamma1: f64,
        alpha2: f64,
        beta2: f64,
        gamma2: f64,
        lincoefx: *mut f64,
        lincoefy: *mut f64,
        linconstant: *mut f64,
        success: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " creates an NLP relaxation and stores it in a given NLPI problem; the function computes for each variable which the"]
    #[doc = "  number of non-linearly occurrences and stores it in the nlscore array"]
    #[doc = ""]
    #[doc = "  @note the first row corresponds always to the cutoff row (even if cutoffbound is SCIPinfinity(scip))"]
    pub fn SCIPcreateNlpiProb(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        nlrows: *mut *mut SCIP_NLROW,
        nnlrows: ::std::os::raw::c_int,
        nlpiprob: *mut SCIP_NLPIPROBLEM,
        var2idx: *mut SCIP_HASHMAP,
        nlrow2idx: *mut SCIP_HASHMAP,
        nlscore: *mut f64,
        cutoffbound: f64,
        setobj: ::std::os::raw::c_uint,
        onlyconvex: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " updates bounds of each variable and the cutoff row in the nlpiproblem"]
    pub fn SCIPupdateNlpiProb(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        nlpiprob: *mut SCIP_NLPIPROBLEM,
        var2nlpiidx: *mut SCIP_HASHMAP,
        nlpivars: *mut *mut SCIP_VAR,
        nlpinvars: ::std::os::raw::c_int,
        cutoffbound: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds linear rows to the NLP relaxation"]
    pub fn SCIPaddNlpiProbRows(
        scip: *mut SCIP,
        nlpi: *mut SCIP_NLPI,
        nlpiprob: *mut SCIP_NLPIPROBLEM,
        var2idx: *mut SCIP_HASHMAP,
        rows: *mut *mut SCIP_ROW,
        nrows: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns value treated as zero"]
    #[doc = ""]
    #[doc = "  @return value treated as zero"]
    pub fn SCIPepsilon(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns value treated as zero for sums of floating point values"]
    #[doc = ""]
    #[doc = "  @return value treated as zero for sums of floating point values"]
    pub fn SCIPsumepsilon(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns feasibility tolerance for constraints"]
    #[doc = ""]
    #[doc = "  @return feasibility tolerance for constraints"]
    pub fn SCIPfeastol(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns primal feasibility tolerance of LP solver"]
    #[doc = ""]
    #[doc = "  @deprecated Please use SCIPgetLPFeastol()."]
    #[doc = ""]
    #[doc = "  @return primal feasibility tolerance of LP solver"]
    pub fn SCIPlpfeastol(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns feasibility tolerance for reduced costs"]
    #[doc = ""]
    #[doc = "  @return feasibility tolerance for reduced costs"]
    pub fn SCIPdualfeastol(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns convergence tolerance used in barrier algorithm"]
    #[doc = ""]
    #[doc = "  @return convergence tolerance used in barrier algorithm"]
    pub fn SCIPbarrierconvtol(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " return the cutoff bound delta"]
    #[doc = ""]
    #[doc = "  @return cutoff bound data"]
    pub fn SCIPcutoffbounddelta(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " return the relaxation primal feasibility tolerance"]
    #[doc = ""]
    #[doc = "  @see SCIPchgRelaxfeastol"]
    #[doc = "  @return relaxfeastol"]
    pub fn SCIPrelaxfeastol(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " sets the feasibility tolerance for constraints"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgFeastol(scip: *mut SCIP, feastol: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the primal feasibility tolerance of LP solver"]
    #[doc = ""]
    #[doc = "  @deprecated Please use SCIPsetLPFeastol()."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgLpfeastol(
        scip: *mut SCIP,
        lpfeastol: f64,
        printnewvalue: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the feasibility tolerance for reduced costs"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgDualfeastol(scip: *mut SCIP, dualfeastol: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the convergence tolerance used in barrier algorithm"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgBarrierconvtol(scip: *mut SCIP, barrierconvtol: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the primal feasibility tolerance of relaxations"]
    #[doc = ""]
    #[doc = " This tolerance value is used by the SCIP core and plugins to tighten then feasibility tolerance on relaxations"]
    #[doc = " (especially the LP relaxation) during a solve. It is set to SCIP_INVALID initially, which means that only the"]
    #[doc = " feasibility tolerance of the particular relaxation is taken into account. If set to a valid value, however,"]
    #[doc = " then this value should be used to reduce the primal feasibility tolerance of a relaxation (thus, use the"]
    #[doc = " minimum of relaxfeastol and the relaxations primal feastol)."]
    #[doc = ""]
    #[doc = " @pre The value of relaxfeastol is reset to SCIP_INVALID when initializing the solve (INITSOL)."]
    #[doc = " Therefore, this method can only be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = " @return previous value of relaxfeastol"]
    pub fn SCIPchgRelaxfeastol(scip: *mut SCIP, relaxfeastol: f64) -> f64;
}
extern "C" {
    #[doc = " marks that some limit parameter was changed"]
    pub fn SCIPmarkLimitChanged(scip: *mut SCIP);
}
extern "C" {
    #[doc = " returns value treated as infinity"]
    pub fn SCIPinfinity(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns the minimum value that is regarded as huge and should be handled separately (e.g., in activity"]
    #[doc = "  computation)"]
    pub fn SCIPgetHugeValue(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " checks, if values are in range of epsilon"]
    pub fn SCIPisEQ(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if val1 is (more than epsilon) lower than val2"]
    pub fn SCIPisLT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if val1 is not (more than epsilon) greater than val2"]
    pub fn SCIPisLE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if val1 is (more than epsilon) greater than val2"]
    pub fn SCIPisGT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if val1 is not (more than epsilon) lower than val2"]
    pub fn SCIPisGE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is (positive) infinite"]
    pub fn SCIPisInfinity(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is huge and should be handled separately (e.g., in activity computation)"]
    pub fn SCIPisHugeValue(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is in range epsilon of 0.0"]
    pub fn SCIPisZero(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is greater than epsilon"]
    pub fn SCIPisPositive(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is lower than -epsilon"]
    pub fn SCIPisNegative(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is integral within epsilon"]
    pub fn SCIPisIntegral(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks whether the product val * scalar is integral in epsilon scaled by scalar"]
    pub fn SCIPisScalingIntegral(scip: *mut SCIP, val: f64, scalar: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if given fractional part is smaller than epsilon"]
    pub fn SCIPisFracIntegral(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " rounds value + epsilon down to the next integer"]
    pub fn SCIPfloor(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " rounds value - epsilon up to the next integer"]
    pub fn SCIPceil(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " rounds value to the nearest integer with epsilon tolerance"]
    pub fn SCIPround(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " returns fractional part of value, i.e. x - floor(x) in epsilon tolerance"]
    pub fn SCIPfrac(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " checks, if values are in range of sumepsilon"]
    pub fn SCIPisSumEQ(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if val1 is (more than sumepsilon) lower than val2"]
    pub fn SCIPisSumLT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if val1 is not (more than sumepsilon) greater than val2"]
    pub fn SCIPisSumLE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if val1 is (more than sumepsilon) greater than val2"]
    pub fn SCIPisSumGT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if val1 is not (more than sumepsilon) lower than val2"]
    pub fn SCIPisSumGE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is in range sumepsilon of 0.0"]
    pub fn SCIPisSumZero(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is greater than sumepsilon"]
    pub fn SCIPisSumPositive(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is lower than -sumepsilon"]
    pub fn SCIPisSumNegative(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of values is in range of feasibility tolerance"]
    pub fn SCIPisFeasEQ(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference val1 and val2 is lower than feasibility tolerance"]
    pub fn SCIPisFeasLT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is not greater than feasibility tolerance"]
    pub fn SCIPisFeasLE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is greater than feastol"]
    pub fn SCIPisFeasGT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is not lower than -feastol"]
    pub fn SCIPisFeasGE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is in range feasibility tolerance of 0.0"]
    pub fn SCIPisFeasZero(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is greater than feasibility tolerance"]
    pub fn SCIPisFeasPositive(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is lower than -feasibility tolerance"]
    pub fn SCIPisFeasNegative(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is integral within the LP feasibility bounds"]
    pub fn SCIPisFeasIntegral(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if given fractional part is smaller than feastol"]
    pub fn SCIPisFeasFracIntegral(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " rounds value + feasibility tolerance down to the next integer"]
    pub fn SCIPfeasFloor(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " rounds value - feasibility tolerance up to the next integer"]
    pub fn SCIPfeasCeil(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " rounds value to the nearest integer in feasibility tolerance"]
    pub fn SCIPfeasRound(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " returns fractional part of value, i.e. x - floor(x)"]
    pub fn SCIPfeasFrac(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " checks, if relative difference of values is in range of dual feasibility tolerance"]
    pub fn SCIPisDualfeasEQ(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference val1 and val2 is lower than dual feasibility tolerance"]
    pub fn SCIPisDualfeasLT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is not greater than dual feasibility tolerance"]
    pub fn SCIPisDualfeasLE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is greater than dual feasibility tolerance"]
    pub fn SCIPisDualfeasGT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is not lower than -dual feasibility tolerance"]
    pub fn SCIPisDualfeasGE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is in range dual feasibility tolerance of 0.0"]
    pub fn SCIPisDualfeasZero(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is greater than dual feasibility tolerance"]
    pub fn SCIPisDualfeasPositive(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is lower than -dual feasibility tolerance"]
    pub fn SCIPisDualfeasNegative(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if value is integral within the LP dual feasibility tolerance"]
    pub fn SCIPisDualfeasIntegral(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if given fractional part is smaller than dual feasibility tolerance"]
    pub fn SCIPisDualfeasFracIntegral(scip: *mut SCIP, val: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " rounds value + dual feasibility tolerance down to the next integer"]
    pub fn SCIPdualfeasFloor(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " rounds value - dual feasibility tolerance up to the next integer"]
    pub fn SCIPdualfeasCeil(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " rounds value to the nearest integer in dual feasibility tolerance"]
    pub fn SCIPdualfeasRound(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " returns fractional part of value, i.e. x - floor(x) in dual feasibility tolerance"]
    pub fn SCIPdualfeasFrac(scip: *mut SCIP, val: f64) -> f64;
}
extern "C" {
    #[doc = " checks, if the given new lower bound is tighter (w.r.t. bound strengthening epsilon) than the old one"]
    pub fn SCIPisLbBetter(
        scip: *mut SCIP,
        newlb: f64,
        oldlb: f64,
        oldub: f64,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if the given new upper bound is tighter (w.r.t. bound strengthening epsilon) than the old one"]
    pub fn SCIPisUbBetter(
        scip: *mut SCIP,
        newub: f64,
        oldlb: f64,
        oldub: f64,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of values is in range of epsilon"]
    pub fn SCIPisRelEQ(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is lower than epsilon"]
    pub fn SCIPisRelLT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is not greater than epsilon"]
    pub fn SCIPisRelLE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is greater than epsilon"]
    pub fn SCIPisRelGT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is not lower than -epsilon"]
    pub fn SCIPisRelGE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of values is in range of sumepsilon"]
    pub fn SCIPisSumRelEQ(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is lower than sumepsilon"]
    pub fn SCIPisSumRelLT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is not greater than sumepsilon"]
    pub fn SCIPisSumRelLE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is greater than sumepsilon"]
    pub fn SCIPisSumRelGT(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " checks, if relative difference of val1 and val2 is not lower than -sumepsilon"]
    pub fn SCIPisSumRelGE(scip: *mut SCIP, val1: f64, val2: f64) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " converts the given real number representing an integer to an int; in optimized mode the function gets inlined for"]
    #[doc = "  performance; in debug mode we check some additional conditions"]
    pub fn SCIPconvertRealToInt(scip: *mut SCIP, real: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " converts the given real number representing an integer to a long integer; in optimized mode the function gets inlined for"]
    #[doc = "  performance; in debug mode we check some additional conditions"]
    pub fn SCIPconvertRealToLongint(scip: *mut SCIP, real: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " Checks, if an iteratively updated value is reliable or should be recomputed from scratch."]
    #[doc = "  This is useful, if the value, e.g., the activity of a linear constraint or the pseudo objective value, gets a high"]
    #[doc = "  absolute value during the optimization process which is later reduced significantly. In this case, the last digits"]
    #[doc = "  were canceled out when increasing the value and are random after decreasing it."]
    #[doc = "  We do not consider the cancellations which can occur during increasing the absolute value because they just cannot"]
    #[doc = "  be expressed using fixed precision floating point arithmetic, anymore."]
    #[doc = "  In order to get more reliable values, the idea is to always store the last reliable value, where increasing the"]
    #[doc = "  absolute of the value is viewed as preserving reliability. Then, after each update, the new absolute value can be"]
    #[doc = "  compared against the last reliable one with this method, checking whether it was decreased by a factor of at least"]
    #[doc = "  \"lp/recompfac\" and should be recomputed."]
    pub fn SCIPisUpdateUnreliable(
        scip: *mut SCIP,
        newvalue: f64,
        oldvalue: f64,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " outputs a real number, or \"+infinity\", or \"-infinity\" to a file"]
    pub fn SCIPprintReal(
        scip: *mut SCIP,
        file: *mut FILE,
        val: f64,
        width: ::std::os::raw::c_int,
        precision: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " parse a real value that was written with SCIPprintReal()"]
    pub fn SCIPparseReal(
        scip: *mut SCIP,
        str_: *const ::std::os::raw::c_char,
        value: *mut f64,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " creates a SCIP_Bool parameter, sets it to its default value, and adds it to the parameter set"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddBoolParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut ::std::os::raw::c_uint,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: ::std::os::raw::c_uint,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a int parameter, sets it to its default value, and adds it to the parameter set"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddIntParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut ::std::os::raw::c_int,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: ::std::os::raw::c_int,
        minvalue: ::std::os::raw::c_int,
        maxvalue: ::std::os::raw::c_int,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a SCIP_Longint parameter, sets it to its default value, and adds it to the parameter set"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddLongintParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut ::std::os::raw::c_longlong,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: ::std::os::raw::c_longlong,
        minvalue: ::std::os::raw::c_longlong,
        maxvalue: ::std::os::raw::c_longlong,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a SCIP_Real parameter, sets it to its default value, and adds it to the parameter set"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddRealParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut f64,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: f64,
        minvalue: f64,
        maxvalue: f64,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a char parameter, sets it to its default value, and adds it to the parameter set"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddCharParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut ::std::os::raw::c_char,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: ::std::os::raw::c_char,
        allowedvalues: *const ::std::os::raw::c_char,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a string(char*) parameter, sets it to its default value, and adds it to the parameter set"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPaddStringParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        valueptr: *mut *mut ::std::os::raw::c_char,
        isadvanced: ::std::os::raw::c_uint,
        defaultvalue: *const ::std::os::raw::c_char,
        paramchgd: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, param: *mut SCIP_PARAM) -> SCIP_RETCODE,
        >,
        paramdata: *mut SCIP_PARAMDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the fixing status of an existing parameter"]
    #[doc = ""]
    #[doc = "  @return TRUE if the parameter is fixed to a value, otherwise FALSE."]
    pub fn SCIPisParamFixed(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the pointer to the SCIP parameter with the given name"]
    #[doc = ""]
    #[doc = "  @return pointer to the parameter with the given name"]
    pub fn SCIPgetParam(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_PARAM;
}
extern "C" {
    #[doc = " gets the value of an existing SCIP_Bool parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPgetBoolParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the value of an existing int parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPgetIntParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the value of an existing SCIP_Longint parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPgetLongintParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the value of an existing SCIP_Real parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPgetRealParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the value of an existing char parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPgetCharParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the value of an existing string(char*) parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPgetStringParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " fixes the value of an existing parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @note: Be careful with this method! Some general settings, e.g., the time or node limit, should not be fixed because"]
    #[doc = "         they have to be changed for sub-SCIPs."]
    pub fn SCIPfixParam(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " unfixes the value of an existing parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPunfixParam(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the value of an existing parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_void,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the value of an existing SCIP_Bool parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgBoolParam(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the value of an existing SCIP_Bool parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetBoolParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether the value of an existing SCIP_Bool parameter is valid"]
    pub fn SCIPisBoolParamValid(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " changes the value of an existing int parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgIntParam(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the value of an existing int parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetIntParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether the value of an existing int parameter is valid"]
    pub fn SCIPisIntParamValid(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " changes the value of an existing SCIP_Longint parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgLongintParam(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the value of an existing SCIP_Longint parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetLongintParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether parameter value of an existing SCIP_Longint paramter is valid"]
    pub fn SCIPisLongintParamValid(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " changes the value of an existing SCIP_Real parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgRealParam(scip: *mut SCIP, param: *mut SCIP_PARAM, value: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the value of an existing SCIP_Real parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetRealParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether parameter value of an existing SCIP_Real paramter is valid"]
    pub fn SCIPisRealParamValid(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: f64,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " changes the value of an existing char parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgCharParam(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the value of an existing char parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetCharParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether parameter value for a given SCIP_Real parameter is valid"]
    pub fn SCIPisCharParamValid(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " changes the value of an existing string(char*) parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPchgStringParam(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the value of an existing string(char*) parameter"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetStringParam(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks whether parameter value for a given string parameter is valid"]
    pub fn SCIPisStringParamValid(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " reads parameters from a file"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPreadParams(scip: *mut SCIP, filename: *const ::std::os::raw::c_char)
        -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes a single parameter to a file"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPwriteParam(
        scip: *mut SCIP,
        param: *mut SCIP_PARAM,
        filename: *const ::std::os::raw::c_char,
        comments: ::std::os::raw::c_uint,
        onlychanged: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes all parameters in the parameter set to a file"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPwriteParams(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        comments: ::std::os::raw::c_uint,
        onlychanged: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " resets a single parameter to its default value"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPresetParam(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " resets all parameters to their default values"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPresetParams(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets parameters to"]
    #[doc = ""]
    #[doc = "  - \\ref SCIP_PARAMEMPHASIS_DEFAULT to use default values (see also SCIPresetParams())"]
    #[doc = "  - \\ref SCIP_PARAMEMPHASIS_COUNTER to get feasible and \"fast\" counting process"]
    #[doc = "  - \\ref SCIP_PARAMEMPHASIS_CPSOLVER to get CP like search (e.g. no LP relaxation)"]
    #[doc = "  - \\ref SCIP_PARAMEMPHASIS_EASYCIP to solve easy problems fast"]
    #[doc = "  - \\ref SCIP_PARAMEMPHASIS_FEASIBILITY to detect feasibility fast"]
    #[doc = "  - \\ref SCIP_PARAMEMPHASIS_HARDLP to be capable to handle hard LPs"]
    #[doc = "  - \\ref SCIP_PARAMEMPHASIS_OPTIMALITY to prove optimality fast"]
    #[doc = "  - \\ref SCIP_PARAMEMPHASIS_PHASEFEAS to find feasible solutions during a 3 phase solution process"]
    #[doc = "  - \\ref SCIP_PARAMEMPHASIS_PHASEIMPROVE to find improved solutions during a 3 phase solution process"]
    #[doc = "  - \\ref SCIP_PARAMEMPHASIS_PHASEPROOF to proof optimality during a 3 phase solution process"]
    #[doc = "  - \\ref SCIP_PARAMEMPHASIS_NUMERICS to solve problems which cause numerical issues"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetEmphasis(
        scip: *mut SCIP,
        paramemphasis: SCIP_PARAMEMPHASIS,
        quiet: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets parameters to deactivate separators and heuristics that use auxiliary SCIP instances; should be called for"]
    #[doc = "  auxiliary SCIP instances to avoid recursion"]
    #[doc = ""]
    #[doc = "  @note only deactivates plugins which could cause recursion, some plugins which use sub-SCIPs stay activated"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetSubscipsOff(scip: *mut SCIP, quiet: ::std::os::raw::c_uint) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets heuristic parameters values to"]
    #[doc = ""]
    #[doc = "  - SCIP_PARAMSETTING_DEFAULT which are the default values of all heuristic parameters"]
    #[doc = "  - SCIP_PARAMSETTING_FAST such that the time spend for heuristic is decreased"]
    #[doc = "  - SCIP_PARAMSETTING_AGGRESSIVE such that the heuristic are called more aggregative"]
    #[doc = "  - SCIP_PARAMSETTING_OFF which turn off all heuristics"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetHeuristics(
        scip: *mut SCIP,
        paramsetting: SCIP_PARAMSETTING,
        quiet: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets presolving parameters to"]
    #[doc = ""]
    #[doc = "  - SCIP_PARAMSETTING_DEFAULT which are the default values of all presolving parameters"]
    #[doc = "  - SCIP_PARAMSETTING_FAST such that the time spend for presolving is decreased"]
    #[doc = "  - SCIP_PARAMSETTING_AGGRESSIVE such that the presolving is more aggregative"]
    #[doc = "  - SCIP_PARAMSETTING_OFF which turn off all presolving"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetPresolving(
        scip: *mut SCIP,
        paramsetting: SCIP_PARAMSETTING,
        quiet: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets separating parameters to"]
    #[doc = ""]
    #[doc = "  - SCIP_PARAMSETTING_DEFAULT which are the default values of all separating parameters"]
    #[doc = "  - SCIP_PARAMSETTING_FAST such that the time spend for separating is decreased"]
    #[doc = "  - SCIP_PARAMSETTING_AGGRESSIVE such that the separating is done more aggregative"]
    #[doc = "  - SCIP_PARAMSETTING_OFF which turn off all separating"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetSeparating(
        scip: *mut SCIP,
        paramsetting: SCIP_PARAMSETTING,
        quiet: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the array of all available SCIP parameters"]
    #[doc = ""]
    #[doc = "  @return SCIP_PARAM* array, containing all SCIP parameters."]
    pub fn SCIPgetParams(scip: *mut SCIP) -> *mut *mut SCIP_PARAM;
}
extern "C" {
    #[doc = " returns the total number of all available SCIP parameters"]
    #[doc = ""]
    #[doc = "  @return number of all SCIP parameters."]
    pub fn SCIPgetNParams(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns whether plugins with sub-SCIPs that could cause recursion have been disabled"]
    #[doc = ""]
    #[doc = "  @return the value of the variable set->subscipsoff"]
    pub fn SCIPgetSubscipsOff(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " creates a presolver and includes it in SCIP"]
    #[doc = ""]
    #[doc = "  @note method has all presolver callbacks as arguments and is thus changed every time a new"]
    #[doc = "        callback is added"]
    #[doc = "        in future releases; consider using SCIPincludePresolBasic() and setter functions"]
    #[doc = "        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludePresol(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        maxrounds: ::std::os::raw::c_int,
        timing: SCIP_PRESOLTIMING,
        presolcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
        presolfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
        presolinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
        presolexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
        presolinitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
        presolexitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
        presolexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                presol: *mut SCIP_PRESOL,
                nrounds: ::std::os::raw::c_int,
                presoltiming: SCIP_PRESOLTIMING,
                nnewfixedvars: ::std::os::raw::c_int,
                nnewaggrvars: ::std::os::raw::c_int,
                nnewchgvartypes: ::std::os::raw::c_int,
                nnewchgbds: ::std::os::raw::c_int,
                nnewholes: ::std::os::raw::c_int,
                nnewdelconss: ::std::os::raw::c_int,
                nnewaddconss: ::std::os::raw::c_int,
                nnewupgdconss: ::std::os::raw::c_int,
                nnewchgcoefs: ::std::os::raw::c_int,
                nnewchgsides: ::std::os::raw::c_int,
                nfixedvars: *mut ::std::os::raw::c_int,
                naggrvars: *mut ::std::os::raw::c_int,
                nchgvartypes: *mut ::std::os::raw::c_int,
                nchgbds: *mut ::std::os::raw::c_int,
                naddholes: *mut ::std::os::raw::c_int,
                ndelconss: *mut ::std::os::raw::c_int,
                naddconss: *mut ::std::os::raw::c_int,
                nupgdconss: *mut ::std::os::raw::c_int,
                nchgcoefs: *mut ::std::os::raw::c_int,
                nchgsides: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        presoldata: *mut SCIP_PRESOLDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Creates a presolver and includes it in SCIP with its fundamental callback. All non-fundamental (or optional)"]
    #[doc = "  callbacks as, e.g., init and exit callbacks, will be set to NULL. Optional callbacks can be set via specific setter"]
    #[doc = "  functions. These are SCIPsetPresolCopy(), SCIPsetPresolFree(), SCIPsetPresolInit(), SCIPsetPresolExit(),"]
    #[doc = "  SCIPsetPresolInitpre(), and SCIPsetPresolExitPre()."]
    #[doc = ""]
    #[doc = "  @note if you want to set all callbacks with a single method call, consider using SCIPincludePresol() instead"]
    pub fn SCIPincludePresolBasic(
        scip: *mut SCIP,
        presolptr: *mut *mut SCIP_PRESOL,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        maxrounds: ::std::os::raw::c_int,
        timing: SCIP_PRESOLTIMING,
        presolexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                presol: *mut SCIP_PRESOL,
                nrounds: ::std::os::raw::c_int,
                presoltiming: SCIP_PRESOLTIMING,
                nnewfixedvars: ::std::os::raw::c_int,
                nnewaggrvars: ::std::os::raw::c_int,
                nnewchgvartypes: ::std::os::raw::c_int,
                nnewchgbds: ::std::os::raw::c_int,
                nnewholes: ::std::os::raw::c_int,
                nnewdelconss: ::std::os::raw::c_int,
                nnewaddconss: ::std::os::raw::c_int,
                nnewupgdconss: ::std::os::raw::c_int,
                nnewchgcoefs: ::std::os::raw::c_int,
                nnewchgsides: ::std::os::raw::c_int,
                nfixedvars: *mut ::std::os::raw::c_int,
                naggrvars: *mut ::std::os::raw::c_int,
                nchgvartypes: *mut ::std::os::raw::c_int,
                nchgbds: *mut ::std::os::raw::c_int,
                naddholes: *mut ::std::os::raw::c_int,
                ndelconss: *mut ::std::os::raw::c_int,
                naddconss: *mut ::std::os::raw::c_int,
                nupgdconss: *mut ::std::os::raw::c_int,
                nchgcoefs: *mut ::std::os::raw::c_int,
                nchgsides: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        presoldata: *mut SCIP_PRESOLDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of presolver"]
    pub fn SCIPsetPresolCopy(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        presolcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of presolver"]
    pub fn SCIPsetPresolFree(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        presolfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of presolver"]
    pub fn SCIPsetPresolInit(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        presolinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of presolver"]
    pub fn SCIPsetPresolExit(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        presolexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of presolver"]
    pub fn SCIPsetPresolInitpre(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        presolinitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of presolver"]
    pub fn SCIPsetPresolExitpre(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        presolexitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, presol: *mut SCIP_PRESOL) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the presolver of the given name, or NULL if not existing"]
    pub fn SCIPfindPresol(scip: *mut SCIP, name: *const ::std::os::raw::c_char)
        -> *mut SCIP_PRESOL;
}
extern "C" {
    #[doc = " returns the array of currently available presolvers"]
    pub fn SCIPgetPresols(scip: *mut SCIP) -> *mut *mut SCIP_PRESOL;
}
extern "C" {
    #[doc = " returns the number of currently available presolvers"]
    pub fn SCIPgetNPresols(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a presolver"]
    pub fn SCIPsetPresolPriority(
        scip: *mut SCIP,
        presol: *mut SCIP_PRESOL,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a variable pricer and includes it in SCIP"]
    #[doc = "  To use the variable pricer for solving a problem, it first has to be activated with a call to SCIPactivatePricer()."]
    #[doc = "  This should be done during the problem creation stage."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note method has all pricer callbacks as arguments and is thus changed every time a new callback is added"]
    #[doc = "        in future releases; consider using SCIPincludePricerBasic() and setter functions"]
    #[doc = "        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludePricer(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        delay: ::std::os::raw::c_uint,
        pricercopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                pricer: *mut SCIP_PRICER,
                valid: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        pricerfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
        pricerinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
        pricerexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
        pricerinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
        pricerexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
        pricerredcost: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                pricer: *mut SCIP_PRICER,
                lowerbound: *mut f64,
                stopearly: *mut ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        pricerfarkas: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                pricer: *mut SCIP_PRICER,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        pricerdata: *mut SCIP_PRICERDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a variable pricer and includes it in SCIP with all non-fundamental callbacks set to NULL;"]
    #[doc = "  if needed, these can be added afterwards via setter functions SCIPsetPricerCopy(), SCIPsetPricerFree(),"]
    #[doc = "  SCIPsetPricerInity(), SCIPsetPricerExit(), SCIPsetPricerInitsol(), SCIPsetPricerExitsol(),"]
    #[doc = "  SCIPsetPricerFarkas();"]
    #[doc = ""]
    #[doc = "  To use the variable pricer for solving a problem, it first has to be activated with a call to SCIPactivatePricer()."]
    #[doc = "  This should be done during the problem creation stage."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note if you want to set all callbacks with a single method call, consider using SCIPincludePricer() instead"]
    pub fn SCIPincludePricerBasic(
        scip: *mut SCIP,
        pricerptr: *mut *mut SCIP_PRICER,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        delay: ::std::os::raw::c_uint,
        pricerredcost: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                pricer: *mut SCIP_PRICER,
                lowerbound: *mut f64,
                stopearly: *mut ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        pricerfarkas: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                pricer: *mut SCIP_PRICER,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        pricerdata: *mut SCIP_PRICERDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of pricer"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetPricerCopy(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        pricercopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                pricer: *mut SCIP_PRICER,
                valid: *mut ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of pricer"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetPricerFree(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        pricerfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of pricer"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetPricerInit(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        pricerinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of pricer"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetPricerExit(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        pricerexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of pricer"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetPricerInitsol(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        pricerinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of pricer"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetPricerExitsol(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        pricerexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the variable pricer of the given name, or NULL if not existing"]
    pub fn SCIPfindPricer(scip: *mut SCIP, name: *const ::std::os::raw::c_char)
        -> *mut SCIP_PRICER;
}
extern "C" {
    #[doc = " returns the array of currently available variable pricers; active pricers are in the first slots of the array"]
    pub fn SCIPgetPricers(scip: *mut SCIP) -> *mut *mut SCIP_PRICER;
}
extern "C" {
    #[doc = " returns the number of currently available variable pricers"]
    pub fn SCIPgetNPricers(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of currently active variable pricers, that are used in the LP solving loop"]
    pub fn SCIPgetNActivePricers(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a variable pricer"]
    pub fn SCIPsetPricerPriority(
        scip: *mut SCIP,
        pricer: *mut SCIP_PRICER,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " activates pricer to be used for the current problem"]
    #[doc = "  This method should be called during the problem creation stage for all pricers that are necessary to solve"]
    #[doc = "  the problem model."]
    #[doc = "  The pricers are automatically deactivated when the problem is freed."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPactivatePricer(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " deactivates pricer"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPdeactivatePricer(scip: *mut SCIP, pricer: *mut SCIP_PRICER) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates empty problem and initializes all solving data structures (the objective sense is set to MINIMIZE)"]
    #[doc = "  If the problem type requires the use of variable pricers, these pricers should be added to the problem with calls"]
    #[doc = "  to SCIPactivatePricer(). These pricers are automatically deactivated, when the problem is freed."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_FREE"]
    #[doc = ""]
    #[doc = "  @post After calling this method, \\SCIP reaches the following stage:"]
    #[doc = "        - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPcreateProb(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        probdelorig: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                probdata: *mut *mut SCIP_PROBDATA,
            ) -> SCIP_RETCODE,
        >,
        probtrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcedata: *mut SCIP_PROBDATA,
                targetdata: *mut *mut SCIP_PROBDATA,
            ) -> SCIP_RETCODE,
        >,
        probdeltrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                probdata: *mut *mut SCIP_PROBDATA,
            ) -> SCIP_RETCODE,
        >,
        probinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, probdata: *mut SCIP_PROBDATA) -> SCIP_RETCODE,
        >,
        probexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                probdata: *mut SCIP_PROBDATA,
                restart: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        probcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcescip: *mut SCIP,
                sourcedata: *mut SCIP_PROBDATA,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                targetdata: *mut *mut SCIP_PROBDATA,
                global: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        probdata: *mut SCIP_PROBDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates empty problem and initializes all solving data structures (the objective sense is set to MINIMIZE)"]
    #[doc = "  all callback methods will be set to NULL and can be set afterwards, if needed, via SCIPsetProbDelorig(),"]
    #[doc = "  SCIPsetProbTrans(), SCIPsetProbDeltrans(), SCIPsetProbInitsol(), SCIPsetProbExitsol(), and"]
    #[doc = "  SCIPsetProbCopy()"]
    #[doc = "  If the problem type requires the use of variable pricers, these pricers should be added to the problem with calls"]
    #[doc = "  to SCIPactivatePricer(). These pricers are automatically deactivated, when the problem is freed."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_FREE"]
    #[doc = ""]
    #[doc = "  @post After calling this method, \\SCIP reaches the following stage:"]
    #[doc = "        - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPcreateProbBasic(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets callback to free user data of original problem"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetProbDelorig(
        scip: *mut SCIP,
        probdelorig: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                probdata: *mut *mut SCIP_PROBDATA,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets callback to create user data of transformed problem by transforming original user data"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetProbTrans(
        scip: *mut SCIP,
        probtrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcedata: *mut SCIP_PROBDATA,
                targetdata: *mut *mut SCIP_PROBDATA,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets callback to free user data of transformed problem"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetProbDeltrans(
        scip: *mut SCIP,
        probdeltrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                probdata: *mut *mut SCIP_PROBDATA,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization callback of transformed data"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetProbInitsol(
        scip: *mut SCIP,
        probinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, probdata: *mut SCIP_PROBDATA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization callback of transformed data"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetProbExitsol(
        scip: *mut SCIP,
        probexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                probdata: *mut SCIP_PROBDATA,
                restart: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets callback to copy user data to a subscip"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetProbCopy(
        scip: *mut SCIP,
        probcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcescip: *mut SCIP,
                sourcedata: *mut SCIP_PROBDATA,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                targetdata: *mut *mut SCIP_PROBDATA,
                global: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reads problem from file and initializes all solving data structures"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = ""]
    #[doc = "  @post After the method was called, \\SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT if reading failed (usually, when a SCIP_READERROR occurs)"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM if the problem file was successfully read"]
    pub fn SCIPreadProb(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        extension: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes original problem to file"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPwriteOrigProblem(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        extension: *const ::std::os::raw::c_char,
        genericnames: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " writes transformed problem which are valid in the current node to file"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = ""]
    #[doc = "  @note If you want the write all constraints (including the once which are redundant for example), you need to set"]
    #[doc = "        the parameter <write/allconss> to TRUE"]
    pub fn SCIPwriteTransProblem(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        extension: *const ::std::os::raw::c_char,
        genericnames: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees problem and solution process data"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_FREE"]
    #[doc = ""]
    #[doc = "  @post After this method was called, SCIP is in the following stage:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    pub fn SCIPfreeProb(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " permutes parts of the problem data structure"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    pub fn SCIPpermuteProb(
        scip: *mut SCIP,
        randseed: ::std::os::raw::c_uint,
        permuteconss: ::std::os::raw::c_uint,
        permutebinvars: ::std::os::raw::c_uint,
        permuteintvars: ::std::os::raw::c_uint,
        permuteimplvars: ::std::os::raw::c_uint,
        permutecontvars: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets user problem data"]
    #[doc = ""]
    #[doc = "  @return a SCIP_PROBDATA pointer, or NULL if no problem data was allocated"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetProbData(scip: *mut SCIP) -> *mut SCIP_PROBDATA;
}
extern "C" {
    #[doc = " sets user problem data"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPsetProbData(scip: *mut SCIP, probdata: *mut SCIP_PROBDATA) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns name of the current problem instance"]
    #[doc = ""]
    #[doc = "  @return name of the current problem instance"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetProbName(scip: *mut SCIP) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " sets name of the current problem instance"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPsetProbName(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the objective function"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = ""]
    #[doc = "  @note This method should be only used to change the objective function during two reoptimization runs and is only"]
    #[doc = "        recommended to an experienced user."]
    #[doc = ""]
    #[doc = "  @note All variables not given in \\p vars array are assumed to have an objective coefficient of zero."]
    pub fn SCIPchgReoptObjective(
        scip: *mut SCIP,
        objsense: SCIP_OBJSENSE,
        vars: *mut *mut SCIP_VAR,
        coefs: *mut f64,
        nvars: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns objective sense of original problem"]
    #[doc = ""]
    #[doc = "  @return objective sense of original problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetObjsense(scip: *mut SCIP) -> SCIP_OBJSENSE;
}
extern "C" {
    #[doc = " sets objective sense of problem"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetObjsense(scip: *mut SCIP, objsense: SCIP_OBJSENSE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds offset of objective function"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    pub fn SCIPaddObjoffset(scip: *mut SCIP, addval: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds offset of objective function to original problem and to all existing solution in original space"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPaddOrigObjoffset(scip: *mut SCIP, addval: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the objective offset of the original problem"]
    #[doc = ""]
    #[doc = "  @return the objective offset of the original problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetOrigObjoffset(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns the objective scale of the original problem"]
    #[doc = ""]
    #[doc = "  @return the objective scale of the original problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetOrigObjscale(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns the objective offset of the transformed problem"]
    #[doc = ""]
    #[doc = "  @return the objective offset of the transformed problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetTransObjoffset(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns the objective scale of the transformed problem"]
    #[doc = ""]
    #[doc = "  @return the objective scale of the transformed problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetTransObjscale(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " sets limit on objective function, such that only solutions better than this limit are accepted"]
    #[doc = ""]
    #[doc = "  @note SCIP will only look for solutions with a strictly better objective value, thus, e.g., prune"]
    #[doc = "        all branch-and-bound nodes with dual bound equal or worse to the objective limit."]
    #[doc = "        However, SCIP will also collect solutions with objective value worse than the objective limit and"]
    #[doc = "        use them to run improvement heuristics on them."]
    #[doc = "  @note If SCIP can prove that there exists no solution with a strictly better objective value, the solving status"]
    #[doc = "        will normally be infeasible (the objective limit is interpreted as part of the problem)."]
    #[doc = "        The only exception is that by chance, SCIP found a solution with the same objective value and thus"]
    #[doc = "        proved the optimality of this solution, resulting in solution status optimal."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetObjlimit(scip: *mut SCIP, objlimit: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns current limit on objective function"]
    #[doc = ""]
    #[doc = "  @return the current objective limit of the original problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetObjlimit(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " informs SCIP, that the objective value is always integral in every feasible solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. otherwise a suitable error code is passed. see \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note This function should be used to inform SCIP that the objective function is integral, helping to improve the"]
    #[doc = "        performance. This is useful when using column generation. If no column generation (pricing) is used, SCIP"]
    #[doc = "        automatically detects whether the objective function is integral or can be scaled to be integral. However, in"]
    #[doc = "        any case, the user has to make sure that no variable is added during the solving process that destroys this"]
    #[doc = "        property."]
    pub fn SCIPsetObjIntegral(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether the objective value is known to be integral in every feasible solution"]
    #[doc = ""]
    #[doc = "  @return TRUE, if objective value is known to be always integral, otherwise FALSE"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note If no pricing is performed, SCIP automatically detects whether the objective function is integral or can be"]
    #[doc = "        scaled to be integral, helping to improve performance. This function returns the result. Otherwise"]
    #[doc = "        SCIPsetObjIntegral() can be used to inform SCIP. However, in any case, the user has to make sure that no"]
    #[doc = "        variable is added during the solving process that destroys this property."]
    pub fn SCIPisObjIntegral(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the Euclidean norm of the objective function vector (available only for transformed problem)"]
    #[doc = ""]
    #[doc = "  @return the Euclidean norm of the transformed objective function vector"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetObjNorm(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " adds variable to the problem"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVar(scip: *mut SCIP, var: *mut SCIP_VAR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds variable to the problem and uses it as pricing candidate to enter the LP"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddPricedVar(scip: *mut SCIP, var: *mut SCIP_VAR, score: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes variable from the problem"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPdelVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        deleted: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets variables of the problem along with the numbers of different variable types; data may become invalid after"]
    #[doc = "  calls to SCIPchgVarType(), SCIPfixVar(), SCIPaggregateVars(), and SCIPmultiaggregateVar()"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = ""]
    #[doc = "  @note Variables in the vars array are ordered: binaries first, then integers, implicit integers and continuous last."]
    pub fn SCIPgetVarsData(
        scip: *mut SCIP,
        vars: *mut *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
        nbinvars: *mut ::std::os::raw::c_int,
        nintvars: *mut ::std::os::raw::c_int,
        nimplvars: *mut ::std::os::raw::c_int,
        ncontvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets array with active problem variables"]
    #[doc = ""]
    #[doc = "  @return array with active problem variables"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = ""]
    #[doc = "  @warning If your are using the methods which add or change bound of variables (e.g., SCIPchgVarType(), SCIPfixVar(),"]
    #[doc = "           SCIPaggregateVars(), and SCIPmultiaggregateVar()), it can happen that the internal variable array (which is"]
    #[doc = "           accessed via this method) gets resized and/or resorted. This can invalid the data pointer which is returned"]
    #[doc = "           by this method."]
    #[doc = ""]
    #[doc = "  @note Variables in the array are ordered: binaries first, then integers, implicit integers and continuous last."]
    pub fn SCIPgetVars(scip: *mut SCIP) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets number of active problem variables"]
    #[doc = ""]
    #[doc = "  @return the number of active problem variables"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of binary active problem variables"]
    #[doc = ""]
    #[doc = "  @return the number of binary active problem variables"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNBinVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of integer active problem variables"]
    #[doc = ""]
    #[doc = "  @return the number of integer active problem variables"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNIntVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of implicit integer active problem variables"]
    #[doc = ""]
    #[doc = "  @return the number of implicit integer active problem variables"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNImplVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of continuous active problem variables"]
    #[doc = ""]
    #[doc = "  @return the number of continuous active problem variables"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNContVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of active problem variables with a non-zero objective coefficient"]
    #[doc = ""]
    #[doc = "  @note In case of the original problem the number of variables is counted. In case of the transformed problem the"]
    #[doc = "        number of variables is just returned since it is stored internally"]
    #[doc = ""]
    #[doc = "  @return the number of active problem variables with a non-zero objective coefficient"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNObjVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array with fixed and aggregated problem variables; data may become invalid after"]
    #[doc = "  calls to SCIPfixVar(), SCIPaggregateVars(), and SCIPmultiaggregateVar()"]
    #[doc = ""]
    #[doc = "  @return an array with fixed and aggregated problem variables; data may become invalid after"]
    #[doc = "          calls to SCIPfixVar(), SCIPaggregateVars(), and SCIPmultiaggregateVar()"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetFixedVars(scip: *mut SCIP) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets number of fixed or aggregated problem variables"]
    #[doc = ""]
    #[doc = "  @return the number of fixed or aggregated problem variables"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNFixedVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets variables of the original problem along with the numbers of different variable types; data may become invalid"]
    #[doc = "  after a call to SCIPchgVarType()"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetOrigVarsData(
        scip: *mut SCIP,
        vars: *mut *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
        nbinvars: *mut ::std::os::raw::c_int,
        nintvars: *mut ::std::os::raw::c_int,
        nimplvars: *mut ::std::os::raw::c_int,
        ncontvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets array with original problem variables; data may become invalid after"]
    #[doc = "  a call to SCIPchgVarType()"]
    #[doc = ""]
    #[doc = "  @return an array with original problem variables; data may become invalid after"]
    #[doc = "          a call to SCIPchgVarType()"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetOrigVars(scip: *mut SCIP) -> *mut *mut SCIP_VAR;
}
extern "C" {
    #[doc = " gets number of original problem variables"]
    #[doc = ""]
    #[doc = "  @return the number of original problem variables"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of binary variables in the original problem"]
    #[doc = ""]
    #[doc = "  @return the number of binary variables in the original problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigBinVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of integer variables in the original problem"]
    #[doc = ""]
    #[doc = "  @return the number of integer variables in the original problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigIntVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of implicit integer variables in the original problem"]
    #[doc = ""]
    #[doc = "  @return the number of implicit integer variables in the original problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigImplVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of continuous variables in the original problem"]
    #[doc = ""]
    #[doc = "  @return the number of continuous variables in the original problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigContVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of all problem variables created during creation and solving of problem;"]
    #[doc = "  this includes also variables that were deleted in the meantime"]
    #[doc = ""]
    #[doc = "  @return the number of all problem variables created during creation and solving of problem;"]
    #[doc = "          this includes also variables that were deleted in the meantime"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNTotalVars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets variables of the original or transformed problem along with the numbers of different variable types;"]
    #[doc = "  the returned problem space (original or transformed) corresponds to the given solution;"]
    #[doc = "  data may become invalid after calls to SCIPchgVarType(), SCIPfixVar(), SCIPaggregateVars(), and"]
    #[doc = "  SCIPmultiaggregateVar()"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetSolVarsData(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        vars: *mut *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
        nbinvars: *mut ::std::os::raw::c_int,
        nintvars: *mut ::std::os::raw::c_int,
        nimplvars: *mut ::std::os::raw::c_int,
        ncontvars: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns variable of given name in the problem, or NULL if not existing"]
    #[doc = ""]
    #[doc = "  @return variable of given name in the problem, or NULL if not existing"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPfindVar(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_VAR;
}
extern "C" {
    #[doc = " returns TRUE iff all potential variables exist in the problem, and FALSE, if there may be additional variables,"]
    #[doc = "  that will be added in pricing and improve the objective value"]
    #[doc = ""]
    #[doc = "  @return TRUE, if all potential variables exist in the problem; FALSE, otherwise"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPallVarsInProb(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " adds constraint to the problem; if constraint is only valid locally, it is added to the local subproblem of the"]
    #[doc = "  current node (and all of its subnodes); otherwise it is added to the global problem;"]
    #[doc = "  if a local constraint is added at the root node, it is automatically upgraded into a global constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPaddCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " globally removes constraint from all subproblems; removes constraint from the constraint set change data of the"]
    #[doc = "  node, where it was added, or from the problem, if it was a problem constraint"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPdelCons(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns original constraint of given name in the problem, or NULL if not existing"]
    #[doc = ""]
    #[doc = "  @return original constraint of given name in the problem, or NULL if not existing"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPfindOrigCons(scip: *mut SCIP, name: *const ::std::os::raw::c_char)
        -> *mut SCIP_CONS;
}
extern "C" {
    #[doc = " returns constraint of given name in the problem, or NULL if not existing"]
    #[doc = ""]
    #[doc = "  @return constraint of given name in the problem, or NULL if not existing"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPfindCons(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_CONS;
}
extern "C" {
    #[doc = " gets number of upgraded constraints"]
    #[doc = ""]
    #[doc = "  @return number of upgraded constraints"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNUpgrConss(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets total number of globally valid constraints currently in the problem"]
    #[doc = ""]
    #[doc = "  @return total number of globally valid constraints currently in the problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNConss(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of globally valid constraints currently in the problem"]
    #[doc = ""]
    #[doc = "  @return array of globally valid constraints currently in the problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @warning If your are using the method SCIPaddCons(), it can happen that the internal constraint array (which is"]
    #[doc = "           accessed via this method) gets resized. This can invalid the pointer which is returned by this method."]
    pub fn SCIPgetConss(scip: *mut SCIP) -> *mut *mut SCIP_CONS;
}
extern "C" {
    #[doc = " gets total number of constraints in the original problem"]
    #[doc = ""]
    #[doc = "  @return total number of constraints in the original problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNOrigConss(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of constraints in the original problem"]
    #[doc = ""]
    #[doc = "  @return array of constraints in the original problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetOrigConss(scip: *mut SCIP) -> *mut *mut SCIP_CONS;
}
extern "C" {
    #[doc = " computes the number of check constraint in the current node (loop over all constraint handler and cumulates the"]
    #[doc = "  number of check constraints)"]
    #[doc = ""]
    #[doc = "  @return returns the number of check constraints"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNCheckConss(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " adds a conflict to a given node or globally to the problem if @p node == NULL."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note this method will release the constraint"]
    pub fn SCIPaddConflict(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        cons: *mut SCIP_CONS,
        validnode: *mut SCIP_NODE,
        conftype: SCIP_CONFTYPE,
        iscutoffinvolved: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " removes all conflicts depending on an old cutoff bound if the improvement of the incumbent is good enough"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPclearConflictStore(scip: *mut SCIP, event: *mut SCIP_EVENT) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds constraint to the given node (and all of its subnodes), even if it is a global constraint;"]
    #[doc = "  It is sometimes desirable to add the constraint to a more local node (i.e., a node of larger depth) even if"]
    #[doc = "  the constraint is also valid higher in the tree, for example, if one wants to produce a constraint which is"]
    #[doc = "  only active in a small part of the tree although it is valid in a larger part."]
    #[doc = "  In this case, one should pass the more global node where the constraint is valid as \"validnode\"."]
    #[doc = "  Note that the same constraint cannot be added twice to the branching tree with different \"validnode\" parameters."]
    #[doc = "  If the constraint is valid at the same node as it is inserted (the usual case), one should pass NULL as \"validnode\"."]
    #[doc = "  If the \"validnode\" is the root node, it is automatically upgraded into a global constraint, but still only added to"]
    #[doc = "  the given node. If a local constraint is added to the root node, it is added to the global problem instead."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddConsNode(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        cons: *mut SCIP_CONS,
        validnode: *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds constraint locally to the current node (and all of its subnodes), even if it is a global constraint;"]
    #[doc = "  It is sometimes desirable to add the constraint to a more local node (i.e., a node of larger depth) even if"]
    #[doc = "  the constraint is also valid higher in the tree, for example, if one wants to produce a constraint which is"]
    #[doc = "  only active in a small part of the tree although it is valid in a larger part."]
    #[doc = ""]
    #[doc = "  If the constraint is valid at the same node as it is inserted (the usual case), one should pass NULL as \"validnode\"."]
    #[doc = "  If the \"validnode\" is the root node, it is automatically upgraded into a global constraint, but still only added to"]
    #[doc = "  the given node. If a local constraint is added to the root node, it is added to the global problem instead."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note The same constraint cannot be added twice to the branching tree with different \"validnode\" parameters. This is"]
    #[doc = "        the case due internal data structures and performance issues. In such a case you should try to realize your"]
    #[doc = "        issue using the method SCIPdisableCons() and SCIPenableCons() and control these via the event system of SCIP."]
    pub fn SCIPaddConsLocal(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        validnode: *mut SCIP_NODE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " disables constraint's separation, enforcing, and propagation capabilities at the given node (and all subnodes);"]
    #[doc = "  if the method is called at the root node, the constraint is globally deleted from the problem;"]
    #[doc = "  the constraint deletion is being remembered at the given node, s.t. after leaving the node's subtree, the constraint"]
    #[doc = "  is automatically enabled again, and after entering the node's subtree, it is automatically disabled;"]
    #[doc = "  this may improve performance because redundant checks on this constraint are avoided, but it consumes memory;"]
    #[doc = "  alternatively, use SCIPdisableCons()"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPdelConsNode(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        cons: *mut SCIP_CONS,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " disables constraint's separation, enforcing, and propagation capabilities at the current node (and all subnodes);"]
    #[doc = "  if the method is called during problem modification or at the root node, the constraint is globally deleted from"]
    #[doc = "  the problem;"]
    #[doc = "  the constraint deletion is being remembered at the current node, s.t. after leaving the current subtree, the"]
    #[doc = "  constraint is automatically enabled again, and after reentering the current node's subtree, it is automatically"]
    #[doc = "  disabled again;"]
    #[doc = "  this may improve performance because redundant checks on this constraint are avoided, but it consumes memory;"]
    #[doc = "  alternatively, use SCIPdisableCons()"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPdelConsLocal(scip: *mut SCIP, cons: *mut SCIP_CONS) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets estimate of best primal solution w.r.t. original problem contained in current subtree"]
    #[doc = ""]
    #[doc = "  @return estimate of best primal solution w.r.t. original problem contained in current subtree"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetLocalOrigEstimate(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets estimate of best primal solution w.r.t. transformed problem contained in current subtree"]
    #[doc = ""]
    #[doc = "  @return estimate of best primal solution w.r.t. transformed problem contained in current subtree"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetLocalTransEstimate(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets dual bound of current node"]
    #[doc = ""]
    #[doc = "  @return dual bound of current node"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetLocalDualbound(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets lower bound of current node in transformed problem"]
    #[doc = ""]
    #[doc = "  @return lower bound  of current node in transformed problem"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetLocalLowerbound(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets dual bound of given node"]
    #[doc = ""]
    #[doc = "  @return dual bound of a given node"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNodeDualbound(scip: *mut SCIP, node: *mut SCIP_NODE) -> f64;
}
extern "C" {
    #[doc = " gets lower bound of given node in transformed problem"]
    #[doc = ""]
    #[doc = "  @return lower bound  of given node in transformed problem"]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNodeLowerbound(scip: *mut SCIP, node: *mut SCIP_NODE) -> f64;
}
extern "C" {
    #[doc = " if given value is tighter (larger for minimization, smaller for maximization) than the current node's dual bound (in"]
    #[doc = "  original problem space), sets the current node's dual bound to the new value"]
    #[doc = ""]
    #[doc = "  @note the given new bound has to be a dual bound, i.e., it has to be valid for the original problem."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPupdateLocalDualbound(scip: *mut SCIP, newbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " if given value is larger than the current node's lower bound (in transformed problem), sets the current node's"]
    #[doc = "  lower bound to the new value"]
    #[doc = ""]
    #[doc = "  @note the given new bound has to be a lower bound, i.e., it has to be valid for the transformed problem."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPupdateLocalLowerbound(scip: *mut SCIP, newbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " if given value is tighter (larger for minimization, smaller for maximization) than the node's dual bound,"]
    #[doc = "  sets the node's dual bound to the new value"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPupdateNodeDualbound(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        newbound: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " if given value is larger than the node's lower bound (in transformed problem), sets the node's lower bound"]
    #[doc = "  to the new value"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPupdateNodeLowerbound(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        newbound: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " change the node selection priority of the given child"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre this method can be called in one of the following stages of the SCIP solving process:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgChildPrio(scip: *mut SCIP, child: *mut SCIP_NODE, priority: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether we are in probing mode; probing mode is activated via SCIPstartProbing() and stopped"]
    #[doc = "  via SCIPendProbing()"]
    #[doc = ""]
    #[doc = "  @return TRUE, if SCIP is currently in probing mode, otherwise FALSE"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPinProbing(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " initiates probing, making methods SCIPnewProbingNode(), SCIPbacktrackProbing(), SCIPchgVarLbProbing(),"]
    #[doc = "  SCIPchgVarUbProbing(), SCIPfixVarProbing(), SCIPpropagateProbing(), and SCIPsolveProbingLP() available"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note The collection of variable statistics is turned off during probing. If these statistics should be collected"]
    #[doc = "        during probing use the method SCIPenableVarHistory() to turn the collection explicitly on."]
    pub fn SCIPstartProbing(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a new probing sub node, whose changes can be undone by backtracking to a higher node in the probing path"]
    #[doc = "  with a call to SCIPbacktrackProbing();"]
    #[doc = "  using a sub node for each set of probing bound changes can improve conflict analysis"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPnewProbingNode(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the current probing depth"]
    #[doc = ""]
    #[doc = "  @return the probing depth, i.e. the number of probing sub nodes existing in the probing path"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetProbingDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " undoes all changes to the problem applied in probing up to the given probing depth;"]
    #[doc = "  the changes of the probing node of the given probing depth are the last ones that remain active;"]
    #[doc = "  changes that were applied before calling SCIPnewProbingNode() cannot be undone"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPbacktrackProbing(
        scip: *mut SCIP,
        probingdepth: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " quits probing and resets bounds and constraints to the focus node's environment"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPendProbing(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " injects a change of variable's lower bound into current probing node; the same can also be achieved with a call to"]
    #[doc = "  SCIPchgVarLb(), but in this case, the bound change would be treated like a deduction instead of a branching decision"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarLbProbing(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " injects a change of variable's upper bound into current probing node; the same can also be achieved with a call to"]
    #[doc = "  SCIPchgVarUb(), but in this case, the bound change would be treated like a deduction instead of a branching decision"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarUbProbing(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets variable's objective value in current probing"]
    #[doc = ""]
    #[doc = "  @return the variable's objective value in current probing."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetVarObjProbing(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " injects a change of variable's bounds into current probing node to fix the variable to the specified value;"]
    #[doc = "  the same can also be achieved with a call to SCIPfixVar(), but in this case, the bound changes would be treated"]
    #[doc = "  like deductions instead of branching decisions"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPfixVarProbing(scip: *mut SCIP, var: *mut SCIP_VAR, fixedval: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes (column) variable's objective value during probing mode"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @pre The variable needs to be a column variable."]
    pub fn SCIPchgVarObjProbing(scip: *mut SCIP, var: *mut SCIP_VAR, newobj: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether the objective function has changed during probing mode"]
    #[doc = ""]
    #[doc = "  @return \\ref TRUE if objective has changed, \\ref FALSE otherwise"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPisObjChangedProbing(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " applies domain propagation on the probing sub problem, that was changed after SCIPstartProbing() was called;"]
    #[doc = "  the propagated domains of the variables can be accessed with the usual bound accessing calls SCIPvarGetLbLocal()"]
    #[doc = "  and SCIPvarGetUbLocal(); the propagation is only valid locally, i.e. the local bounds as well as the changed"]
    #[doc = "  bounds due to SCIPchgVarLbProbing(), SCIPchgVarUbProbing(), and SCIPfixVarProbing() are used for propagation"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPpropagateProbing(
        scip: *mut SCIP,
        maxproprounds: ::std::os::raw::c_int,
        cutoff: *mut ::std::os::raw::c_uint,
        ndomredsfound: *mut ::std::os::raw::c_longlong,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " applies domain propagation on the probing sub problem, that was changed after SCIPstartProbing() was called;"]
    #[doc = "  only propagations of the binary variables fixed at the current probing node that are triggered by the implication"]
    #[doc = "  graph and the clique table are applied;"]
    #[doc = "  the propagated domains of the variables can be accessed with the usual bound accessing calls SCIPvarGetLbLocal()"]
    #[doc = "  and SCIPvarGetUbLocal(); the propagation is only valid locally, i.e. the local bounds as well as the changed"]
    #[doc = "  bounds due to SCIPchgVarLbProbing(), SCIPchgVarUbProbing(), and SCIPfixVarProbing() are used for propagation"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPpropagateProbingImplications(
        scip: *mut SCIP,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " solves the LP at the current probing node (cannot be applied at preprocessing stage);"]
    #[doc = "  no separation or pricing is applied"]
    #[doc = ""]
    #[doc = "  The LP has to be constructed before (you can use SCIPisLPConstructed() or SCIPconstructLP())."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsolveProbingLP(
        scip: *mut SCIP,
        itlim: ::std::os::raw::c_int,
        lperror: *mut ::std::os::raw::c_uint,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " solves the LP at the current probing node (cannot be applied at preprocessing stage) and applies pricing"]
    #[doc = "  until the LP is solved to optimality; no separation is applied"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed . See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsolveProbingLPWithPricing(
        scip: *mut SCIP,
        pretendroot: ::std::os::raw::c_uint,
        displayinfo: ::std::os::raw::c_uint,
        maxpricerounds: ::std::os::raw::c_int,
        lperror: *mut ::std::os::raw::c_uint,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the LP state for the current probing node"]
    #[doc = ""]
    #[doc = "  @note state and norms are stored at the node and later released by SCIP; therefore, the pointers are set"]
    #[doc = "        to NULL by the method"]
    #[doc = ""]
    #[doc = "  @note the pointers to state and norms must not be NULL; however, they may point to a NULL pointer if the"]
    #[doc = "        respective information should not be set"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetProbingLPState(
        scip: *mut SCIP,
        lpistate: *mut *mut SCIP_LPISTATE,
        lpinorms: *mut *mut SCIP_LPINORMS,
        primalfeas: ::std::os::raw::c_uint,
        dualfeas: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a row to the LP in the current probing node"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPaddRowProbing(scip: *mut SCIP, row: *mut SCIP_ROW) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " applies the cuts in the separation storage to the LP and clears the storage afterwards;"]
    #[doc = "  this method can only be applied during probing; the user should resolve the probing LP afterwards"]
    #[doc = "  in order to get a new solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPapplyCutsProbing(
        scip: *mut SCIP,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " solves relaxation(s) at the current probing node (cannot be applied at preprocessing stage);"]
    #[doc = "  no separation or pricing is applied"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsolveProbingRelax(
        scip: *mut SCIP,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " print statistics of probing"]
    pub fn SCIPsnprintfProbingStats(
        scip: *mut SCIP,
        strbuf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " stores the candidate score and preferred rounding direction for a candidate variable"]
    pub fn SCIPgetDivesetScore(
        scip: *mut SCIP,
        diveset: *mut SCIP_DIVESET,
        divetype: SCIP_DIVETYPE,
        divecand: *mut SCIP_VAR,
        divecandsol: f64,
        divecandfrac: f64,
        candscore: *mut f64,
        roundup: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " update diveset LP statistics, should be called after every LP solved by this diving heuristic"]
    pub fn SCIPupdateDivesetLPStats(
        scip: *mut SCIP,
        diveset: *mut SCIP_DIVESET,
        niterstoadd: ::std::os::raw::c_longlong,
        divecontext: SCIP_DIVECONTEXT,
    );
}
extern "C" {
    #[doc = " update diveset statistics and global diveset statistics"]
    pub fn SCIPupdateDivesetStats(
        scip: *mut SCIP,
        diveset: *mut SCIP_DIVESET,
        nprobingnodes: ::std::os::raw::c_int,
        nbacktracks: ::std::os::raw::c_int,
        nsolsfound: ::std::os::raw::c_longlong,
        nbestsolsfound: ::std::os::raw::c_longlong,
        nconflictsfound: ::std::os::raw::c_longlong,
        leavewassol: ::std::os::raw::c_uint,
        divecontext: SCIP_DIVECONTEXT,
    );
}
extern "C" {
    #[doc = " enforces a probing/diving solution by suggesting bound changes that maximize the score w.r.t. the current diving settings"]
    #[doc = ""]
    #[doc = "  the process is guided by the enforcement priorities of the constraint handlers and the scoring mechanism provided by"]
    #[doc = "  the dive set."]
    #[doc = "  Constraint handlers may suggest diving bound changes in decreasing order of their enforcement priority, based on the"]
    #[doc = "  solution values in the solution @p sol and the current local bounds of the variables. A diving bound change"]
    #[doc = "  is a triple (variable,branching direction,value) and is used inside SCIPperformGenericDivingAlgorithm()."]
    #[doc = ""]
    #[doc = "  After a successful call, SCIP holds two arrays of suggested dive bound changes, one for the preferred child"]
    #[doc = "  and one for the alternative."]
    #[doc = ""]
    #[doc = "  @see SCIPgetDiveBoundChangeData() for retrieving the dive bound change suggestions."]
    #[doc = ""]
    #[doc = "  The method stops after the first constraint handler was successful"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetDiveBoundChanges(
        scip: *mut SCIP,
        diveset: *mut SCIP_DIVESET,
        sol: *mut SCIP_SOL,
        success: *mut ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a diving bound change to the diving bound change storage of SCIP together with the information if this is a"]
    #[doc = "  bound change for the preferred direction or not"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPaddDiveBoundChange(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
        value: f64,
        preferred: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get the dive bound change data for the preferred or the alternative direction"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetDiveBoundChangeData(
        scip: *mut SCIP,
        variables: *mut *mut *mut SCIP_VAR,
        directions: *mut *mut SCIP_BRANCHDIR,
        values: *mut *mut f64,
        ndivebdchgs: *mut ::std::os::raw::c_int,
        preferred: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " clear the dive bound change data structures"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPclearDiveBoundChanges(scip: *mut SCIP);
}
extern "C" {
    #[doc = " creates a propagator and includes it in SCIP."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  @note method has all propagator callbacks as arguments and is thus changed every time a new"]
    #[doc = "        callback is added in future releases; consider using SCIPincludePropBasic() and setter functions"]
    #[doc = "        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeProp(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        delay: ::std::os::raw::c_uint,
        timingmask: SCIP_PROPTIMING,
        presolpriority: ::std::os::raw::c_int,
        presolmaxrounds: ::std::os::raw::c_int,
        presoltiming: SCIP_PRESOLTIMING,
        propcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propinitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propexitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
        propexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                restart: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        proppresol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                nrounds: ::std::os::raw::c_int,
                presoltiming: SCIP_PRESOLTIMING,
                nnewfixedvars: ::std::os::raw::c_int,
                nnewaggrvars: ::std::os::raw::c_int,
                nnewchgvartypes: ::std::os::raw::c_int,
                nnewchgbds: ::std::os::raw::c_int,
                nnewholes: ::std::os::raw::c_int,
                nnewdelconss: ::std::os::raw::c_int,
                nnewaddconss: ::std::os::raw::c_int,
                nnewupgdconss: ::std::os::raw::c_int,
                nnewchgcoefs: ::std::os::raw::c_int,
                nnewchgsides: ::std::os::raw::c_int,
                nfixedvars: *mut ::std::os::raw::c_int,
                naggrvars: *mut ::std::os::raw::c_int,
                nchgvartypes: *mut ::std::os::raw::c_int,
                nchgbds: *mut ::std::os::raw::c_int,
                naddholes: *mut ::std::os::raw::c_int,
                ndelconss: *mut ::std::os::raw::c_int,
                naddconss: *mut ::std::os::raw::c_int,
                nupgdconss: *mut ::std::os::raw::c_int,
                nchgcoefs: *mut ::std::os::raw::c_int,
                nchgsides: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        propexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                proptiming: SCIP_PROPTIMING,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        propresprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                infervar: *mut SCIP_VAR,
                inferinfo: ::std::os::raw::c_int,
                boundtype: SCIP_BOUNDTYPE,
                bdchgidx: *mut SCIP_BDCHGIDX,
                relaxedbd: f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        propdata: *mut SCIP_PROPDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a propagator and includes it in SCIP. All non-fundamental (or optional) callbacks will be set to NULL."]
    #[doc = "  Optional callbacks can be set via specific setter functions, see SCIPsetPropInit(), SCIPsetPropExit(),"]
    #[doc = "  SCIPsetPropCopy(), SCIPsetPropFree(), SCIPsetPropInitsol(), SCIPsetPropExitsol(),"]
    #[doc = "  SCIPsetPropInitpre(), SCIPsetPropExitpre(), SCIPsetPropPresol(), and SCIPsetPropResprop()."]
    #[doc = ""]
    #[doc = "  @note if you want to set all callbacks with a single method call, consider using SCIPincludeProp() instead"]
    pub fn SCIPincludePropBasic(
        scip: *mut SCIP,
        propptr: *mut *mut SCIP_PROP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        delay: ::std::os::raw::c_uint,
        timingmask: SCIP_PROPTIMING,
        propexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                proptiming: SCIP_PROPTIMING,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        propdata: *mut SCIP_PROPDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of propagator"]
    pub fn SCIPsetPropCopy(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of propagator"]
    pub fn SCIPsetPropFree(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of propagator"]
    pub fn SCIPsetPropInit(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of propagator"]
    pub fn SCIPsetPropExit(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of propagator"]
    pub fn SCIPsetPropInitsol(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of propagator"]
    pub fn SCIPsetPropExitsol(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propexitsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                restart: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets preprocessing initialization method of propagator"]
    pub fn SCIPsetPropInitpre(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propinitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets preprocessing deinitialization method of propagator"]
    pub fn SCIPsetPropExitpre(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propexitpre: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, prop: *mut SCIP_PROP) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets presolving method of propagator"]
    pub fn SCIPsetPropPresol(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        proppresol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                nrounds: ::std::os::raw::c_int,
                presoltiming: SCIP_PRESOLTIMING,
                nnewfixedvars: ::std::os::raw::c_int,
                nnewaggrvars: ::std::os::raw::c_int,
                nnewchgvartypes: ::std::os::raw::c_int,
                nnewchgbds: ::std::os::raw::c_int,
                nnewholes: ::std::os::raw::c_int,
                nnewdelconss: ::std::os::raw::c_int,
                nnewaddconss: ::std::os::raw::c_int,
                nnewupgdconss: ::std::os::raw::c_int,
                nnewchgcoefs: ::std::os::raw::c_int,
                nnewchgsides: ::std::os::raw::c_int,
                nfixedvars: *mut ::std::os::raw::c_int,
                naggrvars: *mut ::std::os::raw::c_int,
                nchgvartypes: *mut ::std::os::raw::c_int,
                nchgbds: *mut ::std::os::raw::c_int,
                naddholes: *mut ::std::os::raw::c_int,
                ndelconss: *mut ::std::os::raw::c_int,
                naddconss: *mut ::std::os::raw::c_int,
                nupgdconss: *mut ::std::os::raw::c_int,
                nchgcoefs: *mut ::std::os::raw::c_int,
                nchgsides: *mut ::std::os::raw::c_int,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        presolpriority: ::std::os::raw::c_int,
        presolmaxrounds: ::std::os::raw::c_int,
        presoltiming: SCIP_PRESOLTIMING,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets propagation conflict resolving callback of propagator"]
    pub fn SCIPsetPropResprop(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        propresprop: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                prop: *mut SCIP_PROP,
                infervar: *mut SCIP_VAR,
                inferinfo: ::std::os::raw::c_int,
                boundtype: SCIP_BOUNDTYPE,
                bdchgidx: *mut SCIP_BDCHGIDX,
                relaxedbd: f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the propagator of the given name, or NULL if not existing"]
    pub fn SCIPfindProp(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_PROP;
}
extern "C" {
    #[doc = " returns the array of currently available propagators"]
    pub fn SCIPgetProps(scip: *mut SCIP) -> *mut *mut SCIP_PROP;
}
extern "C" {
    #[doc = " returns the number of currently available propagators"]
    pub fn SCIPgetNProps(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a propagator"]
    pub fn SCIPsetPropPriority(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the presolving priority of a propagator"]
    pub fn SCIPsetPropPresolPriority(
        scip: *mut SCIP,
        prop: *mut SCIP_PROP,
        presolpriority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and initializes a random number generator"]
    #[doc = ""]
    #[doc = "  @note The initial seed is changed using SCIPinitializeRandomSeed()"]
    pub fn SCIPcreateRandom(
        scip: *mut SCIP,
        randnumgen: *mut *mut SCIP_RANDNUMGEN,
        initialseed: ::std::os::raw::c_uint,
        useglobalseed: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a random number generator"]
    pub fn SCIPfreeRandom(scip: *mut SCIP, randnumgen: *mut *mut SCIP_RANDNUMGEN);
}
extern "C" {
    #[doc = " initializes a random number generator with a given seed"]
    #[doc = ""]
    #[doc = "  @note The seed is changed using SCIPinitializeRandomSeed()"]
    pub fn SCIPsetRandomSeed(
        scip: *mut SCIP,
        randnumgen: *mut SCIP_RANDNUMGEN,
        seed: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " modifies an initial seed value with the global shift of random seeds"]
    pub fn SCIPinitializeRandomSeed(
        scip: *mut SCIP,
        initialseedvalue: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " creates a reader and includes it in SCIP"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note method has all reader callbacks as arguments and is thus changed every time a new callback is added"]
    #[doc = "        in future releases; consider using SCIPincludeReaderBasic() and setter functions"]
    #[doc = "        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeReader(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        extension: *const ::std::os::raw::c_char,
        readercopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, reader: *mut SCIP_READER) -> SCIP_RETCODE,
        >,
        readerfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, reader: *mut SCIP_READER) -> SCIP_RETCODE,
        >,
        readerread: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                reader: *mut SCIP_READER,
                filename: *const ::std::os::raw::c_char,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        readerwrite: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                reader: *mut SCIP_READER,
                file: *mut FILE,
                name: *const ::std::os::raw::c_char,
                probdata: *mut SCIP_PROBDATA,
                transformed: ::std::os::raw::c_uint,
                objsense: SCIP_OBJSENSE,
                objscale: f64,
                objoffset: f64,
                vars: *mut *mut SCIP_VAR,
                nvars: ::std::os::raw::c_int,
                nbinvars: ::std::os::raw::c_int,
                nintvars: ::std::os::raw::c_int,
                nimplvars: ::std::os::raw::c_int,
                ncontvars: ::std::os::raw::c_int,
                fixedvars: *mut *mut SCIP_VAR,
                nfixedvars: ::std::os::raw::c_int,
                startnvars: ::std::os::raw::c_int,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                maxnconss: ::std::os::raw::c_int,
                startnconss: ::std::os::raw::c_int,
                genericnames: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        readerdata: *mut SCIP_READERDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a reader and includes it in SCIP. All non-fundamental (or optional) callbacks will be set to NULL."]
    #[doc = "  Optional callbacks can be set via specific setter functions, see"]
    #[doc = "  SCIPsetReaderCopy(), SCIPsetReaderFree(), SCIPsetReaderRead(), SCIPsetReaderWrite()."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note if you want to set all callbacks with a single method call, consider using SCIPincludeReader() instead"]
    pub fn SCIPincludeReaderBasic(
        scip: *mut SCIP,
        readerptr: *mut *mut SCIP_READER,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        extension: *const ::std::os::raw::c_char,
        readerdata: *mut SCIP_READERDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set copy method of reader"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetReaderCopy(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        readercopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, reader: *mut SCIP_READER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set deinitialization method of reader"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetReaderFree(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        readerfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, reader: *mut SCIP_READER) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set read method of reader"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetReaderRead(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        readerread: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                reader: *mut SCIP_READER,
                filename: *const ::std::os::raw::c_char,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set write method of reader"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPsetReaderWrite(
        scip: *mut SCIP,
        reader: *mut SCIP_READER,
        readerwrite: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                reader: *mut SCIP_READER,
                file: *mut FILE,
                name: *const ::std::os::raw::c_char,
                probdata: *mut SCIP_PROBDATA,
                transformed: ::std::os::raw::c_uint,
                objsense: SCIP_OBJSENSE,
                objscale: f64,
                objoffset: f64,
                vars: *mut *mut SCIP_VAR,
                nvars: ::std::os::raw::c_int,
                nbinvars: ::std::os::raw::c_int,
                nintvars: ::std::os::raw::c_int,
                nimplvars: ::std::os::raw::c_int,
                ncontvars: ::std::os::raw::c_int,
                fixedvars: *mut *mut SCIP_VAR,
                nfixedvars: ::std::os::raw::c_int,
                startnvars: ::std::os::raw::c_int,
                conss: *mut *mut SCIP_CONS,
                nconss: ::std::os::raw::c_int,
                maxnconss: ::std::os::raw::c_int,
                startnconss: ::std::os::raw::c_int,
                genericnames: ::std::os::raw::c_uint,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the reader of the given name, or NULL if not existing"]
    pub fn SCIPfindReader(scip: *mut SCIP, name: *const ::std::os::raw::c_char)
        -> *mut SCIP_READER;
}
extern "C" {
    #[doc = " returns the array of currently available readers"]
    pub fn SCIPgetReaders(scip: *mut SCIP) -> *mut *mut SCIP_READER;
}
extern "C" {
    #[doc = " returns the number of currently available readers"]
    pub fn SCIPgetNReaders(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates a relaxation handler and includes it in SCIP"]
    #[doc = ""]
    #[doc = "  @note method has all relaxation handler callbacks as arguments and is thus changed every time a new"]
    #[doc = "        callback is added"]
    #[doc = "        in future releases; consider using SCIPincludeRelaxBasic() and setter functions"]
    #[doc = "        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeRelax(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        relaxcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
        relaxfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
        relaxinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
        relaxexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
        relaxinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
        relaxexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
        relaxexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                relax: *mut SCIP_RELAX,
                lowerbound: *mut f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        relaxdata: *mut SCIP_RELAXDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a relaxation handler and includes it in SCIP. All non fundamental"]
    #[doc = "  (or optional) callbacks as, e.g., init and exit callbacks, will be set to NULL."]
    #[doc = "  Optional callbacks can be set via specific setter functions, see SCIPsetRelaxInit(), SCIPsetRelaxExit(),"]
    #[doc = "  SCIPsetRelaxCopy(), SCIPsetRelaxFree(), SCIPsetRelaxInitsol(), and SCIPsetRelaxExitsol()"]
    #[doc = ""]
    #[doc = "  @note if you want to set all callbacks with a single method call, consider using SCIPincludeRelax() instead"]
    pub fn SCIPincludeRelaxBasic(
        scip: *mut SCIP,
        relaxptr: *mut *mut SCIP_RELAX,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        relaxexec: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                relax: *mut SCIP_RELAX,
                lowerbound: *mut f64,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        relaxdata: *mut SCIP_RELAXDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of relaxation handler"]
    pub fn SCIPsetRelaxCopy(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        relaxcopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of relaxation handler"]
    pub fn SCIPsetRelaxFree(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        relaxfree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of relaxation handler"]
    pub fn SCIPsetRelaxInit(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        relaxinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of relaxation handler"]
    pub fn SCIPsetRelaxExit(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        relaxexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of relaxation handler"]
    pub fn SCIPsetRelaxInitsol(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        relaxinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of relaxation handler"]
    pub fn SCIPsetRelaxExitsol(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        relaxexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the relaxation handler of the given name, or NULL if not existing"]
    pub fn SCIPfindRelax(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_RELAX;
}
extern "C" {
    #[doc = " returns the array of currently available relaxation handlers"]
    pub fn SCIPgetRelaxs(scip: *mut SCIP) -> *mut *mut SCIP_RELAX;
}
extern "C" {
    #[doc = " returns the number of currently available relaxation handlers"]
    pub fn SCIPgetNRelaxs(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a relaxation handler"]
    pub fn SCIPsetRelaxPriority(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " return the ids of child nodes stored in the reoptimization tree"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetReoptChildIDs(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        ids: *mut ::std::os::raw::c_uint,
        mem: ::std::os::raw::c_int,
        nids: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " return the ids of all leave nodes store in the reoptimization tree induced by the given node"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetReoptLeaveIDs(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        ids: *mut ::std::os::raw::c_uint,
        mem: ::std::os::raw::c_int,
        nids: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the number of nodes in the reoptimization tree induced by @p node; if @p node == NULL, the method"]
    #[doc = "  returns the number of nodes of the whole reoptimization tree."]
    pub fn SCIPgetNReoptnodes(scip: *mut SCIP, node: *mut SCIP_NODE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the number of leave nodes of the subtree induced by @p node; if @p node == NULL, the method"]
    #[doc = "  returns the number of leaf nodes of the whole reoptimization tree."]
    pub fn SCIPgetNReoptLeaves(scip: *mut SCIP, node: *mut SCIP_NODE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the node of the reoptimization tree corresponding to the unique @p id"]
    pub fn SCIPgetReoptnode(scip: *mut SCIP, id: ::std::os::raw::c_uint) -> *mut SCIP_REOPTNODE;
}
extern "C" {
    #[doc = " add a variable bound change to a given reoptnode"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPaddReoptnodeBndchg(
        scip: *mut SCIP,
        reoptnode: *mut SCIP_REOPTNODE,
        var: *mut SCIP_VAR,
        bound: f64,
        boundtype: SCIP_BOUNDTYPE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " set the @p representation as the new search frontier"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPsetReoptCompression(
        scip: *mut SCIP,
        representation: *mut *mut SCIP_REOPTNODE,
        nrepresentatives: ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " add stored constraint to a reoptimization node"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPaddReoptnodeCons(
        scip: *mut SCIP,
        reoptnode: *mut SCIP_REOPTNODE,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        boundtypes: *mut SCIP_BOUNDTYPE,
        lhs: f64,
        rhs: f64,
        nvars: ::std::os::raw::c_int,
        constype: REOPT_CONSTYPE,
        linear: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " return the branching path stored in the reoptree at ID id"]
    pub fn SCIPgetReoptnodePath(
        scip: *mut SCIP,
        reoptnode: *mut SCIP_REOPTNODE,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        boundtypes: *mut SCIP_BOUNDTYPE,
        mem: ::std::os::raw::c_int,
        nvars: *mut ::std::os::raw::c_int,
        nafterdualvars: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " initialize a set of empty reoptimization nodes"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPinitRepresentation(
        scip: *mut SCIP,
        representatives: *mut *mut SCIP_REOPTNODE,
        nrepresentatives: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reset a set of initialized reoptimization nodes"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPresetRepresentation(
        scip: *mut SCIP,
        representatives: *mut *mut SCIP_REOPTNODE,
        nrepresentatives: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " free a set of initialized reoptimization nodes"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPfreeRepresentation(
        scip: *mut SCIP,
        representatives: *mut *mut SCIP_REOPTNODE,
        nrepresentatives: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reactivate the given @p reoptnode and split them into several nodes if necessary"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPapplyReopt(
        scip: *mut SCIP,
        reoptnode: *mut SCIP_REOPTNODE,
        id: ::std::os::raw::c_uint,
        estimate: f64,
        childnodes: *mut *mut SCIP_NODE,
        ncreatedchilds: *mut ::std::os::raw::c_int,
        naddedconss: *mut ::std::os::raw::c_int,
        childnodessize: ::std::os::raw::c_int,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " remove the stored information about bound changes based in dual information"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPresetReoptnodeDualcons(scip: *mut SCIP, node: *mut SCIP_NODE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " splits the root into several nodes and moves the child nodes of the root to one of the created nodes"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsplitReoptRoot(
        scip: *mut SCIP,
        ncreatedchilds: *mut ::std::os::raw::c_int,
        naddedconss: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns if a node should be reoptimized"]
    pub fn SCIPreoptimizeNode(scip: *mut SCIP, node: *mut SCIP_NODE) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " deletes the given reoptimization node"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPdeleteReoptnode(
        scip: *mut SCIP,
        reoptnode: *mut *mut SCIP_REOPTNODE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " return the similarity between two objective functions"]
    pub fn SCIPgetReoptSimilarity(
        scip: *mut SCIP,
        run1: ::std::os::raw::c_int,
        run2: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " check the changes of the variable coefficient in the objective function"]
    pub fn SCIPgetVarCoefChg(
        scip: *mut SCIP,
        varidx: ::std::os::raw::c_int,
        negated: *mut ::std::os::raw::c_uint,
        entering: *mut ::std::os::raw::c_uint,
        leaving: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " creates a separator and includes it in SCIP."]
    #[doc = ""]
    #[doc = "  @note method has all separator callbacks as arguments and is thus changed every time a new"]
    #[doc = "        callback is added"]
    #[doc = "        in future releases; consider using SCIPincludeSepaBasic() and setter functions"]
    #[doc = "        if you seek for a method which is less likely to change in future releases"]
    pub fn SCIPincludeSepa(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        maxbounddist: f64,
        usessubscip: ::std::os::raw::c_uint,
        delay: ::std::os::raw::c_uint,
        sepacopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
        sepafree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
        sepainit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
        sepaexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
        sepainitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
        sepaexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
        sepaexeclp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sepa: *mut SCIP_SEPA,
                result: *mut SCIP_RESULT,
                allowlocal: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        sepaexecsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sepa: *mut SCIP_SEPA,
                sol: *mut SCIP_SOL,
                result: *mut SCIP_RESULT,
                allowlocal: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        sepadata: *mut SCIP_SEPADATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a separator and includes it in SCIP with its most fundamental callbacks. All non-fundamental"]
    #[doc = "  (or optional) callbacks as, e.g., init and exit callbacks, will be set to NULL."]
    #[doc = "  Optional callbacks can be set via specific setter functions, see SCIPsetSepaInit(), SCIPsetSepaFree(),"]
    #[doc = "  SCIPsetSepaInitsol(), SCIPsetSepaExitsol(), SCIPsetSepaCopy(), SCIPsetExit()."]
    #[doc = ""]
    #[doc = "  @note if you want to set all callbacks with a single method call, consider using SCIPincludeSepa() instead"]
    pub fn SCIPincludeSepaBasic(
        scip: *mut SCIP,
        sepa: *mut *mut SCIP_SEPA,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
        freq: ::std::os::raw::c_int,
        maxbounddist: f64,
        usessubscip: ::std::os::raw::c_uint,
        delay: ::std::os::raw::c_uint,
        sepaexeclp: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sepa: *mut SCIP_SEPA,
                result: *mut SCIP_RESULT,
                allowlocal: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        sepaexecsol: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sepa: *mut SCIP_SEPA,
                sol: *mut SCIP_SOL,
                result: *mut SCIP_RESULT,
                allowlocal: ::std::os::raw::c_uint,
            ) -> SCIP_RETCODE,
        >,
        sepadata: *mut SCIP_SEPADATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets copy method of separator"]
    pub fn SCIPsetSepaCopy(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        sepacopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets destructor method of separator"]
    pub fn SCIPsetSepaFree(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        sepafree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets initialization method of separator"]
    pub fn SCIPsetSepaInit(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        sepainit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets deinitialization method of separator"]
    pub fn SCIPsetSepaExit(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        sepaexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process initialization method of separator"]
    pub fn SCIPsetSepaInitsol(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        sepainitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets solving process deinitialization method of separator"]
    pub fn SCIPsetSepaExitsol(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        sepaexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, sepa: *mut SCIP_SEPA) -> SCIP_RETCODE,
        >,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the separator of the given name, or NULL if not existing"]
    pub fn SCIPfindSepa(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_SEPA;
}
extern "C" {
    #[doc = " returns the array of currently available separators"]
    pub fn SCIPgetSepas(scip: *mut SCIP) -> *mut *mut SCIP_SEPA;
}
extern "C" {
    #[doc = " returns the number of currently available separators"]
    pub fn SCIPgetNSepas(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the priority of a separator"]
    pub fn SCIPsetSepaPriority(
        scip: *mut SCIP,
        sepa: *mut SCIP_SEPA,
        priority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets value of minimal efficacy for a cut to enter the LP"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @return value of \"separating/minefficacyroot\" if at root node, otherwise value of \"separating/minefficacy\""]
    pub fn SCIPgetSepaMinEfficacy(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " creates a primal solution, initialized to zero"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a primal solution, initialized to the current LP solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateLPSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a primal solution, initialized to the current NLP solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateNLPSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a primal solution, initialized to the current relaxation solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateRelaxSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a primal solution, initialized to the current pseudo solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreatePseudoSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a primal solution, initialized to the current LP or pseudo solution, depending on whether the LP was solved"]
    #[doc = "  at the current node"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateCurrentSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a partial primal solution, initialized to unknown values"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPcreatePartialSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a primal solution, initialized to unknown values"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateUnknownSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a primal solution living in the original problem space, initialized to zero;"]
    #[doc = "  a solution in original space allows to set original variables to values that would be invalid in the"]
    #[doc = "  transformed problem due to preprocessing fixings or aggregations"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateOrigSol(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        heur: *mut SCIP_HEUR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a copy of a primal solution; note that a copy of a linked solution is also linked and needs to be unlinked"]
    #[doc = "  if it should stay unaffected from changes in the LP or pseudo solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcreateSolCopy(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        sourcesol: *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a copy of a solution in the original primal solution space"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPcreateSolCopyOrig(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        sourcesol: *mut SCIP_SOL,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a copy of a primal solution, thereby replacing infinite fixings of variables by finite values;"]
    #[doc = "  the copy is always defined in the original variable space;"]
    #[doc = "  success indicates whether the objective value of the solution was changed by removing infinite values"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPcreateFiniteSolCopy(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        sourcesol: *mut SCIP_SOL,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees primal CIP solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPfreeSol(scip: *mut SCIP, sol: *mut *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " links a primal solution to the current LP solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPlinkLPSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " links a primal solution to the current NLP solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPlinkNLPSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " links a primal solution to the current relaxation solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPlinkRelaxSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " links a primal solution to the current pseudo solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPlinkPseudoSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " links a primal solution to the current LP or pseudo solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPlinkCurrentSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " clears a primal solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPclearSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " stores solution values of variables in solution's own array"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPunlinkSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets value of variable in primal CIP solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPsetSolVal(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets values of multiple variables in primal CIP solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPsetSolVals(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " increases value of variable in primal CIP solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPincSolVal(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        var: *mut SCIP_VAR,
        incval: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns value of variable in primal CIP solution, or in current LP/pseudo solution"]
    #[doc = ""]
    #[doc = "  @return value of variable in primal CIP solution, or in current LP/pseudo solution"]
    #[doc = ""]
    #[doc = "  @pre In case the solution pointer @p sol is @b NULL, that means it is asked for the LP or pseudo solution, this method"]
    #[doc = "       can only be called if @p scip is in the solving stage \\ref SCIP_STAGE_SOLVING. In any other case, this method"]
    #[doc = "       can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolVal(scip: *mut SCIP, sol: *mut SCIP_SOL, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets values of multiple variables in primal CIP solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolVals(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns objective value of primal CIP solution w.r.t. original problem, or current LP/pseudo objective value"]
    #[doc = ""]
    #[doc = "  @return objective value of primal CIP solution w.r.t. original problem, or current LP/pseudo objective value"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolOrigObj(scip: *mut SCIP, sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " returns transformed objective value of primal CIP solution, or transformed current LP/pseudo objective value"]
    #[doc = ""]
    #[doc = "  @return transformed objective value of primal CIP solution, or transformed current LP/pseudo objective value"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolTransObj(scip: *mut SCIP, sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " recomputes the objective value of an original solution, e.g., when transferring solutions"]
    #[doc = "  from the solution pool (objective coefficients might have changed in the meantime)"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    pub fn SCIPrecomputeSolObj(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " maps original space objective value into transformed objective value"]
    #[doc = ""]
    #[doc = "  @return transformed objective value"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPtransformObj(scip: *mut SCIP, obj: f64) -> f64;
}
extern "C" {
    #[doc = " maps transformed objective value into original space"]
    #[doc = ""]
    #[doc = "  @return objective value into original space"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPretransformObj(scip: *mut SCIP, obj: f64) -> f64;
}
extern "C" {
    #[doc = " gets clock time, when this solution was found"]
    #[doc = ""]
    #[doc = "  @return clock time, when this solution was found"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolTime(scip: *mut SCIP, sol: *mut SCIP_SOL) -> f64;
}
extern "C" {
    #[doc = " gets branch and bound run number, where this solution was found"]
    #[doc = ""]
    #[doc = "  @return branch and bound run number, where this solution was found"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolRunnum(scip: *mut SCIP, sol: *mut SCIP_SOL) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets node number of the specific branch and bound run, where this solution was found"]
    #[doc = ""]
    #[doc = "  @return node number of the specific branch and bound run, where this solution was found"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolNodenum(scip: *mut SCIP, sol: *mut SCIP_SOL) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets heuristic, that found this solution (or NULL if it's from the tree)"]
    #[doc = ""]
    #[doc = "  @return heuristic, that found this solution (or NULL if it's from the tree)"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetSolHeur(scip: *mut SCIP, sol: *mut SCIP_SOL) -> *mut SCIP_HEUR;
}
extern "C" {
    #[doc = " returns whether two given solutions are exactly equal"]
    #[doc = ""]
    #[doc = "  @return returns whether two given solutions are exactly equal"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPareSolsEqual(
        scip: *mut SCIP,
        sol1: *mut SCIP_SOL,
        sol2: *mut SCIP_SOL,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " adjusts solution values of implicit integer variables in handed solution. Solution objective value is not"]
    #[doc = "  deteriorated by this method."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPadjustImplicitSolVals(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        uselprows: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs non-zero variables of solution in original problem space to the given file stream"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre In case the solution pointer @p sol is NULL (askinking for the current LP/pseudo solution), this method can be"]
    #[doc = "       called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = ""]
    #[doc = "  @pre In case the solution pointer @p sol is @b not NULL, this method can be called if @p scip is in one of the"]
    #[doc = "       following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPprintSol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        file: *mut FILE,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs non-zero variables of solution in transformed problem space to file stream"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPprintTransSol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        file: *mut FILE,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs discrete variables of solution in original problem space to the given file stream"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPprintMIPStart(scip: *mut SCIP, sol: *mut SCIP_SOL, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns dual solution value of a constraint"]
    pub fn SCIPgetDualSolVal(
        scip: *mut SCIP,
        cons: *mut SCIP_CONS,
        dualsolval: *mut f64,
        boundconstraint: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " check whether the dual solution is available"]
    #[doc = ""]
    #[doc = " @note This is used when calling \\ref SCIPprintDualSol()"]
    #[doc = ""]
    #[doc = " @return is dual solution available?"]
    #[doc = ""]
    #[doc = " @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPisDualSolAvailable(
        scip: *mut SCIP,
        printreason: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " outputs dual solution from LP solver to file stream"]
    #[doc = ""]
    #[doc = "  @note This only works if no presolving has been performed, which can be checked by calling method \\ref"]
    #[doc = "        SCIPhasPerformedPresolve()."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintDualSol(
        scip: *mut SCIP,
        file: *mut FILE,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs non-zero variables of solution representing a ray in original problem space to file stream"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPprintRay(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        file: *mut FILE,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of feasible primal solutions stored in the solution storage in case the problem is transformed;"]
    #[doc = "  in case the problem stage is SCIP_STAGE_PROBLEM, the number of solution in the original solution candidate"]
    #[doc = "  storage is returned"]
    #[doc = ""]
    #[doc = "  @return number of feasible primal solutions stored in the solution storage in case the problem is transformed; or"]
    #[doc = "          number of solution in the original solution candidate storage if the problem stage is SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNSols(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets array of feasible primal solutions stored in the solution storage in case the problem is transformed; in case"]
    #[doc = "  if the problem stage is in SCIP_STAGE_PROBLEM, it returns the number array of solution candidate stored"]
    #[doc = ""]
    #[doc = "  @return array of feasible primal solutions"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetSols(scip: *mut SCIP) -> *mut *mut SCIP_SOL;
}
extern "C" {
    #[doc = " gets best feasible primal solution found so far if the problem is transformed; in case the problem is in"]
    #[doc = "  SCIP_STAGE_PROBLEM it returns the best solution candidate, or NULL if no solution has been found or the candidate"]
    #[doc = "  store is empty;"]
    #[doc = ""]
    #[doc = "  @return best feasible primal solution so far"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetBestSol(scip: *mut SCIP) -> *mut SCIP_SOL;
}
extern "C" {
    #[doc = " outputs best feasible primal solution found so far to file stream"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREE"]
    pub fn SCIPprintBestSol(
        scip: *mut SCIP,
        file: *mut FILE,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs best feasible primal solution found so far in transformed variables to file stream"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREE"]
    pub fn SCIPprintBestTransSol(
        scip: *mut SCIP,
        file: *mut FILE,
        printzeros: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " try to round given solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIProundSol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " retransforms solution to original problem space"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPretransformSol(scip: *mut SCIP, sol: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reads a given solution file"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPreadSol(scip: *mut SCIP, filename: *const ::std::os::raw::c_char) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " reads a given solution file and store the solution values in the given solution pointer"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPreadSolFile(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
        sol: *mut SCIP_SOL,
        xml: ::std::os::raw::c_uint,
        partial: *mut ::std::os::raw::c_uint,
        error: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds feasible primal solution to solution storage by copying it"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  @note Do not call during propagation, use heur_trysol instead."]
    pub fn SCIPaddSol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        stored: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds primal solution to solution storage, frees the solution afterwards"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  @note Do not call during propagation, use heur_trysol instead."]
    pub fn SCIPaddSolFree(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        stored: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds current LP/pseudo solution to solution storage"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddCurrentSol(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        stored: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks solution for feasibility; if possible, adds it to storage by copying"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note Do not call during propagation, use heur_trysol instead."]
    pub fn SCIPtrySol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        printreason: ::std::os::raw::c_uint,
        completely: ::std::os::raw::c_uint,
        checkbounds: ::std::os::raw::c_uint,
        checkintegrality: ::std::os::raw::c_uint,
        checklprows: ::std::os::raw::c_uint,
        stored: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks primal solution; if feasible, adds it to storage; solution is freed afterwards"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note Do not call during propagation, use heur_trysol instead."]
    pub fn SCIPtrySolFree(
        scip: *mut SCIP,
        sol: *mut *mut SCIP_SOL,
        printreason: ::std::os::raw::c_uint,
        completely: ::std::os::raw::c_uint,
        checkbounds: ::std::os::raw::c_uint,
        checkintegrality: ::std::os::raw::c_uint,
        checklprows: ::std::os::raw::c_uint,
        stored: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks current LP/pseudo solution for feasibility; if possible, adds it to storage"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPtryCurrentSol(
        scip: *mut SCIP,
        heur: *mut SCIP_HEUR,
        printreason: ::std::os::raw::c_uint,
        completely: ::std::os::raw::c_uint,
        checkintegrality: ::std::os::raw::c_uint,
        checklprows: ::std::os::raw::c_uint,
        stored: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns all partial solutions"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetPartialSols(scip: *mut SCIP) -> *mut *mut SCIP_SOL;
}
extern "C" {
    #[doc = " returns number of partial solutions"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPartialSols(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " checks solution for feasibility without adding it to the solution store"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcheckSol(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        printreason: ::std::os::raw::c_uint,
        completely: ::std::os::raw::c_uint,
        checkbounds: ::std::os::raw::c_uint,
        checkintegrality: ::std::os::raw::c_uint,
        checklprows: ::std::os::raw::c_uint,
        feasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " checks solution for feasibility in original problem without adding it to the solution store;"]
    #[doc = "  this method is used to double check a solution in order to validate the presolving process"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPcheckSolOrig(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        feasible: *mut ::std::os::raw::c_uint,
        printreason: ::std::os::raw::c_uint,
        completely: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " update integrality violation of a solution"]
    pub fn SCIPupdateSolIntegralityViolation(scip: *mut SCIP, sol: *mut SCIP_SOL, absviol: f64);
}
extern "C" {
    #[doc = " update bound violation of a solution"]
    pub fn SCIPupdateSolBoundViolation(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        absviol: f64,
        relviol: f64,
    );
}
extern "C" {
    #[doc = " update LP row violation of a solution"]
    pub fn SCIPupdateSolLPRowViolation(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        absviol: f64,
        relviol: f64,
    );
}
extern "C" {
    #[doc = " update constraint violation of a solution"]
    pub fn SCIPupdateSolConsViolation(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        absviol: f64,
        relviol: f64,
    );
}
extern "C" {
    #[doc = " update LP row and constraint violations of a solution"]
    pub fn SCIPupdateSolLPConsViolation(
        scip: *mut SCIP,
        sol: *mut SCIP_SOL,
        absviol: f64,
        relviol: f64,
    );
}
extern "C" {
    #[doc = " allow violation updates"]
    pub fn SCIPactivateSolViolationUpdates(scip: *mut SCIP);
}
extern "C" {
    #[doc = " disallow violation updates"]
    pub fn SCIPdeactivateSolViolationUpdates(scip: *mut SCIP);
}
extern "C" {
    #[doc = " return whether a primal ray is stored that proves unboundedness of the LP relaxation"]
    #[doc = ""]
    #[doc = "  @return return whether a primal ray is stored that proves unboundedness of the LP relaxation"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPhasPrimalRay(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets value of given variable in primal ray causing unboundedness of the LP relaxation;"]
    #[doc = "  should only be called if such a ray is stored (check with SCIPhasPrimalRay())"]
    #[doc = ""]
    #[doc = "  @return value of given variable in primal ray causing unboundedness of the LP relaxation"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetPrimalRayVal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " updates the primal ray thats proves unboundedness"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPupdatePrimalRay(scip: *mut SCIP, primalray: *mut SCIP_SOL) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " initializes solving data structures and transforms problem"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = "       - \\ref SCIP_STAGE_FREE"]
    #[doc = ""]
    #[doc = "  @post When calling this method in the \\ref SCIP_STAGE_PROBLEM stage, the \\SCIP stage is changed to \\ref"]
    #[doc = "        SCIP_STAGE_TRANSFORMED; otherwise, the stage is not changed"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPtransformProb(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " transforms and presolves problem"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = ""]
    #[doc = "  @post After calling this method \\SCIP reaches one of the following stages:"]
    #[doc = "        - \\ref SCIP_STAGE_PRESOLVING if the presolving process was interrupted"]
    #[doc = "        - \\ref SCIP_STAGE_PRESOLVED if the presolving process was finished and did not solve the problem"]
    #[doc = "        - \\ref SCIP_STAGE_SOLVED if the problem was solved during presolving"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPpresolve(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " transforms, presolves, and solves problem"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @post After calling this method \\SCIP reaches one of the following stages depending on if and when the solution"]
    #[doc = "        process was interrupted:"]
    #[doc = ""]
    #[doc = "        - \\ref SCIP_STAGE_PRESOLVING if the solution process was interrupted during presolving"]
    #[doc = "        - \\ref SCIP_STAGE_SOLVING if the solution process was interrupted during the tree search"]
    #[doc = "        - \\ref SCIP_STAGE_SOLVED if the solving process was not interrupted"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPsolve(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " transforms, presolves, and solves problem using additional solvers which emphasize on"]
    #[doc = "  finding solutions."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @post After calling this method \\SCIP reaches one of the following stages depending on if and when the solution"]
    #[doc = "        process was interrupted:"]
    #[doc = "        - \\ref SCIP_STAGE_PRESOLVING if the solution process was interrupted during presolving"]
    #[doc = "        - \\ref SCIP_STAGE_SOLVING if the solution process was interrupted during the tree search"]
    #[doc = "        - \\ref SCIP_STAGE_SOLVED if the solving process was not interrupted"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    #[doc = ""]
    #[doc = "  @deprecated Please use SCIPsolveConcurrent() instead."]
    pub fn SCIPsolveParallel(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " transforms, presolves, and solves problem using additional solvers which emphasize on"]
    #[doc = "  finding solutions."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @post After calling this method \\SCIP reaches one of the following stages depending on if and when the solution"]
    #[doc = "        process was interrupted:"]
    #[doc = "        - \\ref SCIP_STAGE_PRESOLVING if the solution process was interrupted during presolving"]
    #[doc = "        - \\ref SCIP_STAGE_SOLVING if the solution process was interrupted during the tree search"]
    #[doc = "        - \\ref SCIP_STAGE_SOLVED if the solving process was not interrupted"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPsolveConcurrent(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees branch and bound tree and all solution process data; statistics, presolving data and transformed problem is"]
    #[doc = "  preserved"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @post If this method is called in \\SCIP stage \\ref SCIP_STAGE_INIT or \\ref SCIP_STAGE_PROBLEM, the stage of"]
    #[doc = "        \\SCIP is not changed; otherwise, the \\SCIP stage is changed to \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPfreeSolve(scip: *mut SCIP, restart: ::std::os::raw::c_uint) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees branch and bound tree and all solution process data; statistics, presolving data and transformed problem is"]
    #[doc = "  preserved"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @post If this method is called in \\SCIP stage \\ref SCIP_STAGE_INIT or \\ref SCIP_STAGE_PROBLEM, the stage of"]
    #[doc = "        \\SCIP is not changed; otherwise, the \\SCIP stage is changed to \\ref SCIP_STAGE_PRESOLVED."]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPfreeReoptSolve(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees all solution process data including presolving and transformed problem, only original problem is kept"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  @post After calling this method \\SCIP reaches one of the following stages:"]
    #[doc = "        - \\ref SCIP_STAGE_INIT if the method was called from \\SCIP stage \\ref SCIP_STAGE_INIT"]
    #[doc = "        - \\ref SCIP_STAGE_PROBLEM if the method was called from any other of the allowed stages"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPfreeTransform(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " informs \\SCIP that the solving process should be interrupted as soon as possible (e.g., after the current node has"]
    #[doc = "   been solved)"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  @note the \\SCIP stage does not get changed"]
    pub fn SCIPinterruptSolve(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " informs SCIP that the solving process should be restarted as soon as possible (e.g., after the current node has"]
    #[doc = "  been solved)"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note the \\SCIP stage does not get changed"]
    pub fn SCIPrestartSolve(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " include specific heuristics and branching rules for reoptimization"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    pub fn SCIPenableReoptimization(
        scip: *mut SCIP,
        enable: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether reoptimization is enabled or not"]
    pub fn SCIPisReoptEnabled(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns the stored solutions corresponding to a given run"]
    pub fn SCIPgetReoptSolsRun(
        scip: *mut SCIP,
        run: ::std::os::raw::c_int,
        sols: *mut *mut SCIP_SOL,
        allocmem: ::std::os::raw::c_int,
        nsols: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " mark all stored solutions as not updated"]
    pub fn SCIPresetReoptSolMarks(scip: *mut SCIP);
}
extern "C" {
    #[doc = " check if the reoptimization process should be restarted"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcheckReoptRestart(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        restart: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " save bound change based on dual information in the reoptimization tree"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPaddReoptDualBndchg(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        var: *mut SCIP_VAR,
        newbound: f64,
        oldbound: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the optimal solution of the last iteration or NULL of none exists"]
    pub fn SCIPgetReoptLastOptSol(scip: *mut SCIP) -> *mut SCIP_SOL;
}
extern "C" {
    #[doc = " returns the objective coefficent of a given variable in a previous iteration"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetReoptOldObjCoef(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        run: ::std::os::raw::c_int,
        objcoef: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether we are in the restarting phase"]
    #[doc = ""]
    #[doc = "  @return TRUE, if we are in the restarting phase; FALSE, otherwise"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPisInRestart(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets number of branch and bound runs performed, including the current run"]
    #[doc = ""]
    #[doc = "  @return the number of branch and bound runs performed, including the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNRuns(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of reoptimization runs performed, including the current run"]
    #[doc = ""]
    #[doc = "  @return the number of reoptimization runs performed, including the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNReoptRuns(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " add given number to the number of processed nodes in current run and in all runs, including the focus node"]
    #[doc = ""]
    #[doc = "  @return the number of processed nodes in current run, including the focus node"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPaddNNodes(scip: *mut SCIP, nnodes: ::std::os::raw::c_longlong);
}
extern "C" {
    #[doc = " gets number of processed nodes in current run, including the focus node"]
    #[doc = ""]
    #[doc = "  @return the number of processed nodes in current run, including the focus node"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNNodes(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of processed nodes in all runs, including the focus node"]
    #[doc = ""]
    #[doc = "  @return the total number of processed nodes in all runs, including the focus node"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNTotalNodes(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of leaf nodes processed with feasible relaxation solution"]
    #[doc = ""]
    #[doc = " @return number of leaf nodes processed with feasible relaxation solution"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNFeasibleLeaves(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of infeasible leaf nodes processed"]
    #[doc = ""]
    #[doc = " @return number of infeasible leaf nodes processed"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNInfeasibleLeaves(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of processed leaf nodes that hit LP objective limit"]
    #[doc = ""]
    #[doc = " @return number of processed leaf nodes that hit LP objective limit"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNObjlimLeaves(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of global bound changes"]
    #[doc = ""]
    #[doc = " @return number of global bound changes"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNRootboundChgs(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of global bound changes applied in the current run"]
    #[doc = ""]
    #[doc = " @return number of global bound changes"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNRootboundChgsRun(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of times a selected node was from a cut off subtree"]
    #[doc = ""]
    #[doc = "  @return number of times a selected node was from a cut off subtree"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNDelayedCutoffs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of LPs solved so far"]
    #[doc = ""]
    #[doc = "  @return the total number of LPs solved so far"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of iterations used so far in primal and dual simplex and barrier algorithm"]
    #[doc = ""]
    #[doc = "  @return the total number of iterations used so far in primal and dual simplex and barrier algorithm"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of active non-zeros in the current transformed problem"]
    #[doc = ""]
    #[doc = "  @return the number of active non-zeros in the current transformed problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNNZs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of iterations used so far in primal and dual simplex and barrier algorithm for the root node"]
    #[doc = ""]
    #[doc = "  @return the total number of iterations used so far in primal and dual simplex and barrier algorithm for the root node"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNRootLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of iterations used in primal and dual simplex and barrier algorithm for the first LP at the root"]
    #[doc = "  node"]
    #[doc = ""]
    #[doc = "  @return the total number of iterations used in primal and dual simplex and barrier algorithm for the first root LP"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNRootFirstLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of primal LPs solved so far"]
    #[doc = ""]
    #[doc = "  @return the total number of primal LPs solved so far"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPrimalLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of iterations used so far in primal simplex"]
    #[doc = ""]
    #[doc = "  @return total number of iterations used so far in primal simplex"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPrimalLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of dual LPs solved so far"]
    #[doc = ""]
    #[doc = "  @return the total number of dual LPs solved so far"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNDualLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of iterations used so far in dual simplex"]
    #[doc = ""]
    #[doc = "  @return the total number of iterations used so far in dual simplex"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNDualLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of barrier LPs solved so far"]
    #[doc = ""]
    #[doc = "  @return the total number of barrier LPs solved so far"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNBarrierLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of iterations used so far in barrier algorithm"]
    #[doc = ""]
    #[doc = "  @return the total number of iterations used so far in barrier algorithm"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNBarrierLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of LPs solved so far that were resolved from an advanced start basis"]
    #[doc = ""]
    #[doc = "  @return the total number of LPs solved so far that were resolved from an advanced start basis"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNResolveLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of simplex iterations used so far in primal and dual simplex calls where an advanced start basis"]
    #[doc = "  was available"]
    #[doc = ""]
    #[doc = "  @return the total number of simplex iterations used so far in primal and dual simplex calls where an advanced start"]
    #[doc = "          basis was available"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNResolveLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of primal LPs solved so far that were resolved from an advanced start basis"]
    #[doc = ""]
    #[doc = "  @return the total number of primal LPs solved so far that were resolved from an advanced start basis"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPrimalResolveLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of simplex iterations used so far in primal simplex calls where an advanced start basis"]
    #[doc = "  was available"]
    #[doc = ""]
    #[doc = "  @return the total number of simplex iterations used so far in primal simplex calls where an advanced start"]
    #[doc = "          basis was available"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPrimalResolveLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of dual LPs solved so far that were resolved from an advanced start basis"]
    #[doc = ""]
    #[doc = "  @return the total number of dual LPs solved so far that were resolved from an advanced start basis"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNDualResolveLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of simplex iterations used so far in dual simplex calls where an advanced start basis"]
    #[doc = "  was available"]
    #[doc = ""]
    #[doc = "  @return the total number of simplex iterations used so far in dual simplex calls where an advanced start"]
    #[doc = "          basis was available"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNDualResolveLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of LPs solved so far for node relaxations"]
    #[doc = ""]
    #[doc = "  @return the total number of LPs solved so far for node relaxations"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNNodeLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of LPs solved in 0 iterations for node relaxations"]
    #[doc = ""]
    #[doc = "  @return the total number of LPs solved with 0 iteratins for node relaxations"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNNodeZeroIterationLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of simplex iterations used so far for node relaxations"]
    #[doc = ""]
    #[doc = "  @return the total number of simplex iterations used so far for node relaxations"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNNodeLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of LPs solved so far for initial LP in node relaxations"]
    #[doc = ""]
    #[doc = "  @return the total number of LPs solved so far for initial LP in node relaxations"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNNodeInitLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of simplex iterations used so far for initial LP in node relaxations"]
    #[doc = ""]
    #[doc = "  @return the total number of simplex iterations used so far for initial LP in node relaxations"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNNodeInitLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of LPs solved so far during diving and probing"]
    #[doc = ""]
    #[doc = "  @return total number of LPs solved so far during diving and probing"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNDivingLPs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of simplex iterations used so far during diving and probing"]
    #[doc = ""]
    #[doc = "  @return the total number of simplex iterations used so far during diving and probing"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNDivingLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of times, strong branching was called (each call represents solving two LPs)"]
    #[doc = ""]
    #[doc = "  @return the total number of times, strong branching was called (each call represents solving two LPs)"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNStrongbranchs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of simplex iterations used so far in strong branching"]
    #[doc = ""]
    #[doc = "  @return the total number of simplex iterations used so far in strong branching"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNStrongbranchLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of times, strong branching was called at the root node (each call represents solving two LPs)"]
    #[doc = ""]
    #[doc = "  @return the total number of times, strong branching was called at the root node (each call represents solving two LPs)"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNRootStrongbranchs(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of simplex iterations used so far in strong branching at the root node"]
    #[doc = ""]
    #[doc = "  @return the total number of simplex iterations used so far in strong branching at the root node"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNRootStrongbranchLPIterations(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of pricing rounds performed so far at the current node"]
    #[doc = ""]
    #[doc = "  @return the number of pricing rounds performed so far at the current node"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNPriceRounds(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get current number of variables in the pricing store"]
    #[doc = ""]
    #[doc = "  @return the current number of variables in the pricing store"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPricevars(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get total number of pricing variables found so far"]
    #[doc = ""]
    #[doc = "  @return the total number of pricing variables found so far"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPricevarsFound(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get total number of pricing variables applied to the LPs"]
    #[doc = ""]
    #[doc = "  @return the total number of pricing variables applied to the LPs"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNPricevarsApplied(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of separation rounds performed so far at the current node"]
    #[doc = ""]
    #[doc = "  @return the number of separation rounds performed so far at the current node"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNSepaRounds(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get total number of cuts found so far"]
    #[doc = ""]
    #[doc = "  @return the total number of cuts found so far"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNCutsFound(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of cuts found so far in current separation round"]
    #[doc = ""]
    #[doc = "  @return the number of cuts found so far in current separation round"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNCutsFoundRound(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get total number of cuts applied to the LPs"]
    #[doc = ""]
    #[doc = "  @return the total number of cuts applied to the LPs"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNCutsApplied(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get total number of constraints found in conflict analysis (conflict and reconvergence constraints)"]
    #[doc = ""]
    #[doc = "  @return the total number of constraints found in conflict analysis (conflict and reconvergence constraints)"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNConflictConssFound(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get number of conflict constraints found so far at the current node"]
    #[doc = ""]
    #[doc = "  @return the number of conflict constraints found so far at the current node"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNConflictConssFoundNode(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get total number of conflict constraints added to the problem"]
    #[doc = ""]
    #[doc = "  @return the total number of conflict constraints added to the problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNConflictConssApplied(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " get total number of dual proof constraints added to the problem"]
    #[doc = ""]
    #[doc = "  @return the total number of dual proof constraints added to the problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNConflictDualproofsApplied(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets maximal depth of all processed nodes in current branch and bound run (excluding probing nodes)"]
    #[doc = ""]
    #[doc = "  @return the maximal depth of all processed nodes in current branch and bound run (excluding probing nodes)"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetMaxDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets maximal depth of all processed nodes over all branch and bound runs"]
    #[doc = ""]
    #[doc = "  @return the maximal depth of all processed nodes over all branch and bound runs"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetMaxTotalDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets total number of backtracks, i.e. number of times, the new node was selected from the leaves queue"]
    #[doc = ""]
    #[doc = "  @return the total number of backtracks, i.e. number of times, the new node was selected from the leaves queue"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNBacktracks(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets total number of active constraints at the current node"]
    #[doc = ""]
    #[doc = "  @return the total number of active constraints at the current node"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNActiveConss(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets total number of enabled constraints at the current node"]
    #[doc = ""]
    #[doc = "  @return the total number of enabled constraints at the current node"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNEnabledConss(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets average dual bound of all unprocessed nodes for original problem"]
    pub fn SCIPgetAvgDualbound(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets average lower (dual) bound of all unprocessed nodes in transformed problem"]
    #[doc = ""]
    #[doc = "  @return the average lower (dual) bound of all unprocessed nodes in transformed problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgLowerbound(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets global dual bound"]
    #[doc = ""]
    #[doc = "  @return the global dual bound"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetDualbound(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets global lower (dual) bound in transformed problem"]
    #[doc = ""]
    #[doc = "  @return the global lower (dual) bound in transformed problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetLowerbound(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets dual bound of the root node for the original problem"]
    #[doc = ""]
    #[doc = "  @return the dual bound of the root node for the original problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetDualboundRoot(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets lower (dual) bound in transformed problem of the root node"]
    #[doc = ""]
    #[doc = "  @return the lower (dual) bound in transformed problem of the root node"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetLowerboundRoot(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets dual bound for the original problem obtained by the first LP solve at the root node"]
    #[doc = ""]
    #[doc = "  @return the dual bound for the original problem of the first LP solve at the root node"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetFirstLPDualboundRoot(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets lower (dual) bound in transformed problem obtained by the first LP solve at the root node"]
    #[doc = ""]
    #[doc = "  @return the lower (dual) bound in transformed problem obtained by first LP solve at the root node"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetFirstLPLowerboundRoot(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " the primal bound of the very first solution"]
    pub fn SCIPgetFirstPrimalBound(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets global primal bound (objective value of best solution or user objective limit) for the original problem"]
    #[doc = ""]
    #[doc = "  @return the global primal bound (objective value of best solution or user objective limit) for the original problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetPrimalbound(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets global upper (primal) bound in transformed problem (objective value of best solution or user objective limit)"]
    #[doc = ""]
    #[doc = "  @return the global upper (primal) bound in transformed problem (objective value of best solution or user objective limit)"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetUpperbound(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets global cutoff bound in transformed problem: a sub problem with lower bound larger than the cutoff"]
    #[doc = "  cannot contain a better feasible solution; usually, this bound is equal to the upper bound, but if the"]
    #[doc = "  objective value is always integral, the cutoff bound is (nearly) one less than the upper bound;"]
    #[doc = "  additionally, due to objective function domain propagation, the cutoff bound can be further reduced"]
    #[doc = ""]
    #[doc = "  @return global cutoff bound in transformed problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetCutoffbound(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " updates the cutoff bound"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @note using this method in the solving stage can lead to an erroneous SCIP solving status; in particular,"]
    #[doc = "        if a solution not respecting the cutoff bound was found before installing a cutoff bound which"]
    #[doc = "        renders the remaining problem infeasible, this solution may be reported as optimal"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note the given cutoff bound has to better or equal to known one (SCIPgetCutoffbound())"]
    pub fn SCIPupdateCutoffbound(scip: *mut SCIP, cutoffbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether the current primal bound is justified with a feasible primal solution; if not, the primal bound"]
    #[doc = "  was set from the user as objective limit"]
    #[doc = ""]
    #[doc = "  @return TRUE if the current primal bound is justified with a feasible primal solution, otherwise FALSE"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPisPrimalboundSol(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets current gap |(primalbound - dualbound)/min(|primalbound|,|dualbound|)| if both bounds have same sign,"]
    #[doc = "  or infinity, if they have opposite sign"]
    #[doc = ""]
    #[doc = "  @return the current gap |(primalbound - dualbound)/min(|primalbound|,|dualbound|)| if both bounds have same sign,"]
    #[doc = "  or infinity, if they have opposite sign"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetGap(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets current gap |(upperbound - lowerbound)/min(|upperbound|,|lowerbound|)| in transformed problem if both bounds"]
    #[doc = "  have same sign, or infinity, if they have opposite sign"]
    #[doc = ""]
    #[doc = "  @return current gap |(upperbound - lowerbound)/min(|upperbound|,|lowerbound|)| in transformed problem if both bounds"]
    #[doc = "  have same sign, or infinity, if they have opposite sign"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetTransGap(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets number of feasible primal solutions found so far"]
    #[doc = ""]
    #[doc = "  @return the number of feasible primal solutions found so far"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNSolsFound(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of feasible primal solutions respecting the objective limit found so far"]
    #[doc = ""]
    #[doc = "  @return the number of feasible primal solutions respecting the objective limit found so far"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNLimSolsFound(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of feasible primal solutions found so far, that improved the primal bound at the time they were found"]
    #[doc = ""]
    #[doc = "  @return the number of feasible primal solutions found so far, that improved the primal bound at the time they were found"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNBestSolsFound(scip: *mut SCIP) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets the average pseudo cost value for the given direction over all variables"]
    #[doc = ""]
    #[doc = "  @return the average pseudo cost value for the given direction over all variables"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgPseudocost(scip: *mut SCIP, solvaldelta: f64) -> f64;
}
extern "C" {
    #[doc = " gets the average pseudo cost value for the given direction over all variables,"]
    #[doc = "  only using the pseudo cost information of the current run"]
    #[doc = ""]
    #[doc = "  @return the average pseudo cost value for the given direction over all variables,"]
    #[doc = "  only using the pseudo cost information of the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgPseudocostCurrentRun(scip: *mut SCIP, solvaldelta: f64) -> f64;
}
extern "C" {
    #[doc = " gets the average number of pseudo cost updates for the given direction over all variables"]
    #[doc = ""]
    #[doc = "  @return the average number of pseudo cost updates for the given direction over all variables"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgPseudocostCount(scip: *mut SCIP, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " gets the average number of pseudo cost updates for the given direction over all variables,"]
    #[doc = "  only using the pseudo cost information of the current run"]
    #[doc = ""]
    #[doc = "  @return the average number of pseudo cost updates for the given direction over all variables,"]
    #[doc = "  only using the pseudo cost information of the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgPseudocostCountCurrentRun(scip: *mut SCIP, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " gets the number of pseudo cost updates for the given direction over all variables"]
    #[doc = ""]
    #[doc = "  @return the number of pseudo cost updates for the given direction over all variables"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetPseudocostCount(
        scip: *mut SCIP,
        dir: SCIP_BRANCHDIR,
        onlycurrentrun: ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " gets the average pseudo cost score value over all variables, assuming a fractionality of 0.5"]
    #[doc = ""]
    #[doc = "  @return the average pseudo cost score value over all variables, assuming a fractionality of 0.5"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgPseudocostScore(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns the variance of pseudo costs for all variables in the requested direction"]
    #[doc = ""]
    #[doc = "  @return the variance of pseudo costs for all variables in the requested direction"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetPseudocostVariance(
        scip: *mut SCIP,
        branchdir: SCIP_BRANCHDIR,
        onlycurrentrun: ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " gets the average pseudo cost score value over all variables, assuming a fractionality of 0.5,"]
    #[doc = "  only using the pseudo cost information of the current run"]
    #[doc = ""]
    #[doc = "  @return the average pseudo cost score value over all variables, assuming a fractionality of 0.5,"]
    #[doc = "  only using the pseudo cost information of the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgPseudocostScoreCurrentRun(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the average conflict score value over all variables"]
    pub fn SCIPgetAvgConflictScore(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the average conflict score value over all variables, only using the conflict information of the current run"]
    #[doc = ""]
    #[doc = "  @return the average conflict score value over all variables, only using the conflict information of the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgConflictScoreCurrentRun(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the average inference score value over all variables"]
    #[doc = ""]
    #[doc = "  @return the average inference score value over all variables"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgConflictlengthScore(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the average conflictlength score value over all variables, only using the conflictlength information of the"]
    #[doc = "  current run"]
    #[doc = ""]
    #[doc = "  @return the average conflictlength score value over all variables, only using the conflictlength information of the"]
    #[doc = "          current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgConflictlengthScoreCurrentRun(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns the average number of inferences found after branching in given direction over all variables"]
    #[doc = ""]
    #[doc = "  @return the average number of inferences found after branching in given direction over all variables"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgInferences(scip: *mut SCIP, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " returns the average number of inferences found after branching in given direction over all variables,"]
    #[doc = "  only using the inference information of the current run"]
    #[doc = ""]
    #[doc = "  @return the average number of inferences found after branching in given direction over all variables,"]
    #[doc = "          only using the inference information of the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgInferencesCurrentRun(scip: *mut SCIP, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " gets the average inference score value over all variables"]
    #[doc = ""]
    #[doc = "  @return the average inference score value over all variables"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgInferenceScore(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the average inference score value over all variables, only using the inference information of the"]
    #[doc = "  current run"]
    #[doc = ""]
    #[doc = "  @return the average inference score value over all variables, only using the inference information of the"]
    #[doc = "          current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgInferenceScoreCurrentRun(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " returns the average number of cutoffs found after branching in given direction over all variables"]
    #[doc = ""]
    #[doc = "  @return the average number of cutoffs found after branching in given direction over all variables"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgCutoffs(scip: *mut SCIP, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " returns the average number of cutoffs found after branching in given direction over all variables,"]
    #[doc = "  only using the cutoff information of the current run"]
    #[doc = ""]
    #[doc = "  @return the average number of cutoffs found after branching in given direction over all variables,"]
    #[doc = "          only using the cutoff information of the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgCutoffsCurrentRun(scip: *mut SCIP, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " gets the average cutoff score value over all variables"]
    #[doc = ""]
    #[doc = "  @return the average cutoff score value over all variables"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgCutoffScore(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the average cutoff score value over all variables, only using the cutoff information of the current run"]
    #[doc = ""]
    #[doc = "  @return the average cutoff score value over all variables, only using the cutoff information of the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetAvgCutoffScoreCurrentRun(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets deterministic time number of LPs solved so far"]
    #[doc = ""]
    #[doc = "  @return the total number of LPs solved so far"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetDeterministicTime(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " outputs original problem to file stream"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPprintOrigProblem(
        scip: *mut SCIP,
        file: *mut FILE,
        extension: *const ::std::os::raw::c_char,
        genericnames: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs transformed problem of the current node to file stream"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPprintTransProblem(
        scip: *mut SCIP,
        file: *mut FILE,
        extension: *const ::std::os::raw::c_char,
        genericnames: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs status statistics"]
    #[doc = ""]
    #[doc = "  @note If limits have been changed between the solution and the call to this function, the status is recomputed and"]
    #[doc = "        thus may to correspond to the original status."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintStatusStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs timing statistics"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintTimingStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs statistics for original problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintOrigProblemStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs statistics for transformed problem"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintTransProblemStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs presolver statistics"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintPresolverStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs constraint statistics"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintConstraintStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs constraint timing statistics"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintConstraintTimingStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs propagator statistics"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintPropagatorStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs conflict statistics"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintConflictStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs separator statistics"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintSeparatorStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs pricer statistics"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintPricerStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs branching rule statistics"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintBranchruleStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs heuristics statistics"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintHeuristicStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs compression statistics"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintCompressionStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs LP statistics"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintLPStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs NLP statistics"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintNLPStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs relaxator statistics"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintRelaxatorStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs tree statistics"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintTreeStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs root statistics"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintRootStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs solution statistics"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintSolutionStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs concurrent solver statistics"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintConcsolverStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs Benders' decomposition statistics"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintBendersStatistics(scip: *mut SCIP, file: *mut FILE);
}
extern "C" {
    #[doc = " outputs solving statistics"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @note If limits have been changed between the solution and the call to this function, the status is recomputed and"]
    #[doc = "        thus may to correspond to the original status."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintStatistics(scip: *mut SCIP, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs reoptimization statistics"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintReoptStatistics(scip: *mut SCIP, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs history statistics about branchings on variables"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPprintBranchingStatistics(scip: *mut SCIP, file: *mut FILE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs node information display line"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPprintDisplayLine(
        scip: *mut SCIP,
        file: *mut FILE,
        verblevel: SCIP_VERBLEVEL,
        endline: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets total number of implications between variables that are stored in the implication graph"]
    #[doc = ""]
    #[doc = "  @return the total number of implications between variables that are stored in the implication graph"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNImplications(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " stores conflict graph of binary variables' implications into a file, which can be used as input for the DOT tool"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = ""]
    #[doc = "  @deprecated because binary implications are now stored as cliques"]
    pub fn SCIPwriteImplicationConflictGraph(
        scip: *mut SCIP,
        filename: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " update statistical information when a new solution was found"]
    pub fn SCIPstoreSolutionGap(scip: *mut SCIP);
}
extern "C" {
    #[doc = " creates a statistics table and includes it in SCIP"]
    pub fn SCIPincludeTable(
        scip: *mut SCIP,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        active: ::std::os::raw::c_uint,
        tablecopy: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, table: *mut SCIP_TABLE) -> SCIP_RETCODE,
        >,
        tablefree: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, table: *mut SCIP_TABLE) -> SCIP_RETCODE,
        >,
        tableinit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, table: *mut SCIP_TABLE) -> SCIP_RETCODE,
        >,
        tableexit: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, table: *mut SCIP_TABLE) -> SCIP_RETCODE,
        >,
        tableinitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, table: *mut SCIP_TABLE) -> SCIP_RETCODE,
        >,
        tableexitsol: ::std::option::Option<
            unsafe extern "C" fn(scip: *mut SCIP, table: *mut SCIP_TABLE) -> SCIP_RETCODE,
        >,
        tableoutput: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                table: *mut SCIP_TABLE,
                file: *mut FILE,
            ) -> SCIP_RETCODE,
        >,
        tabledata: *mut SCIP_TABLEDATA,
        position: ::std::os::raw::c_int,
        earlieststage: SCIP_STAGE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the statistics table of the given name, or NULL if not existing"]
    pub fn SCIPfindTable(scip: *mut SCIP, name: *const ::std::os::raw::c_char) -> *mut SCIP_TABLE;
}
extern "C" {
    #[doc = " returns the array of currently available statistics tables"]
    pub fn SCIPgetTables(scip: *mut SCIP) -> *mut *mut SCIP_TABLE;
}
extern "C" {
    #[doc = " returns the number of currently available statistics tables"]
    pub fn SCIPgetNTables(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets current time of day in seconds (standard time zone)"]
    #[doc = ""]
    #[doc = "  @return the current time of day in seconds (standard time zone)."]
    pub fn SCIPgetTimeOfDay(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " creates a clock using the default clock type"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreateClock(scip: *mut SCIP, clck: *mut *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a clock counting the CPU user seconds"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreateCPUClock(scip: *mut SCIP, clck: *mut *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates a clock counting the wall clock seconds"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPcreateWallClock(scip: *mut SCIP, clck: *mut *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees a clock"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPfreeClock(scip: *mut SCIP, clck: *mut *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " resets the time measurement of a clock to zero and completely stops the clock"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPresetClock(scip: *mut SCIP, clck: *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " starts the time measurement of a clock"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPstartClock(scip: *mut SCIP, clck: *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " stops the time measurement of a clock"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPstopClock(scip: *mut SCIP, clck: *mut SCIP_CLOCK) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enables or disables all statistic clocks of SCIP concerning plugin statistics,"]
    #[doc = "  LP execution time, strong branching time, etc."]
    #[doc = ""]
    #[doc = "  Method reads the value of the parameter timing/statistictiming. In order to disable statistic timing,"]
    #[doc = "  set the parameter to FALSE."]
    #[doc = ""]
    #[doc = "  @note: The (pre-)solving time clocks which are relevant for the output during (pre-)solving"]
    #[doc = "         are not affected by this method"]
    #[doc = ""]
    #[doc = "  @see: For completely disabling all timing of SCIP, consider setting the parameter timing/enabled to FALSE"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPenableOrDisableStatisticTiming(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " starts the current solving time"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPstartSolvingTime(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " stops the current solving time in seconds"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPstopSolvingTime(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the measured time of a clock in seconds"]
    #[doc = ""]
    #[doc = "  @return the measured time of a clock in seconds."]
    pub fn SCIPgetClockTime(scip: *mut SCIP, clck: *mut SCIP_CLOCK) -> f64;
}
extern "C" {
    #[doc = " sets the measured time of a clock to the given value in seconds"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    pub fn SCIPsetClockTime(scip: *mut SCIP, clck: *mut SCIP_CLOCK, sec: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the current total SCIP time in seconds, possibly accumulated over several problems."]
    #[doc = ""]
    #[doc = "  @return the current total SCIP time in seconds, ie. the total time since the SCIP instance has been created"]
    pub fn SCIPgetTotalTime(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the current solving time in seconds"]
    #[doc = ""]
    #[doc = "  @return the current solving time in seconds."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetSolvingTime(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the current reading time in seconds"]
    #[doc = ""]
    #[doc = "  @return the current reading time in seconds."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetReadingTime(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the current presolving time in seconds"]
    #[doc = ""]
    #[doc = "  @return the current presolving time in seconds."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetPresolvingTime(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets the time need to solve the first LP in the root node"]
    #[doc = ""]
    #[doc = "  @return the solving time for the first LP in the root node in seconds."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = ""]
    #[doc = "  See \\ref SCIP_Stage \"SCIP_STAGE\" for a complete list of all possible solving stages."]
    pub fn SCIPgetFirstLPTime(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " gets focus node in the tree"]
    #[doc = ""]
    #[doc = "  if we are in probing/diving mode this method returns the node in the tree where the probing/diving mode was started."]
    #[doc = ""]
    #[doc = "  @return the current node of the search tree"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetFocusNode(scip: *mut SCIP) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets current node in the tree"]
    #[doc = ""]
    #[doc = "  @return the current node of the search tree"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetCurrentNode(scip: *mut SCIP) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets depth of current node, or -1 if no current node exists; in probing, the current node is the last probing node,"]
    #[doc = "  such that the depth includes the probing path"]
    #[doc = ""]
    #[doc = "  @return the depth of current node, or -1 if no current node exists; in probing, the current node is the last probing node,"]
    #[doc = "  such that the depth includes the probing path"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets depth of the focus node, or -1 if no focus node exists; the focus node is the currently processed node in the"]
    #[doc = "  branching tree, excluding the nodes of the probing path"]
    #[doc = ""]
    #[doc = "  @return the depth of the focus node, or -1 if no focus node exists; the focus node is the currently processed node in the"]
    #[doc = "  branching tree, excluding the nodes of the probing path"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetFocusDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets current plunging depth (successive times, a child was selected as next node)"]
    #[doc = ""]
    #[doc = "  @return the current plunging depth (successive times, a child was selected as next node)"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetPlungeDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the root node of the tree"]
    #[doc = ""]
    #[doc = "  @return the root node of the search tree"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRootNode(scip: *mut SCIP) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets the effective root depth, i.e., the depth of the deepest node which is part of all paths from the root node"]
    #[doc = "  to the unprocessed nodes."]
    #[doc = ""]
    #[doc = "  @return effective root depth"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetEffectiveRootDepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns whether the current node is already solved and only propagated again"]
    #[doc = ""]
    #[doc = "  @return TRUE is returned if \\SCIP performance repropagation, otherwise FALSE."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPinRepropagation(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets children of focus node along with the number of children"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetChildren(
        scip: *mut SCIP,
        children: *mut *mut *mut SCIP_NODE,
        nchildren: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of children of focus node"]
    #[doc = ""]
    #[doc = "  @return number of children of the focus node"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNChildren(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets siblings of focus node along with the number of siblings"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetSiblings(
        scip: *mut SCIP,
        siblings: *mut *mut *mut SCIP_NODE,
        nsiblings: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of siblings of focus node"]
    #[doc = ""]
    #[doc = "  @return the number of siblings of focus node"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNSiblings(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets leaves of the tree along with the number of leaves"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetLeaves(
        scip: *mut SCIP,
        leaves: *mut *mut *mut SCIP_NODE,
        nleaves: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets number of leaves in the tree"]
    #[doc = ""]
    #[doc = "  @return the number of leaves in the tree"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetNLeaves(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets number of nodes left in the tree (children + siblings + leaves)"]
    #[doc = ""]
    #[doc = "  @return the number of nodes left in the tree (children + siblings + leaves)"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetNNodesLeft(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the best child of the focus node w.r.t. the node selection priority assigned by the branching rule"]
    #[doc = ""]
    #[doc = "  @return the best child of the focus node w.r.t. the node selection priority assigned by the branching rule"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetPrioChild(scip: *mut SCIP) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets the best sibling of the focus node w.r.t. the node selection priority assigned by the branching rule"]
    #[doc = ""]
    #[doc = "  @return the best sibling of the focus node w.r.t. the node selection priority assigned by the branching rule"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetPrioSibling(scip: *mut SCIP) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets the best child of the focus node w.r.t. the node selection strategy"]
    #[doc = ""]
    #[doc = "  @return the best child of the focus node w.r.t. the node selection strategy"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetBestChild(scip: *mut SCIP) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets the best sibling of the focus node w.r.t. the node selection strategy"]
    #[doc = ""]
    #[doc = "  @return the best sibling of the focus node w.r.t. the node selection strategy"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetBestSibling(scip: *mut SCIP) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets the best leaf from the node queue w.r.t. the node selection strategy"]
    #[doc = ""]
    #[doc = "  @return the best leaf from the node queue w.r.t. the node selection strategy"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetBestLeaf(scip: *mut SCIP) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets the best node from the tree (child, sibling, or leaf) w.r.t. the node selection strategy"]
    #[doc = ""]
    #[doc = "  @return the best node from the tree (child, sibling, or leaf) w.r.t. the node selection strategy"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetBestNode(scip: *mut SCIP) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " gets the node with smallest lower bound from the tree (child, sibling, or leaf)"]
    #[doc = ""]
    #[doc = "  @return the node with smallest lower bound from the tree (child, sibling, or leaf)"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetBestboundNode(scip: *mut SCIP) -> *mut SCIP_NODE;
}
extern "C" {
    #[doc = " access to all data of open nodes (leaves, children, and siblings)"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetOpenNodesData(
        scip: *mut SCIP,
        leaves: *mut *mut *mut SCIP_NODE,
        children: *mut *mut *mut SCIP_NODE,
        siblings: *mut *mut *mut SCIP_NODE,
        nleaves: *mut ::std::os::raw::c_int,
        nchildren: *mut ::std::os::raw::c_int,
        nsiblings: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " cuts off node and whole sub tree from branch and bound tree"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcutoffNode(scip: *mut SCIP, node: *mut SCIP_NODE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " marks the given node to be propagated again the next time a node of its subtree is processed"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPrepropagateNode(scip: *mut SCIP, node: *mut SCIP_NODE) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns depth of first node in active path that is marked being cutoff"]
    #[doc = ""]
    #[doc = "  @return depth of first node in active path that is marked being cutoff"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetCutoffdepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns depth of first node in active path that has to be propagated again"]
    #[doc = ""]
    #[doc = "  @return depth of first node in active path that has to be propagated again"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRepropdepth(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " prints all branching decisions on variables from the root to the given node"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPprintNodeRootPath(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        file: *mut FILE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets whether the LP should be solved at the focus node"]
    #[doc = ""]
    #[doc = "  @note In order to have an effect, this method needs to be called after a node is focused but before the LP is"]
    #[doc = "        solved."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetFocusnodeLP(scip: *mut SCIP, solvelp: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " query if node was the last parent of a branching of the tree"]
    #[doc = ""]
    #[doc = "  @return TRUE if node was the last parent of a branching of the tree"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if SCIP is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPwasNodeLastBranchParent(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " validate the result of the solve"]
    #[doc = ""]
    #[doc = "  the validation includes"]
    #[doc = ""]
    #[doc = "  - checking the feasibility of the incumbent solution in the original problem (using SCIPcheckSolOrig())"]
    #[doc = ""]
    #[doc = "  - checking if the objective bounds computed by SCIP agree with external primal and dual reference bounds."]
    #[doc = ""]
    #[doc = "  All external reference bounds the original problem space and the original objective sense."]
    #[doc = ""]
    #[doc = "  For infeasible problems, +/-SCIPinfinity() should be passed as reference bounds depending on the objective sense"]
    #[doc = "  of the original problem."]
    pub fn SCIPvalidateSolve(
        scip: *mut SCIP,
        primalreference: f64,
        dualreference: f64,
        reftol: f64,
        quiet: ::std::os::raw::c_uint,
        feasible: *mut ::std::os::raw::c_uint,
        primalboundcheck: *mut ::std::os::raw::c_uint,
        dualboundcheck: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures problem variable; if variable is of integral type, fractional bounds are automatically rounded;"]
    #[doc = "  an integer variable with bounds zero and one is automatically converted into a binary variable;"]
    #[doc = ""]
    #[doc = "  @warning When doing column generation and the original problem is a maximization problem, notice that SCIP will"]
    #[doc = "           transform the problem into a minimization problem by multiplying the objective function by -1.  Thus, the"]
    #[doc = "           original objective function value of variables created during the solving process has to be multiplied by"]
    #[doc = "           -1, too."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note the variable gets captured, hence at one point you have to release it using the method SCIPreleaseVar()"]
    pub fn SCIPcreateVar(
        scip: *mut SCIP,
        var: *mut *mut SCIP_VAR,
        name: *const ::std::os::raw::c_char,
        lb: f64,
        ub: f64,
        obj: f64,
        vartype: SCIP_VARTYPE,
        initial: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        vardelorig: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                vardata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        vartrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcevar: *mut SCIP_VAR,
                sourcedata: *mut SCIP_VARDATA,
                targetvar: *mut SCIP_VAR,
                targetdata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        vardeltrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                vardata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        varcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcescip: *mut SCIP,
                sourcevar: *mut SCIP_VAR,
                sourcedata: *mut SCIP_VARDATA,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                targetvar: *mut SCIP_VAR,
                targetdata: *mut *mut SCIP_VARDATA,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        vardata: *mut SCIP_VARDATA,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " creates and captures problem variable with optional callbacks and variable data set to NULL, which can be set"]
    #[doc = "  afterwards using SCIPvarSetDelorigData(), SCIPvarSetTransData(),"]
    #[doc = "  SCIPvarSetDeltransData(), SCIPvarSetCopy(), and SCIPvarSetData(); sets variable flags initial=TRUE"]
    #[doc = "  and removable = FALSE, which can be adjusted by using SCIPvarSetInitial() and SCIPvarSetRemovable(), resp.;"]
    #[doc = "  if variable is of integral type, fractional bounds are automatically rounded;"]
    #[doc = "  an integer variable with bounds zero and one is automatically converted into a binary variable;"]
    #[doc = ""]
    #[doc = "  @warning When doing column generation and the original problem is a maximization problem, notice that SCIP will"]
    #[doc = "           transform the problem into a minimization problem by multiplying the objective function by -1.  Thus, the"]
    #[doc = "           original objective function value of variables created during the solving process has to be multiplied by"]
    #[doc = "           -1, too."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note the variable gets captured, hence at one point you have to release it using the method SCIPreleaseVar()"]
    pub fn SCIPcreateVarBasic(
        scip: *mut SCIP,
        var: *mut *mut SCIP_VAR,
        name: *const ::std::os::raw::c_char,
        lb: f64,
        ub: f64,
        obj: f64,
        vartype: SCIP_VARTYPE,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " outputs the variable name to the file stream"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPwriteVarName(
        scip: *mut SCIP,
        file: *mut FILE,
        var: *mut SCIP_VAR,
        type_: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " print the given list of variables to output stream separated by the given delimiter character;"]
    #[doc = ""]
    #[doc = "  i. e. the variables x1, x2, ..., xn with given delimiter ',' are written as: \\<x1\\>, \\<x2\\>, ..., \\<xn\\>;"]
    #[doc = ""]
    #[doc = "  the method SCIPparseVarsList() can parse such a string"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  @note The printing process is done via the message handler system."]
    pub fn SCIPwriteVarsList(
        scip: *mut SCIP,
        file: *mut FILE,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_uint,
        delimiter: ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " print the given variables and coefficients as linear sum in the following form"]
    #[doc = "  c1 \\<x1\\> + c2 \\<x2\\>   ... + cn \\<xn\\>"]
    #[doc = ""]
    #[doc = "  This string can be parsed by the method SCIPparseVarsLinearsum()."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  @note The printing process is done via the message handler system."]
    pub fn SCIPwriteVarsLinearsum(
        scip: *mut SCIP,
        file: *mut FILE,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        nvars: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " print the given monomials as polynomial in the following form"]
    #[doc = "  c1 \\<x11\\>^e11 \\<x12\\>^e12 ... \\<x1n\\>^e1n + c2 \\<x21\\>^e21 \\<x22\\>^e22 ... + ... + cn \\<xn1\\>^en1 ..."]
    #[doc = ""]
    #[doc = "  This string can be parsed by the method SCIPparseVarsPolynomial()."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  @note The printing process is done via the message handler system."]
    pub fn SCIPwriteVarsPolynomial(
        scip: *mut SCIP,
        file: *mut FILE,
        monomialvars: *mut *mut *mut SCIP_VAR,
        monomialexps: *mut *mut f64,
        monomialcoefs: *mut f64,
        monomialnvars: *mut ::std::os::raw::c_int,
        nmonomials: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " parses variable information (in cip format) out of a string; if the parsing process was successful a variable is"]
    #[doc = "  created and captured; if variable is of integral type, fractional bounds are automatically rounded; an integer"]
    #[doc = "  variable with bounds zero and one is automatically converted into a binary variable"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPparseVar(
        scip: *mut SCIP,
        var: *mut *mut SCIP_VAR,
        str_: *const ::std::os::raw::c_char,
        initial: ::std::os::raw::c_uint,
        removable: ::std::os::raw::c_uint,
        varcopy: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcescip: *mut SCIP,
                sourcevar: *mut SCIP_VAR,
                sourcedata: *mut SCIP_VARDATA,
                varmap: *mut SCIP_HASHMAP,
                consmap: *mut SCIP_HASHMAP,
                targetvar: *mut SCIP_VAR,
                targetdata: *mut *mut SCIP_VARDATA,
                result: *mut SCIP_RESULT,
            ) -> SCIP_RETCODE,
        >,
        vardelorig: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                vardata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        vartrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                sourcevar: *mut SCIP_VAR,
                sourcedata: *mut SCIP_VARDATA,
                targetvar: *mut SCIP_VAR,
                targetdata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        vardeltrans: ::std::option::Option<
            unsafe extern "C" fn(
                scip: *mut SCIP,
                var: *mut SCIP_VAR,
                vardata: *mut *mut SCIP_VARDATA,
            ) -> SCIP_RETCODE,
        >,
        vardata: *mut SCIP_VARDATA,
        endptr: *mut *mut ::std::os::raw::c_char,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " parses the given string for a variable name and stores the variable in the corresponding pointer if such a variable"]
    #[doc = "  exits and returns the position where the parsing stopped"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPparseVarName(
        scip: *mut SCIP,
        str_: *const ::std::os::raw::c_char,
        var: *mut *mut SCIP_VAR,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " parse the given string as variable list (here ',' is the delimiter)) (\\<x1\\>, \\<x2\\>, ..., \\<xn\\>) (see"]
    #[doc = "  SCIPwriteVarsList() ); if it was successful, the pointer success is set to TRUE"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note The pointer success in only set to FALSE in the case that a variable with a parsed variable name does not exist."]
    #[doc = ""]
    #[doc = "  @note If the number of (parsed) variables is greater than the available slots in the variable array, nothing happens"]
    #[doc = "        except that the required size is stored in the corresponding integer; the reason for this approach is that we"]
    #[doc = "        cannot reallocate memory, since we do not know how the memory has been allocated (e.g., by a C++ 'new' or SCIP"]
    #[doc = "        memory functions)."]
    pub fn SCIPparseVarsList(
        scip: *mut SCIP,
        str_: *const ::std::os::raw::c_char,
        vars: *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
        varssize: ::std::os::raw::c_int,
        requiredsize: *mut ::std::os::raw::c_int,
        endptr: *mut *mut ::std::os::raw::c_char,
        delimiter: ::std::os::raw::c_char,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " parse the given string as linear sum of variables and coefficients (c1 \\<x1\\> + c2 \\<x2\\> + ... + cn \\<xn\\>)"]
    #[doc = "  (see SCIPwriteVarsLinearsum() ); if it was successful, the pointer success is set to TRUE"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note The pointer success in only set to FALSE in the case that a variable with a parsed variable name does not exist."]
    #[doc = ""]
    #[doc = "  @note If the number of (parsed) variables is greater than the available slots in the variable array, nothing happens"]
    #[doc = "        except that the required size is stored in the corresponding integer; the reason for this approach is that we"]
    #[doc = "        cannot reallocate memory, since we do not know how the memory has been allocated (e.g., by a C++ 'new' or SCIP"]
    #[doc = "        memory functions)."]
    pub fn SCIPparseVarsLinearsum(
        scip: *mut SCIP,
        str_: *const ::std::os::raw::c_char,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        nvars: *mut ::std::os::raw::c_int,
        varssize: ::std::os::raw::c_int,
        requiredsize: *mut ::std::os::raw::c_int,
        endptr: *mut *mut ::std::os::raw::c_char,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " parse the given string as polynomial of variables and coefficients"]
    #[doc = "  (c1 \\<x11\\>^e11 \\<x12\\>^e12 ... \\<x1n\\>^e1n + c2 \\<x21\\>^e21 \\<x22\\>^e22 ... + ... + cn \\<xn1\\>^en1 ...)"]
    #[doc = "  (see SCIPwriteVarsPolynomial()); if it was successful, the pointer success is set to TRUE"]
    #[doc = ""]
    #[doc = "  The user has to call SCIPfreeParseVarsPolynomialData(scip, monomialvars, monomialexps,"]
    #[doc = "  monomialcoefs, monomialnvars, *nmonomials) short after SCIPparseVarsPolynomial to free all the"]
    #[doc = "  allocated memory again.  Do not keep the arrays created by SCIPparseVarsPolynomial around, since"]
    #[doc = "  they use buffer memory that is intended for short term use only."]
    #[doc = ""]
    #[doc = "  Parsing is stopped at the end of string (indicated by the \\\\0-character) or when no more monomials"]
    #[doc = "  are recognized."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPparseVarsPolynomial(
        scip: *mut SCIP,
        str_: *const ::std::os::raw::c_char,
        monomialvars: *mut *mut *mut *mut SCIP_VAR,
        monomialexps: *mut *mut *mut f64,
        monomialcoefs: *mut *mut f64,
        monomialnvars: *mut *mut ::std::os::raw::c_int,
        nmonomials: *mut ::std::os::raw::c_int,
        endptr: *mut *mut ::std::os::raw::c_char,
        success: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " frees memory allocated when parsing a polynomial from a string"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPfreeParseVarsPolynomialData(
        scip: *mut SCIP,
        monomialvars: *mut *mut *mut *mut SCIP_VAR,
        monomialexps: *mut *mut *mut f64,
        monomialcoefs: *mut *mut f64,
        monomialnvars: *mut *mut ::std::os::raw::c_int,
        nmonomials: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " increases usage counter of variable"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPcaptureVar(scip: *mut SCIP, var: *mut SCIP_VAR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " decreases usage counter of variable, if the usage pointer reaches zero the variable gets freed"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  @note the pointer of the variable will be NULLed"]
    pub fn SCIPreleaseVar(scip: *mut SCIP, var: *mut *mut SCIP_VAR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the name of a variable"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_PROBLEM"]
    #[doc = ""]
    #[doc = "  @note to get the current name of a variable, use SCIPvarGetName() from pub_var.h"]
    pub fn SCIPchgVarName(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        name: *const ::std::os::raw::c_char,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets and captures transformed variable of a given variable; if the variable is not yet transformed,"]
    #[doc = "  a new transformed variable for this variable is created"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPtransformVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        transvar: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets and captures transformed variables for an array of variables;"]
    #[doc = "  if a variable of the array is not yet transformed, a new transformed variable for this variable is created;"]
    #[doc = "  it is possible to call this method with vars == transvars"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPtransformVars(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        transvars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets corresponding transformed variable of a given variable;"]
    #[doc = "  returns NULL as transvar, if transformed variable is not yet existing"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetTransformedVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        transvar: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets corresponding transformed variables for an array of variables;"]
    #[doc = "  stores NULL in a transvars slot, if the transformed variable is not yet existing;"]
    #[doc = "  it is possible to call this method with vars == transvars, but remember that variables that are not"]
    #[doc = "  yet transformed will be replaced with NULL"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetTransformedVars(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        transvars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets negated variable x' = lb + ub - x of variable x; negated variable is created, if not yet existing"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNegatedVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        negvar: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets negated variables x' = lb + ub - x of variables x; negated variables are created, if not yet existing;"]
    #[doc = "  in difference to \\ref SCIPcreateVar, the negated variable must not be released (unless captured explicitly)"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetNegatedVars(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        negvars: *mut *mut SCIP_VAR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets a binary variable that is equal to the given binary variable, and that is either active, fixed, or"]
    #[doc = "  multi-aggregated, or the negated variable of an active, fixed, or multi-aggregated variable"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetBinvarRepresentative(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        repvar: *mut *mut SCIP_VAR,
        negated: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets binary variables that are equal to the given binary variables, and which are either active, fixed, or"]
    #[doc = "  multi-aggregated, or the negated variables of active, fixed, or multi-aggregated variables"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetBinvarRepresentatives(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        repvars: *mut *mut SCIP_VAR,
        negated: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " flattens aggregation graph of multi-aggregated variable in order to avoid exponential recursion later on"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPflattenVarAggregationGraph(scip: *mut SCIP, var: *mut SCIP_VAR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Transforms a given linear sum of variables, that is a_1*x_1 + ... + a_n*x_n + c into a corresponding linear sum of"]
    #[doc = "  active variables, that is b_1*y_1 + ... + b_m*y_m + d."]
    #[doc = ""]
    #[doc = "  If the number of needed active variables is greater than the available slots in the variable array, nothing happens"]
    #[doc = "  except that the required size is stored in the corresponding variable (requiredsize). Otherwise, the active variable"]
    #[doc = "  representation is stored in the variable array, scalar array and constant."]
    #[doc = ""]
    #[doc = "  The reason for this approach is that we cannot reallocate memory, since we do not know how the memory has been"]
    #[doc = "  allocated (e.g., by a C++ 'new' or SCIP functions)."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  @note The resulting linear sum is stored into the given variable array, scalar array, and constant. That means the"]
    #[doc = "        given entries are overwritten."]
    #[doc = ""]
    #[doc = "  @note That method can be used to convert a single variables into variable space of active variables. Therefore call"]
    #[doc = "        the method with the linear sum 1.0*x + 0.0."]
    pub fn SCIPgetProbvarLinearSum(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        scalars: *mut f64,
        nvars: *mut ::std::os::raw::c_int,
        varssize: ::std::os::raw::c_int,
        constant: *mut f64,
        requiredsize: *mut ::std::os::raw::c_int,
        mergemultiples: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " transforms given variable, scalar and constant to the corresponding active, fixed, or"]
    #[doc = "  multi-aggregated variable, scalar and constant; if the variable resolves to a fixed variable,"]
    #[doc = "  \"scalar\" will be 0.0 and the value of the sum will be stored in \"constant\"; a multi-aggregation"]
    #[doc = "  with only one active variable (this can happen due to fixings after the multi-aggregation),"]
    #[doc = "  is treated like an aggregation; if the multi-aggregation constant is infinite, \"scalar\" will be 0.0"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetProbvarSum(
        scip: *mut SCIP,
        var: *mut *mut SCIP_VAR,
        scalar: *mut f64,
        constant: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " return for given variables all their active counterparts; all active variables will be pairwise different"]
    #[doc = "  @note It does not hold that the first output variable is the active variable for the first input variable."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPgetActiveVars(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        nvars: *mut ::std::os::raw::c_int,
        varssize: ::std::os::raw::c_int,
        requiredsize: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the reduced costs of the variable in the current node's LP relaxation;"]
    #[doc = "  the current node has to have a feasible LP."]
    #[doc = ""]
    #[doc = "  returns SCIP_INVALID if the variable is active but not in the current LP;"]
    #[doc = "  returns 0 if the variable has been aggregated out or fixed in presolving."]
    #[doc = ""]
    #[doc = "  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note The return value of this method should be used carefully if the dual feasibility check was explictely disabled."]
    pub fn SCIPgetVarRedcost(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the implied reduced costs of the variable in the current node's LP relaxation;"]
    #[doc = "  the current node has to have a feasible LP."]
    #[doc = ""]
    #[doc = "  returns SCIP_INVALID if the variable is active but not in the current LP;"]
    #[doc = "  returns 0 if the variable has been aggregated out or fixed in presolving."]
    #[doc = ""]
    #[doc = "  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note The return value of this method should be used carefully if the dual feasibility check was explictely disabled."]
    pub fn SCIPgetVarImplRedcost(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the Farkas coefficient of the variable in the current node's LP relaxation;"]
    #[doc = "  the current node has to have an infeasible LP."]
    #[doc = ""]
    #[doc = "  returns SCIP_INVALID if the variable is active but not in the current LP;"]
    #[doc = "  returns 0 if the variable has been aggregated out or fixed in presolving."]
    #[doc = ""]
    #[doc = "  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarFarkasCoef(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns lower bound of variable directly before or after the bound change given by the bound change index"]
    #[doc = "  was applied"]
    pub fn SCIPgetVarLbAtIndex(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " returns upper bound of variable directly before or after the bound change given by the bound change index"]
    #[doc = "  was applied"]
    pub fn SCIPgetVarUbAtIndex(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " returns lower or upper bound of variable directly before or after the bound change given by the bound change index"]
    #[doc = "  was applied"]
    pub fn SCIPgetVarBdAtIndex(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        boundtype: SCIP_BOUNDTYPE,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " returns whether the binary variable was fixed at the time given by the bound change index"]
    pub fn SCIPgetVarWasFixedAtIndex(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        bdchgidx: *mut SCIP_BDCHGIDX,
        after: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets solution value for variable in current node"]
    #[doc = ""]
    #[doc = "  @return solution value for variable in current node"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarSol(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets solution values of multiple variables in current node"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarSols(
        scip: *mut SCIP,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the solution value of all variables in the global relaxation solution to zero"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPclearRelaxSolVals(scip: *mut SCIP, relax: *mut SCIP_RELAX) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the value of the given variable in the global relaxation solution;"]
    #[doc = "  this solution can be filled by the relaxation handlers  and can be used by heuristics and for separation;"]
    #[doc = "  You can use SCIPclearRelaxSolVals() to set all values to zero, initially;"]
    #[doc = "  after setting all solution values, you have to call SCIPmarkRelaxSolValid()"]
    #[doc = "  to inform SCIP that the stored solution is valid"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note This method incrementally updates the objective value of the relaxation solution. If the whole solution"]
    #[doc = "        should be updated, using SCIPsetRelaxSolVals() instead or calling SCIPclearRelaxSolVals() before setting"]
    #[doc = "        the first value to reset the solution and the objective value to 0 may help the numerics."]
    pub fn SCIPsetRelaxSolVal(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        var: *mut SCIP_VAR,
        val: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the values of the given variables in the global relaxation solution and informs SCIP about the validity"]
    #[doc = "  and whether the solution can be enforced via linear cuts;"]
    #[doc = "  this solution can be filled by the relaxation handlers  and can be used by heuristics and for separation;"]
    #[doc = "  the solution is automatically cleared, s.t. all other variables get value 0.0"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetRelaxSolVals(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        nvars: ::std::os::raw::c_int,
        vars: *mut *mut SCIP_VAR,
        vals: *mut f64,
        includeslp: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the values of the variables in the global relaxation solution to the values in the given primal solution"]
    #[doc = "  and informs SCIP about the validity and whether the solution can be enforced via linear cuts;"]
    #[doc = "  the relaxation solution can be filled by the relaxation handlers and might be used by heuristics and for separation"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetRelaxSolValsSol(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        sol: *mut SCIP_SOL,
        includeslp: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether the relaxation solution is valid"]
    #[doc = ""]
    #[doc = "  @return TRUE, if the relaxation solution is valid; FALSE, otherwise"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPisRelaxSolValid(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " informs SCIP that the relaxation solution is valid and whether the relaxation can be enforced through linear cuts"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPmarkRelaxSolValid(
        scip: *mut SCIP,
        relax: *mut SCIP_RELAX,
        includeslp: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " informs SCIP, that the relaxation solution is invalid"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPmarkRelaxSolInvalid(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the relaxation solution value of the given variable"]
    #[doc = ""]
    #[doc = "  @return the relaxation solution value of the given variable"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRelaxSolVal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " gets the relaxation solution objective value"]
    #[doc = ""]
    #[doc = "  @return the objective value of the relaxation solution"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetRelaxSolObj(scip: *mut SCIP) -> f64;
}
extern "C" {
    #[doc = " determine which branching direction should be evaluated first by strong branching"]
    #[doc = ""]
    #[doc = "  @return TRUE iff strong branching should first evaluate the down child"]
    #[doc = ""]
    pub fn SCIPisStrongbranchDownFirst(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " start strong branching - call before any strong branching"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note if propagation is enabled, strong branching is not done directly on the LP, but probing nodes are created"]
    #[doc = "        which allow to perform propagation but also creates some overhead"]
    pub fn SCIPstartStrongbranch(
        scip: *mut SCIP,
        enablepropagation: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " end strong branching - call after any strong branching"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPendStrongbranch(scip: *mut SCIP) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets strong branching information on column variable with fractional value"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarStrongbranchFrac(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        itlim: ::std::os::raw::c_int,
        idempotent: ::std::os::raw::c_uint,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        downinf: *mut ::std::os::raw::c_uint,
        upinf: *mut ::std::os::raw::c_uint,
        downconflict: *mut ::std::os::raw::c_uint,
        upconflict: *mut ::std::os::raw::c_uint,
        lperror: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets strong branching information with previous domain propagation on column variable"]
    #[doc = ""]
    #[doc = "  Before calling this method, the strong branching mode must have been activated by calling SCIPstartStrongbranch();"]
    #[doc = "  after strong branching was done for all candidate variables, the strong branching mode must be ended by"]
    #[doc = "  SCIPendStrongbranch(). Since this method applies domain propagation before strongbranching, propagation has to be be"]
    #[doc = "  enabled in the SCIPstartStrongbranch() call."]
    #[doc = ""]
    #[doc = "  Before solving the strong branching LP, domain propagation can be performed. The number of propagation rounds"]
    #[doc = "  can be specified by the parameter @p maxproprounds."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @warning When using this method, LP banching candidates and solution values must be copied beforehand, because"]
    #[doc = "           they are updated w.r.t. the strong branching LP solution."]
    pub fn SCIPgetVarStrongbranchWithPropagation(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        solval: f64,
        lpobjval: f64,
        itlim: ::std::os::raw::c_int,
        maxproprounds: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        ndomredsdown: *mut ::std::os::raw::c_longlong,
        ndomredsup: *mut ::std::os::raw::c_longlong,
        downinf: *mut ::std::os::raw::c_uint,
        upinf: *mut ::std::os::raw::c_uint,
        downconflict: *mut ::std::os::raw::c_uint,
        upconflict: *mut ::std::os::raw::c_uint,
        lperror: *mut ::std::os::raw::c_uint,
        newlbs: *mut f64,
        newubs: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets strong branching information on column variable x with integral LP solution value (val); that is, the down branch"]
    #[doc = "  is (val -1.0) and the up brach ins (val +1.0)"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note If the integral LP solution value is the lower or upper bound of the variable, the corresponding branch will be"]
    #[doc = "        marked as infeasible. That is, the valid pointer and the infeasible pointer are set to TRUE."]
    pub fn SCIPgetVarStrongbranchInt(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        itlim: ::std::os::raw::c_int,
        idempotent: ::std::os::raw::c_uint,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        downinf: *mut ::std::os::raw::c_uint,
        upinf: *mut ::std::os::raw::c_uint,
        downconflict: *mut ::std::os::raw::c_uint,
        upconflict: *mut ::std::os::raw::c_uint,
        lperror: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets strong branching information on column variables with fractional values"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarsStrongbranchesFrac(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        itlim: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        downinf: *mut ::std::os::raw::c_uint,
        upinf: *mut ::std::os::raw::c_uint,
        downconflict: *mut ::std::os::raw::c_uint,
        upconflict: *mut ::std::os::raw::c_uint,
        lperror: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets strong branching information on column variables with integral values"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarsStrongbranchesInt(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        itlim: ::std::os::raw::c_int,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        downinf: *mut ::std::os::raw::c_uint,
        upinf: *mut ::std::os::raw::c_uint,
        downconflict: *mut ::std::os::raw::c_uint,
        upconflict: *mut ::std::os::raw::c_uint,
        lperror: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " get LP solution status of last strong branching call (currently only works for strong branching with propagation)"]
    pub fn SCIPgetLastStrongbranchLPSolStat(
        scip: *mut SCIP,
        branchdir: SCIP_BRANCHDIR,
    ) -> SCIP_LPSOLSTAT;
}
extern "C" {
    #[doc = " gets strong branching information on COLUMN variable of the last SCIPgetVarStrongbranch() call;"]
    #[doc = "  returns values of SCIP_INVALID, if strong branching was not yet called on the given variable;"]
    #[doc = "  keep in mind, that the returned old values may have nothing to do with the current LP solution"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarStrongbranchLast(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        down: *mut f64,
        up: *mut f64,
        downvalid: *mut ::std::os::raw::c_uint,
        upvalid: *mut ::std::os::raw::c_uint,
        solval: *mut f64,
        lpobjval: *mut f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets strong branching information for a column variable"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPsetVarStrongbranchData(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        lpobjval: f64,
        primsol: f64,
        down: f64,
        up: f64,
        downvalid: ::std::os::raw::c_uint,
        upvalid: ::std::os::raw::c_uint,
        iter: ::std::os::raw::c_longlong,
        itlim: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " rounds the current solution and tries it afterwards; if feasible, adds it to storage"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPtryStrongbranchLPSol(
        scip: *mut SCIP,
        foundsol: *mut ::std::os::raw::c_uint,
        cutoff: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets node number of the last node in current branch and bound run, where strong branching was used on the"]
    #[doc = "  given variable, or -1 if strong branching was never applied to the variable in current run"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetVarStrongbranchNode(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " if strong branching was already applied on the variable at the current node, returns the number of LPs solved after"]
    #[doc = "  the LP where the strong branching on this variable was applied;"]
    #[doc = "  if strong branching was not yet applied on the variable at the current node, returns INT_MAX"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetVarStrongbranchLPAge(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " gets number of times, strong branching was applied in current run on the given variable"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetVarNStrongbranchs(scip: *mut SCIP, var: *mut SCIP_VAR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " adds given values to lock numbers of type @p locktype of variable for rounding"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPaddVarLocksType(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        locktype: SCIP_LOCKTYPE,
        nlocksdown: ::std::os::raw::c_int,
        nlocksup: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds given values to lock numbers of variable for rounding"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  @note This method will always add variable locks of type model"]
    pub fn SCIPaddVarLocks(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        nlocksdown: ::std::os::raw::c_int,
        nlocksup: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " add locks of type @p locktype of variable with respect to the lock status of the constraint and its negation;"]
    #[doc = "  this method should be called whenever the lock status of a variable in a constraint changes, for example if"]
    #[doc = "  the coefficient of the variable changed its sign or if the left or right hand sides of the constraint were"]
    #[doc = "  added or removed"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPlockVarCons(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        cons: *mut SCIP_CONS,
        lockdown: ::std::os::raw::c_uint,
        lockup: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " remove locks of type @p locktype of variable with respect to the lock status of the constraint and its negation;"]
    #[doc = "  this method should be called whenever the lock status of a variable in a constraint changes, for example if"]
    #[doc = "  the coefficient of the variable changed its sign or if the left or right hand sides of the constraint were"]
    #[doc = "  added or removed"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPunlockVarCons(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        cons: *mut SCIP_CONS,
        lockdown: ::std::os::raw::c_uint,
        lockup: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes variable's objective value"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    pub fn SCIPchgVarObj(scip: *mut SCIP, var: *mut SCIP_VAR, newobj: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds value to variable's objective value"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    pub fn SCIPaddVarObj(scip: *mut SCIP, var: *mut SCIP_VAR, addobj: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the adjusted (i.e. rounded, if the given variable is of integral type) lower bound value;"]
    #[doc = "  does not change the bounds of the variable"]
    #[doc = ""]
    #[doc = "  @return adjusted lower bound for the given variable; the bound of the variable is not changed"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPadjustedVarLb(scip: *mut SCIP, var: *mut SCIP_VAR, lb: f64) -> f64;
}
extern "C" {
    #[doc = " returns the adjusted (i.e. rounded, if the given variable is of integral type) upper bound value;"]
    #[doc = "  does not change the bounds of the variable"]
    #[doc = ""]
    #[doc = "  @return adjusted upper bound for the given variable; the bound of the variable is not changed"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    pub fn SCIPadjustedVarUb(scip: *mut SCIP, var: *mut SCIP_VAR, ub: f64) -> f64;
}
extern "C" {
    #[doc = " depending on SCIP's stage, changes lower bound of variable in the problem, in preprocessing, or in current node;"]
    #[doc = "  if possible, adjusts bound to integral value; doesn't store any inference information in the bound change, such"]
    #[doc = "  that in conflict analysis, this change is treated like a branching decision"]
    #[doc = ""]
    #[doc = "  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via"]
    #[doc = "           SCIPgetVars()) gets resorted."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPchgVarLb(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " depending on SCIP's stage, changes upper bound of variable in the problem, in preprocessing, or in current node;"]
    #[doc = "  if possible, adjusts bound to integral value; doesn't store any inference information in the bound change, such"]
    #[doc = "  that in conflict analysis, this change is treated like a branching decision"]
    #[doc = ""]
    #[doc = "  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via"]
    #[doc = "           SCIPgetVars()) gets resorted."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPchgVarUb(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes lower bound of variable in the given node; if possible, adjust bound to integral value; doesn't store any"]
    #[doc = "  inference information in the bound change, such that in conflict analysis, this change is treated like a branching"]
    #[doc = "  decision"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarLbNode(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        var: *mut SCIP_VAR,
        newbound: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes upper bound of variable in the given node; if possible, adjust bound to integral value; doesn't store any"]
    #[doc = "  inference information in the bound change, such that in conflict analysis, this change is treated like a branching"]
    #[doc = "  decision"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarUbNode(
        scip: *mut SCIP,
        node: *mut SCIP_NODE,
        var: *mut SCIP_VAR,
        newbound: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes global lower bound of variable; if possible, adjust bound to integral value; also tightens the local bound,"]
    #[doc = "  if the global bound is better than the local bound"]
    #[doc = ""]
    #[doc = "  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via"]
    #[doc = "           SCIPgetVars()) gets resorted."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPchgVarLbGlobal(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes global upper bound of variable; if possible, adjust bound to integral value; also tightens the local bound,"]
    #[doc = "  if the global bound is better than the local bound"]
    #[doc = ""]
    #[doc = "  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via"]
    #[doc = "           SCIPgetVars()) gets resorted."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPchgVarUbGlobal(scip: *mut SCIP, var: *mut SCIP_VAR, newbound: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes lazy lower bound of the variable, this is only possible if the variable is not in the LP yet"]
    #[doc = ""]
    #[doc = "  lazy bounds are bounds, that are enforced by constraints and the objective function; hence, these bounds do not need"]
    #[doc = "  to be put into the LP explicitly."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note lazy bounds are useful for branch-and-price since the corresponding variable bounds are not part of the LP"]
    pub fn SCIPchgVarLbLazy(scip: *mut SCIP, var: *mut SCIP_VAR, lazylb: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes lazy upper bound of the variable, this is only possible if the variable is not in the LP yet"]
    #[doc = ""]
    #[doc = "  lazy bounds are bounds, that are enforced by constraints and the objective function; hence, these bounds do not need"]
    #[doc = "  to be put into the LP explicitly."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note lazy bounds are useful for branch-and-price since the corresponding variable bounds are not part of the LP"]
    pub fn SCIPchgVarUbLazy(scip: *mut SCIP, var: *mut SCIP_VAR, lazyub: f64) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes lower bound of variable in preprocessing or in the current node, if the new bound is tighter"]
    #[doc = "  (w.r.t. bound strengthening epsilon) than the current bound; if possible, adjusts bound to integral value;"]
    #[doc = "  doesn't store any inference information in the bound change, such that in conflict analysis, this change"]
    #[doc = "  is treated like a branching decision"]
    #[doc = ""]
    #[doc = "  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via"]
    #[doc = "           SCIPgetVars()) gets resorted."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPtightenVarLb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes upper bound of variable in preprocessing or in the current node, if the new bound is tighter"]
    #[doc = "  (w.r.t. bound strengthening epsilon) than the current bound; if possible, adjusts bound to integral value;"]
    #[doc = "  doesn't store any inference information in the bound change, such that in conflict analysis, this change"]
    #[doc = "  is treated like a branching decision"]
    #[doc = ""]
    #[doc = "  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via"]
    #[doc = "           SCIPgetVars()) gets resorted."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPtightenVarUb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " fixes variable in preprocessing or in the current node, if the new bound is tighter (w.r.t. bound strengthening"]
    #[doc = "  epsilon) than the current bound; if possible, adjusts bound to integral value; the given inference constraint is"]
    #[doc = "  stored, such that the conflict analysis is able to find out the reason for the deduction of the bound change"]
    #[doc = ""]
    #[doc = "  @note In presolving stage when not in probing mode the variable will be fixed directly, otherwise this method"]
    #[doc = "        changes first the lowerbound by calling SCIPinferVarLbCons and second the upperbound by calling"]
    #[doc = "        SCIPinferVarUbCons"]
    #[doc = ""]
    #[doc = "  @note If SCIP is in presolving stage, it can happen that the internal variable array (which get be accessed via"]
    #[doc = "        SCIPgetVars()) gets resorted."]
    #[doc = ""]
    #[doc = "  @note During presolving, an integer variable which bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPinferVarFixCons(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        fixedval: f64,
        infercons: *mut SCIP_CONS,
        inferinfo: ::std::os::raw::c_int,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes lower bound of variable in preprocessing or in the current node, if the new bound is tighter"]
    #[doc = "  (w.r.t. bound strengthening epsilon) than the current bound; if possible, adjusts bound to integral value;"]
    #[doc = "  the given inference constraint is stored, such that the conflict analysis is able to find out the reason"]
    #[doc = "  for the deduction of the bound change"]
    #[doc = ""]
    #[doc = "  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via"]
    #[doc = "           SCIPgetVars()) gets resorted."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPinferVarLbCons(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        infercons: *mut SCIP_CONS,
        inferinfo: ::std::os::raw::c_int,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes upper bound of variable in preprocessing or in the current node, if the new bound is tighter"]
    #[doc = "  (w.r.t. bound strengthening epsilon) than the current bound; if possible, adjusts bound to integral value;"]
    #[doc = "  the given inference constraint is stored, such that the conflict analysis is able to find out the reason"]
    #[doc = "  for the deduction of the bound change"]
    #[doc = ""]
    #[doc = "  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via"]
    #[doc = "           SCIPgetVars()) gets resorted."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPinferVarUbCons(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        infercons: *mut SCIP_CONS,
        inferinfo: ::std::os::raw::c_int,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " depending on SCIP's stage, fixes binary variable in the problem, in preprocessing, or in current node;"]
    #[doc = "  the given inference constraint is stored, such that the conflict analysis is able to find out the reason for the"]
    #[doc = "  deduction of the fixing"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPinferBinvarCons(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        fixedval: ::std::os::raw::c_uint,
        infercons: *mut SCIP_CONS,
        inferinfo: ::std::os::raw::c_int,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " fixes variable in preprocessing or in the current node, if the new bound is tighter (w.r.t. bound strengthening"]
    #[doc = "  epsilon) than the current bound; if possible, adjusts bound to integral value; the given inference constraint is"]
    #[doc = "  stored, such that the conflict analysis is able to find out the reason for the deduction of the bound change"]
    #[doc = ""]
    #[doc = "  @note In presolving stage when not in probing mode the variable will be fixed directly, otherwise this method"]
    #[doc = "        changes first the lowerbound by calling SCIPinferVarLbProp and second the upperbound by calling"]
    #[doc = "        SCIPinferVarUbProp"]
    #[doc = ""]
    #[doc = "  @note If SCIP is in presolving stage, it can happen that the internal variable array (which get be accessed via"]
    #[doc = "        SCIPgetVars()) gets resorted."]
    #[doc = ""]
    #[doc = "  @note During presolving, an integer variable which bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPinferVarFixProp(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        fixedval: f64,
        inferprop: *mut SCIP_PROP,
        inferinfo: ::std::os::raw::c_int,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes lower bound of variable in preprocessing or in the current node, if the new bound is tighter"]
    #[doc = "  (w.r.t. bound strengthening epsilon) than the current bound; if possible, adjusts bound to integral value;"]
    #[doc = "  the given inference propagator is stored, such that the conflict analysis is able to find out the reason"]
    #[doc = "  for the deduction of the bound change"]
    #[doc = ""]
    #[doc = "  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via"]
    #[doc = "           SCIPgetVars()) gets resorted."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPinferVarLbProp(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        inferprop: *mut SCIP_PROP,
        inferinfo: ::std::os::raw::c_int,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes upper bound of variable in preprocessing or in the current node, if the new bound is tighter"]
    #[doc = "  (w.r.t. bound strengthening epsilon) than the current bound; if possible, adjusts bound to integral value;"]
    #[doc = "  the given inference propagator is stored, such that the conflict analysis is able to find out the reason"]
    #[doc = "  for the deduction of the bound change"]
    #[doc = ""]
    #[doc = "  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via"]
    #[doc = "           SCIPgetVars()) gets resorted."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPinferVarUbProp(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        inferprop: *mut SCIP_PROP,
        inferinfo: ::std::os::raw::c_int,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " depending on SCIP's stage, fixes binary variable in the problem, in preprocessing, or in current node;"]
    #[doc = "  the given inference propagator is stored, such that the conflict analysis is able to find out the reason for the"]
    #[doc = "  deduction of the fixing"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPinferBinvarProp(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        fixedval: ::std::os::raw::c_uint,
        inferprop: *mut SCIP_PROP,
        inferinfo: ::std::os::raw::c_int,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes global lower bound of variable in preprocessing or in the current node, if the new bound is tighter"]
    #[doc = "  (w.r.t. bound strengthening epsilon) than the current global bound; if possible, adjusts bound to integral value;"]
    #[doc = "  also tightens the local bound, if the global bound is better than the local bound"]
    #[doc = ""]
    #[doc = "  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via"]
    #[doc = "           SCIPgetVars()) gets resorted."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPtightenVarLbGlobal(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes global upper bound of variable in preprocessing or in the current node, if the new bound is tighter"]
    #[doc = "  (w.r.t. bound strengthening epsilon) than the current global bound; if possible, adjusts bound to integral value;"]
    #[doc = "  also tightens the local bound, if the global bound is better than the local bound"]
    #[doc = ""]
    #[doc = "  @warning If SCIP is in presolving stage, it can happen that the internal variable array (which can be accessed via"]
    #[doc = "           SCIPgetVars()) gets resorted."]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = "  @note During presolving, an integer variable whose bound changes to {0,1} is upgraded to a binary variable."]
    pub fn SCIPtightenVarUbGlobal(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        newbound: f64,
        force: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        tightened: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " for a multi-aggregated variable, returns the global lower bound computed by adding the global bounds from all aggregation variables"]
    #[doc = ""]
    #[doc = "  This global bound may be tighter than the one given by SCIPvarGetLbGlobal, since the latter is not updated if bounds of aggregation variables are changing"]
    #[doc = "  calling this function for a non-multi-aggregated variable results in a call to SCIPvarGetLbGlobal."]
    #[doc = ""]
    #[doc = "  @return the global lower bound computed by adding the global bounds from all aggregation variables"]
    pub fn SCIPcomputeVarLbGlobal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " for a multi-aggregated variable, returns the global upper bound computed by adding the global bounds from all aggregation variables"]
    #[doc = ""]
    #[doc = "  This global bound may be tighter than the one given by SCIPvarGetUbGlobal, since the latter is not updated if bounds of aggregation variables are changing"]
    #[doc = "  calling this function for a non-multi-aggregated variable results in a call to SCIPvarGetUbGlobal."]
    #[doc = ""]
    #[doc = "  @return the global upper bound computed by adding the global bounds from all aggregation variables"]
    pub fn SCIPcomputeVarUbGlobal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " for a multi-aggregated variable, returns the local lower bound computed by adding the local bounds from all aggregation variables"]
    #[doc = ""]
    #[doc = "  This local bound may be tighter than the one given by SCIPvarGetLbLocal, since the latter is not updated if bounds of aggregation variables are changing"]
    #[doc = "  calling this function for a non-multi-aggregated variable results in a call to SCIPvarGetLbLocal."]
    #[doc = ""]
    #[doc = "  @return the local lower bound computed by adding the global bounds from all aggregation variables"]
    pub fn SCIPcomputeVarLbLocal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " for a multi-aggregated variable, returns the local upper bound computed by adding the local bounds from all aggregation variables"]
    #[doc = ""]
    #[doc = "  This local bound may be tighter than the one given by SCIPvarGetUbLocal, since the latter is not updated if bounds of aggregation variables are changing"]
    #[doc = "  calling this function for a non-multi-aggregated variable results in a call to SCIPvarGetUbLocal."]
    #[doc = ""]
    #[doc = "  @return the local upper bound computed by adding the global bounds from all aggregation variables"]
    pub fn SCIPcomputeVarUbLocal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " for a multi-aggregated variable, gives the global lower bound computed by adding the global bounds from all"]
    #[doc = "  aggregation variables, this global bound may be tighter than the one given by SCIPvarGetLbGlobal, since the latter is"]
    #[doc = "  not updated if bounds of aggregation variables are changing"]
    #[doc = ""]
    #[doc = "  calling this function for a non-multi-aggregated variable is not allowed"]
    pub fn SCIPgetVarMultaggrLbGlobal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " for a multi-aggregated variable, gives the global upper bound computed by adding the global bounds from all"]
    #[doc = "  aggregation variables, this upper bound may be tighter than the one given by SCIPvarGetUbGlobal, since the latter is"]
    #[doc = "  not updated if bounds of aggregation variables are changing"]
    #[doc = ""]
    #[doc = "  calling this function for a non-multi-aggregated variable is not allowed"]
    pub fn SCIPgetVarMultaggrUbGlobal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " for a multi-aggregated variable, gives the local lower bound computed by adding the local bounds from all"]
    #[doc = "  aggregation variables, this lower bound may be tighter than the one given by SCIPvarGetLbLocal, since the latter is"]
    #[doc = "  not updated if bounds of aggregation variables are changing"]
    #[doc = ""]
    #[doc = "  calling this function for a non-multi-aggregated variable is not allowed"]
    pub fn SCIPgetVarMultaggrLbLocal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " for a multi-aggregated variable, gives the local upper bound computed by adding the local bounds from all"]
    #[doc = "  aggregation variables, this upper bound may be tighter than the one given by SCIPvarGetUbLocal, since the latter is"]
    #[doc = "  not updated if bounds of aggregation variables are changing"]
    #[doc = ""]
    #[doc = "  calling this function for a non-multi-aggregated variable is not allowed"]
    pub fn SCIPgetVarMultaggrUbLocal(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns solution value and index of variable lower bound that is closest to the variable's value in the given primal"]
    #[doc = "  solution or current LP solution if no primal solution is given; returns an index of -1 if no variable lower bound is"]
    #[doc = "  available"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarClosestVlb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        sol: *mut SCIP_SOL,
        closestvlb: *mut f64,
        closestvlbidx: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns solution value and index of variable upper bound that is closest to the variable's value in the given primal solution;"]
    #[doc = "  or current LP solution if no primal solution is given; returns an index of -1 if no variable upper bound is available"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPgetVarClosestVub(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        sol: *mut SCIP_SOL,
        closestvub: *mut f64,
        closestvubidx: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " informs variable x about a globally valid variable lower bound x >= b*z + d with integer variable z;"]
    #[doc = "  if z is binary, the corresponding valid implication for z is also added;"]
    #[doc = "  if z is non-continuous and 1/b not too small, the corresponding valid upper/lower bound"]
    #[doc = "  z <= (x-d)/b or z >= (x-d)/b (depending on the sign of of b) is added, too;"]
    #[doc = "  improves the global bounds of the variable and the vlb variable if possible"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarVlb(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        vlbvar: *mut SCIP_VAR,
        vlbcoef: f64,
        vlbconstant: f64,
        infeasible: *mut ::std::os::raw::c_uint,
        nbdchgs: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " informs variable x about a globally valid variable upper bound x <= b*z + d with integer variable z;"]
    #[doc = "  if z is binary, the corresponding valid implication for z is also added;"]
    #[doc = "  if z is non-continuous and 1/b not too small, the corresponding valid lower/upper bound"]
    #[doc = "  z >= (x-d)/b or z <= (x-d)/b (depending on the sign of of b) is added, too;"]
    #[doc = "  improves the global bounds of the variable and the vlb variable if possible"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarVub(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        vubvar: *mut SCIP_VAR,
        vubcoef: f64,
        vubconstant: f64,
        infeasible: *mut ::std::os::raw::c_uint,
        nbdchgs: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " informs binary variable x about a globally valid implication:  x == 0 or x == 1  ==>  y <= b  or  y >= b;"]
    #[doc = "  also adds the corresponding implication or variable bound to the implied variable;"]
    #[doc = "  if the implication is conflicting, the variable is fixed to the opposite value;"]
    #[doc = "  if the variable is already fixed to the given value, the implication is performed immediately;"]
    #[doc = "  if the implication is redundant with respect to the variables' global bounds, it is ignored"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarImplication(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        varfixing: ::std::os::raw::c_uint,
        implvar: *mut SCIP_VAR,
        impltype: SCIP_BOUNDTYPE,
        implbound: f64,
        infeasible: *mut ::std::os::raw::c_uint,
        nbdchgs: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds a clique information to SCIP, stating that at most one of the given binary variables can be set to 1;"]
    #[doc = "  if a variable appears twice in the same clique, the corresponding implications are performed"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddClique(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        values: *mut ::std::os::raw::c_uint,
        nvars: ::std::os::raw::c_int,
        isequation: ::std::os::raw::c_uint,
        infeasible: *mut ::std::os::raw::c_uint,
        nbdchgs: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calculates a partition of the given set of binary variables into cliques; takes into account independent clique components"]
    #[doc = ""]
    #[doc = "  The algorithm performs the following steps:"]
    #[doc = "  - recomputes connected components of the clique table, if necessary"]
    #[doc = "  - computes a clique partition for every connected component greedily."]
    #[doc = "  - relabels the resulting clique partition such that it satisfies the description below"]
    #[doc = ""]
    #[doc = "  afterwards the output array contains one value for each variable, such that two variables got the same value iff they"]
    #[doc = "  were assigned to the same clique;"]
    #[doc = "  the first variable is always assigned to clique 0, and a variable can only be assigned to clique i if at least one of"]
    #[doc = "  the preceding variables was assigned to clique i-1;"]
    #[doc = "  for each clique at most 1 variables can be set to TRUE in a feasible solution;"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcalcCliquePartition(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        cliquepartition: *mut ::std::os::raw::c_int,
        ncliques: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " calculates a partition of the given set of binary variables into negated cliques;"]
    #[doc = "  afterwards the output array contains one value for each variable, such that two variables got the same value iff they"]
    #[doc = "  were assigned to the same negated clique;"]
    #[doc = "  the first variable is always assigned to clique 0 and a variable can only be assigned to clique i if at least one of"]
    #[doc = "  the preceding variables was assigned to clique i-1;"]
    #[doc = "  for each clique with n_c variables at least n_c-1 variables can be set to TRUE in a feasible solution;"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPcalcNegatedCliquePartition(
        scip: *mut SCIP,
        vars: *mut *mut SCIP_VAR,
        nvars: ::std::os::raw::c_int,
        cliquepartition: *mut ::std::os::raw::c_int,
        ncliques: *mut ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " force SCIP to clean up all cliques; cliques do not get automatically cleaned up after presolving. Use"]
    #[doc = "  this method to prevent inactive variables in cliques when retrieved via SCIPgetCliques()"]
    #[doc = ""]
    #[doc = "  @return SCIP_OKAY if everything worked, otherwise a suitable error code is passed"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPcleanupCliques(
        scip: *mut SCIP,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the number of cliques in the clique table"]
    #[doc = ""]
    #[doc = "  @return number of cliques in the clique table"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNCliques(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the number of cliques created so far by the cliquetable"]
    #[doc = ""]
    #[doc = "  @return number of cliques created so far by the cliquetable"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetNCliquesCreated(scip: *mut SCIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " gets the array of cliques in the clique table"]
    #[doc = ""]
    #[doc = "  @return array of cliques in the clique table"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPgetCliques(scip: *mut SCIP) -> *mut *mut SCIP_CLIQUE;
}
extern "C" {
    #[doc = " returns whether there is a clique that contains both given variable/value pairs;"]
    #[doc = "  the variables must be active binary variables;"]
    #[doc = "  if regardimplics is FALSE, only the cliques in the clique table are looked at;"]
    #[doc = "  if regardimplics is TRUE, both the cliques and the implications of the implication graph are regarded"]
    #[doc = ""]
    #[doc = "  @return TRUE, if there is a clique that contains both variable/clique pairs; FALSE, otherwise"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = ""]
    #[doc = "  @note a variable with it's negated variable are NOT! in a clique"]
    #[doc = "  @note a variable with itself are in a clique"]
    pub fn SCIPhaveVarsCommonClique(
        scip: *mut SCIP,
        var1: *mut SCIP_VAR,
        value1: ::std::os::raw::c_uint,
        var2: *mut SCIP_VAR,
        value2: ::std::os::raw::c_uint,
        regardimplics: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " writes the clique graph to a gml file"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = ""]
    #[doc = "  @note there can be duplicated arcs in the output file"]
    #[doc = ""]
    #[doc = "  If @p writenodeweights is true, only nodes corresponding to variables that have a fractional value and only edges"]
    #[doc = "  between such nodes are written."]
    pub fn SCIPwriteCliqueGraph(
        scip: *mut SCIP,
        fname: *const ::std::os::raw::c_char,
        writenodeweights: ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " Removes (irrelevant) variable from all its global structures, i.e. cliques, implications and variable bounds."]
    #[doc = "  This is an advanced method which should be used with care."]
    #[doc = ""]
    #[doc = "  @return SCIP_OKAY if everything worked, otherwise a suitable error code is passed"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    pub fn SCIPremoveVarFromGlobalStructures(scip: *mut SCIP, var: *mut SCIP_VAR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the branch factor of the variable; this value can be used in the branching methods to scale the score"]
    #[doc = "  values of the variables; higher factor leads to a higher probability that this variable is chosen for branching"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarBranchFactor(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        branchfactor: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " scales the branch factor of the variable with the given value"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPscaleVarBranchFactor(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        scale: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds the given value to the branch factor of the variable"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarBranchFactor(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        addfactor: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the branch priority of the variable; variables with higher branch priority are always preferred to variables"]
    #[doc = "  with lower priority in selection of branching variable"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = ""]
    #[doc = " @note the default branching priority is 0"]
    pub fn SCIPchgVarBranchPriority(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        branchpriority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes the branch priority of the variable to the given value, if it is larger than the current priority"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPupdateVarBranchPriority(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        branchpriority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " adds the given value to the branch priority of the variable"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPaddVarBranchPriority(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        addpriority: ::std::os::raw::c_int,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " sets the branch direction of the variable (-1: prefer downwards branch, 0: automatic selection, +1: prefer upwards"]
    #[doc = "  branch)"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPchgVarBranchDirection(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        branchdirection: SCIP_BRANCHDIR,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " changes type of variable in the problem;"]
    #[doc = ""]
    #[doc = "  @warning This type change might change the variable array returned from SCIPgetVars() and SCIPgetVarsData();"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = ""]
    #[doc = "  @note If SCIP is already beyond the SCIP_STAGE_PROBLEM and a original variable is passed, the variable type of the"]
    #[doc = "        corresponding transformed variable is changed; the type of the original variable does not change"]
    #[doc = ""]
    #[doc = "  @note If the type changes from a continuous variable to a non-continuous variable the bounds of the variable get"]
    #[doc = "        adjusted w.r.t. to integrality information"]
    pub fn SCIPchgVarType(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        vartype: SCIP_VARTYPE,
        infeasible: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " in problem creation and solving stage, both bounds of the variable are set to the given value;"]
    #[doc = "  in presolving stage, the variable is converted into a fixed variable, and bounds are changed respectively;"]
    #[doc = "  conversion into a fixed variable changes the vars array returned from SCIPgetVars() and SCIPgetVarsData(),"]
    #[doc = "  and also renders arrays returned from the SCIPvarGetImpl...() methods invalid"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPfixVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        fixedval: f64,
        infeasible: *mut ::std::os::raw::c_uint,
        fixed: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " From a given equality a*x + b*y == c, aggregates one of the variables and removes it from the set of"]
    #[doc = "  active problem variables. This changes the vars array returned from SCIPgetVars() and SCIPgetVarsData(),"]
    #[doc = "  and also renders the arrays returned from the SCIPvarGetImpl...() methods for the two variables invalid."]
    #[doc = "  In the first step, the equality is transformed into an equality with active problem variables"]
    #[doc = "  a'*x' + b'*y' == c'. If x' == y', this leads to the detection of redundancy if a' == -b' and c' == 0,"]
    #[doc = "  of infeasibility, if a' == -b' and c' != 0, or to a variable fixing x' == c'/(a'+b') (and possible"]
    #[doc = "  infeasibility) otherwise."]
    #[doc = "  In the second step, the variable to be aggregated is chosen among x' and y', prefering a less strict variable"]
    #[doc = "  type as aggregation variable (i.e. continuous variables are preferred over implicit integers, implicit integers"]
    #[doc = "  over integers, and integers over binaries). If none of the variables is continuous, it is tried to find an integer"]
    #[doc = "  aggregation (i.e. integral coefficients a'' and b'', such that a''*x' + b''*y' == c''). This can lead to"]
    #[doc = "  the detection of infeasibility (e.g. if c'' is fractional), or to a rejection of the aggregation (denoted by"]
    #[doc = "  aggregated == FALSE), if the resulting integer coefficients are too large and thus numerically instable."]
    #[doc = ""]
    #[doc = "  The output flags have the following meaning:"]
    #[doc = "  - infeasible: the problem is infeasible"]
    #[doc = "  - redundant:  the equality can be deleted from the constraint set"]
    #[doc = "  - aggregated: the aggregation was successfully performed (the variables were not aggregated before)"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_PRESOLVING"]
    pub fn SCIPaggregateVars(
        scip: *mut SCIP,
        varx: *mut SCIP_VAR,
        vary: *mut SCIP_VAR,
        scalarx: f64,
        scalary: f64,
        rhs: f64,
        infeasible: *mut ::std::os::raw::c_uint,
        redundant: *mut ::std::os::raw::c_uint,
        aggregated: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " converts variable into multi-aggregated variable; this changes the variable array returned from"]
    #[doc = "  SCIPgetVars() and SCIPgetVarsData();"]
    #[doc = ""]
    #[doc = "  @warning The integrality condition is not checked anymore on the multi-aggregated variable. You must not"]
    #[doc = "           multi-aggregate an integer variable without being sure, that integrality on the aggregation variables"]
    #[doc = "           implies integrality on the aggregated variable."]
    #[doc = ""]
    #[doc = "  The output flags have the following meaning:"]
    #[doc = "  - infeasible: the problem is infeasible"]
    #[doc = "  - aggregated: the aggregation was successfully performed (the variables were not aggregated before)"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can only be called if @p scip is in stage \\ref SCIP_STAGE_PRESOLVING"]
    pub fn SCIPmultiaggregateVar(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        naggvars: ::std::os::raw::c_int,
        aggvars: *mut *mut SCIP_VAR,
        scalars: *mut f64,
        constant: f64,
        infeasible: *mut ::std::os::raw::c_uint,
        aggregated: *mut ::std::os::raw::c_uint,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns whether aggregation of variables is not allowed"]
    pub fn SCIPdoNotAggr(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether multi-aggregation is disabled"]
    pub fn SCIPdoNotMultaggr(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether variable is not allowed to be multi-aggregated"]
    pub fn SCIPdoNotMultaggrVar(scip: *mut SCIP, var: *mut SCIP_VAR) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether dual reductions are allowed during propagation and presolving"]
    #[doc = ""]
    #[doc = "  @deprecated Please use SCIPallowStrongDualReds()"]
    pub fn SCIPallowDualReds(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether strong dual reductions are allowed during propagation and presolving"]
    #[doc = ""]
    #[doc = "  @note A reduction is called strong dual, if it may discard feasible/optimal solutions, but leaves at least one"]
    #[doc = "        optimal solution intact. Often such reductions are based on analyzing the objective function and variable"]
    #[doc = "        locks."]
    pub fn SCIPallowStrongDualReds(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether propagation w.r.t. current objective is allowed"]
    #[doc = ""]
    #[doc = "  @deprecated Please use SCIPallowWeakDualReds()"]
    pub fn SCIPallowObjProp(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " returns whether weak dual reductions are allowed during propagation and presolving"]
    #[doc = ""]
    #[doc = "  @note A reduction is called weak dual, if it may discard feasible solutions, but leaves at all optimal solutions"]
    #[doc = "        intact. Often such reductions are based on analyzing the objective function, reduced costs, and/or dual LPs."]
    pub fn SCIPallowWeakDualReds(scip: *mut SCIP) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " marks the variable that it must not be multi-aggregated"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INIT"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = ""]
    #[doc = "  @note There exists no \"unmark\" method since it has to be ensured that if a plugin requires that a variable is not"]
    #[doc = "        multi-aggregated that this is will be the case."]
    pub fn SCIPmarkDoNotMultaggrVar(scip: *mut SCIP, var: *mut SCIP_VAR) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " enables the collection of statistics for a variable"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPenableVarHistory(scip: *mut SCIP);
}
extern "C" {
    #[doc = " disables the collection of any statistic for a variable"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPdisableVarHistory(scip: *mut SCIP);
}
extern "C" {
    #[doc = " updates the pseudo costs of the given variable and the global pseudo costs after a change of \"solvaldelta\" in the"]
    #[doc = "  variable's solution value and resulting change of \"objdelta\" in the in the LP's objective value;"]
    #[doc = "  the update is ignored, if the objective value difference is infinite"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPupdateVarPseudocost(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        solvaldelta: f64,
        objdelta: f64,
        weight: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " gets the variable's pseudo cost value for the given change of the variable's LP value"]
    #[doc = ""]
    #[doc = "  @return the variable's pseudo cost value for the given change of the variable's LP value"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostVal(scip: *mut SCIP, var: *mut SCIP_VAR, solvaldelta: f64) -> f64;
}
extern "C" {
    #[doc = " gets the variable's pseudo cost value for the given change of the variable's LP value,"]
    #[doc = "  only using the pseudo cost information of the current run"]
    #[doc = ""]
    #[doc = "  @return the variable's pseudo cost value for the given change of the variable's LP value,"]
    #[doc = "  only using the pseudo cost information of the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostValCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        solvaldelta: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " gets the variable's pseudo cost value for the given direction"]
    #[doc = ""]
    #[doc = "  @return the variable's pseudo cost value for the given direction"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocost(scip: *mut SCIP, var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " gets the variable's pseudo cost value for the given direction,"]
    #[doc = "  only using the pseudo cost information of the current run"]
    #[doc = ""]
    #[doc = "  @return the variable's pseudo cost value for the given direction,"]
    #[doc = "  only using the pseudo cost information of the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
extern "C" {
    #[doc = " gets the variable's (possible fractional) number of pseudo cost updates for the given direction"]
    #[doc = ""]
    #[doc = "  @return the variable's (possible fractional) number of pseudo cost updates for the given direction"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostCount(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
extern "C" {
    #[doc = " gets the variable's (possible fractional) number of pseudo cost updates for the given direction,"]
    #[doc = "  only using the pseudo cost information of the current run"]
    #[doc = ""]
    #[doc = "  @return the variable's (possible fractional) number of pseudo cost updates for the given direction,"]
    #[doc = "  only using the pseudo cost information of the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostCountCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
extern "C" {
    #[doc = " get pseudo cost variance of the variable, either for entire solve or only for current branch and bound run"]
    #[doc = ""]
    #[doc = "  @return returns the (corrected) variance of pseudo code information collected so far."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostVariance(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
        onlycurrentrun: ::std::os::raw::c_uint,
    ) -> f64;
}
extern "C" {
    #[doc = " calculates a confidence bound for this variable under the assumption of normally distributed pseudo costs"]
    #[doc = ""]
    #[doc = "  The confidence bound \\f$ \\theta \\geq 0\\f$ denotes the interval borders \\f$ [X - \\theta, \\ X + \\theta]\\f$, which contains"]
    #[doc = "  the true pseudo costs of the variable, i.e., the expected value of the normal distribution, with a probability"]
    #[doc = "  of 2 * clevel - 1."]
    #[doc = ""]
    #[doc = "  @return value of confidence bound for this variable"]
    pub fn SCIPcalculatePscostConfidenceBound(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
        onlycurrentrun: ::std::os::raw::c_uint,
        clevel: SCIP_CONFIDENCELEVEL,
    ) -> f64;
}
extern "C" {
    #[doc = " check if variable pseudo-costs have a significant difference in location. The significance depends on"]
    #[doc = "  the choice of \\p clevel and on the kind of tested hypothesis. The one-sided hypothesis, which"]
    #[doc = "  should be rejected, is that fracy * mu_y >= fracx * mu_x, where mu_y and mu_x denote the"]
    #[doc = "  unknown location means of the underlying pseudo-cost distributions of x and y."]
    #[doc = ""]
    #[doc = "  This method is applied best if variable x has a better pseudo-cost score than y. The method hypothesizes that y were actually"]
    #[doc = "  better than x (despite the current information), meaning that y can be expected to yield branching"]
    #[doc = "  decisions as least as good as x in the long run. If the method returns TRUE, the current history information is"]
    #[doc = "  sufficient to safely rely on the alternative hypothesis that x yields indeed a better branching score (on average)"]
    #[doc = "  than y."]
    #[doc = ""]
    #[doc = "  @note The order of x and y matters for the one-sided hypothesis"]
    #[doc = ""]
    #[doc = "  @note set \\p onesided to FALSE if you are not sure which variable is better. The hypothesis tested then reads"]
    #[doc = "        fracy * mu_y == fracx * mu_x vs the alternative hypothesis fracy * mu_y != fracx * mu_x."]
    #[doc = ""]
    #[doc = "  @return TRUE if the hypothesis can be safely rejected at the given confidence level"]
    pub fn SCIPsignificantVarPscostDifference(
        scip: *mut SCIP,
        varx: *mut SCIP_VAR,
        fracx: f64,
        vary: *mut SCIP_VAR,
        fracy: f64,
        dir: SCIP_BRANCHDIR,
        clevel: SCIP_CONFIDENCELEVEL,
        onesided: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " tests at a given confidence level whether the variable pseudo-costs only have a small probability to"]
    #[doc = "  exceed a \\p threshold. This is useful to determine if past observations provide enough evidence"]
    #[doc = "  to skip an expensive strong-branching step if there is already a candidate that has been proven to yield an improvement"]
    #[doc = "  of at least \\p threshold."]
    #[doc = ""]
    #[doc = "  @note use \\p clevel to adjust the level of confidence. For SCIP_CONFIDENCELEVEL_MIN, the method returns TRUE if"]
    #[doc = "        the estimated probability to exceed \\p threshold is less than 25 %."]
    #[doc = ""]
    #[doc = "  @see  SCIP_Confidencelevel for a list of available levels. The used probability limits refer to the one-sided levels"]
    #[doc = "        of confidence."]
    #[doc = ""]
    #[doc = "  @return TRUE if the variable pseudo-cost probabilistic model is likely to be smaller than \\p threshold"]
    #[doc = "          at the given confidence level \\p clevel."]
    pub fn SCIPpscostThresholdProbabilityTest(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        frac: f64,
        threshold: f64,
        dir: SCIP_BRANCHDIR,
        clevel: SCIP_CONFIDENCELEVEL,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " check if the current pseudo cost relative error in a direction violates the given threshold. The Relative"]
    #[doc = "  Error is calculated at a specific confidence level"]
    #[doc = ""]
    #[doc = "  @return TRUE if relative error in variable pseudo costs is smaller than \\p threshold"]
    pub fn SCIPisVarPscostRelerrorReliable(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        threshold: f64,
        clevel: SCIP_CONFIDENCELEVEL,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " gets the variable's pseudo cost score value for the given LP solution value"]
    #[doc = ""]
    #[doc = "  @return the variable's pseudo cost score value for the given LP solution value"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostScore(scip: *mut SCIP, var: *mut SCIP_VAR, solval: f64) -> f64;
}
extern "C" {
    #[doc = " gets the variable's pseudo cost score value for the given LP solution value,"]
    #[doc = "  only using the pseudo cost information of the current run"]
    #[doc = ""]
    #[doc = "  @return the variable's pseudo cost score value for the given LP solution value,"]
    #[doc = "  only using the pseudo cost information of the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarPseudocostScoreCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        solval: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the variable's VSIDS value"]
    #[doc = ""]
    #[doc = "  @return the variable's VSIDS value"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarVSIDS(scip: *mut SCIP, var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " returns the variable's VSIDS value only using conflicts of the current run"]
    #[doc = ""]
    #[doc = "  @return the variable's VSIDS value only using conflicts of the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarVSIDSCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the variable's conflict score value"]
    #[doc = ""]
    #[doc = "  @return the variable's conflict score value"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarConflictScore(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the variable's conflict score value only using conflicts of the current run"]
    #[doc = ""]
    #[doc = "  @return the variable's conflict score value only using conflicts of the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarConflictScoreCurrentRun(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the variable's conflict length score"]
    #[doc = ""]
    #[doc = "  @return the variable's conflict length score"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarConflictlengthScore(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the variable's conflict length score only using conflicts of the current run"]
    #[doc = ""]
    #[doc = "  @return the variable's conflict length score only using conflicts of the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarConflictlengthScoreCurrentRun(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the variable's average conflict length"]
    #[doc = ""]
    #[doc = "  @return the variable's average conflict length"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgConflictlength(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the variable's average  conflict length only using conflicts of the current run"]
    #[doc = ""]
    #[doc = "  @return the variable's average conflict length only using conflicts of the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgConflictlengthCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the average number of inferences found after branching on the variable in given direction;"]
    #[doc = "  if branching on the variable in the given direction was yet evaluated, the average number of inferences"]
    #[doc = "  over all variables for branching in the given direction is returned"]
    #[doc = ""]
    #[doc = "  @return the average number of inferences found after branching on the variable in given direction"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgInferences(scip: *mut SCIP, var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR)
        -> f64;
}
extern "C" {
    #[doc = " returns the average number of inferences found after branching on the variable in given direction in the current run;"]
    #[doc = "  if branching on the variable in the given direction was yet evaluated, the average number of inferences"]
    #[doc = "  over all variables for branching in the given direction is returned"]
    #[doc = ""]
    #[doc = "  @return the average number of inferences found after branching on the variable in given direction in the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgInferencesCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the variable's average inference score value"]
    #[doc = ""]
    #[doc = "  @return the variable's average inference score value"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgInferenceScore(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the variable's average inference score value only using inferences of the current run"]
    #[doc = ""]
    #[doc = "  @return the variable's average inference score value only using inferences of the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgInferenceScoreCurrentRun(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " initializes the upwards and downwards pseudocosts, conflict scores, conflict lengths, inference scores, cutoff scores"]
    #[doc = "  of a variable to the given values"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPinitVarBranchStats(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        downpscost: f64,
        uppscost: f64,
        downvsids: f64,
        upvsids: f64,
        downconflen: f64,
        upconflen: f64,
        downinfer: f64,
        upinfer: f64,
        downcutoff: f64,
        upcutoff: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " initializes the upwards and downwards conflict scores, conflict lengths, inference scores, cutoff scores of a"]
    #[doc = "  variable w.r.t. a value by the given values (SCIP_VALUEHISTORY)"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    pub fn SCIPinitVarValueBranchStats(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        value: f64,
        downvsids: f64,
        upvsids: f64,
        downconflen: f64,
        upconflen: f64,
        downinfer: f64,
        upinfer: f64,
        downcutoff: f64,
        upcutoff: f64,
    ) -> SCIP_RETCODE;
}
extern "C" {
    #[doc = " returns the average number of cutoffs found after branching on the variable in given direction;"]
    #[doc = "  if branching on the variable in the given direction was yet evaluated, the average number of cutoffs"]
    #[doc = "  over all variables for branching in the given direction is returned"]
    #[doc = ""]
    #[doc = "  @return the average number of cutoffs found after branching on the variable in given direction"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgCutoffs(scip: *mut SCIP, var: *mut SCIP_VAR, dir: SCIP_BRANCHDIR) -> f64;
}
extern "C" {
    #[doc = " returns the average number of cutoffs found after branching on the variable in given direction in the current run;"]
    #[doc = "  if branching on the variable in the given direction was yet evaluated, the average number of cutoffs"]
    #[doc = "  over all variables for branching in the given direction is returned"]
    #[doc = ""]
    #[doc = "  @return the average number of cutoffs found after branching on the variable in given direction in the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgCutoffsCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        dir: SCIP_BRANCHDIR,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the variable's average cutoff score value"]
    #[doc = ""]
    #[doc = "  @return the variable's average cutoff score value"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgCutoffScore(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the variable's average cutoff score value, only using cutoffs of the current run"]
    #[doc = ""]
    #[doc = "  @return the variable's average cutoff score value, only using cutoffs of the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgCutoffScoreCurrentRun(scip: *mut SCIP, var: *mut SCIP_VAR) -> f64;
}
extern "C" {
    #[doc = " returns the variable's average inference/cutoff score value, weighting the cutoffs of the variable with the given"]
    #[doc = "  factor"]
    #[doc = ""]
    #[doc = "  @return the variable's average inference/cutoff score value"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgInferenceCutoffScore(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        cutoffweight: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " returns the variable's average inference/cutoff score value, weighting the cutoffs of the variable with the given"]
    #[doc = "  factor, only using inferences and cutoffs of the current run"]
    #[doc = ""]
    #[doc = "  @return the variable's average inference/cutoff score value, only using inferences and cutoffs of the current run"]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    pub fn SCIPgetVarAvgInferenceCutoffScoreCurrentRun(
        scip: *mut SCIP,
        var: *mut SCIP_VAR,
        cutoffweight: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " outputs variable information to file stream via the message system"]
    #[doc = ""]
    #[doc = "  @return \\ref SCIP_OKAY is returned if everything worked. Otherwise a suitable error code is passed. See \\ref"]
    #[doc = "          SCIP_Retcode \"SCIP_RETCODE\" for a complete list of error codes."]
    #[doc = ""]
    #[doc = "  @pre This method can be called if @p scip is in one of the following stages:"]
    #[doc = "       - \\ref SCIP_STAGE_PROBLEM"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMING"]
    #[doc = "       - \\ref SCIP_STAGE_TRANSFORMED"]
    #[doc = "       - \\ref SCIP_STAGE_INITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_EXITPRESOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_PRESOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_INITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVING"]
    #[doc = "       - \\ref SCIP_STAGE_SOLVED"]
    #[doc = "       - \\ref SCIP_STAGE_EXITSOLVE"]
    #[doc = "       - \\ref SCIP_STAGE_FREETRANS"]
    #[doc = ""]
    #[doc = "  @note If the message handler is set to a NULL pointer nothing will be printed"]
    pub fn SCIPprintVar(scip: *mut SCIP, var: *mut SCIP_VAR, file: *mut FILE) -> SCIP_RETCODE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
